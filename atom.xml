<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://007havegone.github.io/"/>
  <updated>2019-08-21T16:41:20.456Z</updated>
  <id>http://007havegone.github.io/</id>
  
  <author>
    <name>007havegone</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法导论思考题6-3Young氏矩阵</title>
    <link href="http://007havegone.github.io/2019/08/21/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E6%80%9D%E8%80%83%E9%A2%986-3Young%E6%B0%8F%E7%9F%A9%E9%98%B5/"/>
    <id>http://007havegone.github.io/2019/08/21/算法导论思考题6-3Young氏矩阵/</id>
    <published>2019-08-21T08:32:55.000Z</published>
    <updated>2019-08-21T16:41:20.456Z</updated>
    
    <content type="html"><![CDATA[<h3 id="思考题6-3（Young氏矩阵）在一个-m-times-n-的Young氏矩阵（Young-tableau）中，每一行的数据都是从左到右排序的，每一列的数据都是从上到下排列的。Young氏矩阵中也会存在一些为-infty-的数据项，表示那些不存在的数据。因此，Young氏矩阵可以用来村出-r-leq-mn-个有限的数。"><a href="#思考题6-3（Young氏矩阵）在一个-m-times-n-的Young氏矩阵（Young-tableau）中，每一行的数据都是从左到右排序的，每一列的数据都是从上到下排列的。Young氏矩阵中也会存在一些为-infty-的数据项，表示那些不存在的数据。因此，Young氏矩阵可以用来村出-r-leq-mn-个有限的数。" class="headerlink" title="思考题6-3（Young氏矩阵）在一个$m\times n$的Young氏矩阵（Young tableau）中，每一行的数据都是从左到右排序的，每一列的数据都是从上到下排列的。Young氏矩阵中也会存在一些为 $\infty$ 的数据项，表示那些不存在的数据。因此，Young氏矩阵可以用来村出$r \leq mn$个有限的数。"></a>思考题6-3（Young氏矩阵）在一个$m\times n$的Young氏矩阵（Young tableau）中，每一行的数据都是从左到右排序的，每一列的数据都是从上到下排列的。Young氏矩阵中也会存在一些为 $\infty$ 的数据项，表示那些不存在的数据。因此，Young氏矩阵可以用来村出$r \leq mn$个有限的数。</h3><h4 id="a-emsp-画出一个包含元素-9，16，3，2，4，8，5，14，12-的-4-times-4-Young氏矩阵。"><a href="#a-emsp-画出一个包含元素-9，16，3，2，4，8，5，14，12-的-4-times-4-Young氏矩阵。" class="headerlink" title="a.&emsp;画出一个包含元素$\{9，16，3，2，4，8，5，14，12\}$的$4 \times 4$Young氏矩阵。"></a>a.&emsp;画出一个包含元素$\{9，16，3，2，4，8，5，14，12\}$的$4 \times 4$Young氏矩阵。</h4><p>第一题比较简单，只要满足插入和每行每列都是非递减就行。<br>下面示例：</p><script type="math/tex; mode=display">\begin{bmatrix} 2 & 5 & 8 & \infty \\                  3 & 9 & 14 & \infty \\                  4 & 12 & 16 & \infty \\                   \infty & \infty  & \infty & \infty \\ \end{bmatrix}</script><p>采用不同规则最终效果不同，只要满足其定义即可。</p><p><strong>在后面的实现中我们为了简化边界检查，我们实际的矩阵实现行数和列数要比实际大2，Y的存储位置为$[1,1]$到$[M,N]$。</strong><br>$4 \times 4$的Young氏矩阵的实际存储空间。</p><script type="math/tex; mode=display">\begin{bmatrix}                  -\infty& -\infty & -\infty & -\infty & -\infty &-\infty \\                  -\infty& 2 & 5 & 8 & \infty & \infty\\                  -\infty & 3 & 9 & 14 & \infty & \infty \\                   -\infty & 4 & 12 & 16 & \infty & \infty \\                   -\infty & \infty  & \infty & \infty & \infty & \infty\\ \end{bmatrix}</script><p>采取这种方案，当达到边界时，不会越界。</p><h4 id="b-emsp-对于一个-m-times-n-的Young氏矩阵来说，请证明：如果-Y-1-1-infty-，则-Y-为空；如果-Y-m-n-lt-infty-，则-Y-为满（即包含-mn-个元素）。"><a href="#b-emsp-对于一个-m-times-n-的Young氏矩阵来说，请证明：如果-Y-1-1-infty-，则-Y-为空；如果-Y-m-n-lt-infty-，则-Y-为满（即包含-mn-个元素）。" class="headerlink" title="b.&emsp;对于一个$m \times n$的Young氏矩阵来说，请证明：如果$Y[1,1]=\infty$，则$Y$为空；如果$Y[m,n]&lt; \infty$，则$Y$为满（即包含$mn$个元素）。"></a>b.&emsp;对于一个$m \times n$的Young氏矩阵来说，请证明：如果$Y[1,1]=\infty$，则$Y$为空；如果$Y[m,n]&lt; \infty$，则$Y$为满（即包含$mn$个元素）。</h4><p>这道题比较简单，根据定义就可以快速得出。<br>证明：根据Young氏矩阵的定义，$Y[i,j] \leq Y[i+k1,j+k2]，\forall i,i+k1 \leq m$ 且 $j,j+k2 \leq n$。即$Y[1,1]$为矩阵的最小值，$Y[m,n]$为最大值。</p><p>如果$Y[1,1]=\infty$，则矩阵其他元素均为$\infty$，即为空。若$Y[m,n]&lt; \infty$，则其他元素均小于$\infty$，故$Y$为满。</p><h4 id="c-emsp-请给出一个在-m-times-n-Young氏矩阵上时间复杂度为-O-m-n-的EXTRACT-MIN的算法实现。你的算法可以考虑使用一个递归过程，它把一个规模为-m-times-n-的问题分解为规模为-m-1-times-n-或-m-times-n-1-的子问题（提示：考虑使用MAX-HEAPFY）。这里，定义T-p-用来表示在任意-m-times-n-的Young氏矩阵上的时间复杂度，其中-p-m-n-。给出并求解-T-p-的递归表达式，其结果为-O-m-n-。"><a href="#c-emsp-请给出一个在-m-times-n-Young氏矩阵上时间复杂度为-O-m-n-的EXTRACT-MIN的算法实现。你的算法可以考虑使用一个递归过程，它把一个规模为-m-times-n-的问题分解为规模为-m-1-times-n-或-m-times-n-1-的子问题（提示：考虑使用MAX-HEAPFY）。这里，定义T-p-用来表示在任意-m-times-n-的Young氏矩阵上的时间复杂度，其中-p-m-n-。给出并求解-T-p-的递归表达式，其结果为-O-m-n-。" class="headerlink" title="c.&emsp;请给出一个在$m \times n$ Young氏矩阵上时间复杂度为$O(m+n)$的EXTRACT-MIN的算法实现。你的算法可以考虑使用一个递归过程，它把一个规模为$m \times n$的问题分解为规模为$(m-1) \times n$或$m \times (n-1)$的子问题（提示：考虑使用MAX-HEAPFY）。这里，定义T(p)用来表示在任意$m \times n$的Young氏矩阵上的时间复杂度，其中$p = m+n$。给出并求解$T(p)$的递归表达式，其结果为$O(m+n)$。"></a>c.&emsp;请给出一个在$m \times n$ Young氏矩阵上时间复杂度为$O(m+n)$的EXTRACT-MIN的算法实现。你的算法可以考虑使用一个递归过程，它把一个规模为$m \times n$的问题分解为规模为$(m-1) \times n$或$m \times (n-1)$的子问题（提示：考虑使用MAX-HEAPFY）。这里，定义T(p)用来表示在任意$m \times n$的Young氏矩阵上的时间复杂度，其中$p = m+n$。给出并求解$T(p)$的递归表达式，其结果为$O(m+n)$。</h4><p>这个实现上也比较简单。如下：</p><ul><li>在$Y$非空时，将$Y[1,1]$用$\infty$替换</li></ul><p>然后重新调整$\infty$的位置，记当前位置在$Y[i,j]$，让其满足定义。</p><ul><li>取其下面元素$Y[i+1,j]$和右边元素$Y[i,j+1]$的最小值$mix$，若$min \neq \infty$交换它和$\infty$的位置。</li><li>当达到矩阵边界，或$min = \infty$，此时结束。</li></ul><p>下面是伪代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">extractMin(Y)</span><br><span class="line">    <span class="keyword">if</span>(!Y.empty())<span class="comment">//非空</span></span><br><span class="line">        Y[<span class="number">1</span>][<span class="number">1</span>] = INF;<span class="comment">//第一个元素置为INF</span></span><br><span class="line">        MinFixup(Y,Loc&#123;<span class="number">1</span>,<span class="number">1</span>&#125;);<span class="comment">//调整</span></span><br><span class="line"></span><br><span class="line">MinFixup(Young,loc)</span><br><span class="line">    t = Y[loc.x][loc.y]</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span>(Y[loc.x][loc.y+<span class="number">1</span>] &lt; Y[loc.x+<span class="number">1</span>][loc.y])<span class="comment">//获取下方和右边小的数的位置</span></span><br><span class="line">            small = &#123;loc.x,loc.y+<span class="number">1</span>&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            small = &#123;loc.x+<span class="number">1</span>,loc.y&#125;</span><br><span class="line">        <span class="keyword">if</span>(Y[small.x][small.y] &lt; t)</span><br><span class="line">            Y[loc.x][loc.y] = Y[small.x][small.y]</span><br><span class="line">            loc = small</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    Y[loc.x][loc.y] = t</span><br></pre></td></tr></table></figure></p><p>该过程相当于一个棋子从左上角向右下方行走，每次交换后$i=i+1$或$j=j+1$，最多交换$m+n$次，总是时间复杂度为$O(m+m)$。</p><h4 id="d-emsp-是说明如何在-O-m-n-的时间内，将一个元素插入到一个未满的-m-times-n-的Young氏矩阵中。"><a href="#d-emsp-是说明如何在-O-m-n-的时间内，将一个元素插入到一个未满的-m-times-n-的Young氏矩阵中。" class="headerlink" title="d.&emsp;是说明如何在$O(m+n)$的时间内，将一个元素插入到一个未满的$m \times n$的Young氏矩阵中。"></a>d.&emsp;是说明如何在$O(m+n)$的时间内，将一个元素插入到一个未满的$m \times n$的Young氏矩阵中。</h4><p>类似二叉堆的插入过程，我们将新的元素放置在矩阵的最后一个位置$Y[m,n]$，类似题目c相反，让它与上面的元素$Y[m-1,n]$或左边的元素$Y[m,n-1]$比较，取它们的最大值$max$，若$max\leq Y[m,n]$，那么此时满足，否则，取用$max$与它交换。直到达到达到边界或满足Young氏矩阵的定义。</p><p>下面是伪代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">insert(Y,x)</span><br><span class="line"> <span class="keyword">if</span>(!Y.full())</span><br><span class="line">    Y[M][N] = x</span><br><span class="line">    MaxFixup(Loc&#123;M,N&#125;);</span><br><span class="line"></span><br><span class="line">MaxFixup(Y,loc)</span><br><span class="line">    t = Y[loc.x][loc.y]</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span>(Y[loc.x][loc.y<span class="number">-1</span>] &lt; Y[loc.x<span class="number">-1</span>][loc.y])</span><br><span class="line">            lager = &#123;loc.x,loc.y<span class="number">-1</span>&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            small = &#123;loc.x<span class="number">-1</span>,loc.y&#125;</span><br><span class="line">        <span class="keyword">if</span>(Y[lager.x][lager.y] &gt; t)</span><br><span class="line">            Y[loc.x][loc.y] = Y[lager.x][lager.y]</span><br><span class="line">            loc = lager</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    Y[loc.x][loc.y] = t</span><br></pre></td></tr></table></figure></p><h4 id="e-emsp-在不用其他排序算法的情况下，是说明如何利用一个-n-times-n-的Young氏矩阵在-O-n-3-时间内将-n-2-个数进行排列。"><a href="#e-emsp-在不用其他排序算法的情况下，是说明如何利用一个-n-times-n-的Young氏矩阵在-O-n-3-时间内将-n-2-个数进行排列。" class="headerlink" title="e.&emsp;在不用其他排序算法的情况下，是说明如何利用一个$n \times n$的Young氏矩阵在$O(n^3)$时间内将$n^2$个数进行排列。"></a>e.&emsp;在不用其他排序算法的情况下，是说明如何利用一个$n \times n$的Young氏矩阵在$O(n^3)$时间内将$n^2$个数进行排列。</h4><p>将$n \times n$个元素插入Young氏矩阵中，花费$O(n^3)$，然后将他们意义取出即可，也是花费$O(n^3)$。故总的时间复杂度为$O(n^3)$。</p><h4 id="f-emsp-设计一个时间复杂度为-O-m-n-的算法，它可以用来判断一个给定的数是否存储在-m-times-n-的Young氏矩阵内。"><a href="#f-emsp-设计一个时间复杂度为-O-m-n-的算法，它可以用来判断一个给定的数是否存储在-m-times-n-的Young氏矩阵内。" class="headerlink" title="f.&emsp;设计一个时间复杂度为$O(m+n)$的算法，它可以用来判断一个给定的数是否存储在$m \times n$的Young氏矩阵内。"></a>f.&emsp;设计一个时间复杂度为$O(m+n)$的算法，它可以用来判断一个给定的数是否存储在$m \times n$的Young氏矩阵内。</h4><p>查找一个数$x$，我们可以从左下角或右上角开始搜索。不能从左上角或右下角进行，例如左上角来说，当我们查找点元素大于$Y[1,1]$时，若往右或下均是大于$x$时，我们不知道往那个方向，有可能选择方向错误后，后面需要回过头来找尝试另一方向，花费额外时间。</p><p>但是如果我们从左下角开始查找，如果$x &lt; Y[m,1]$，那么我们往上继续查找，若$X &gt; T[m,1]$，那么我们往右边查找。这样可以在$O(m+n)$时间内完成。当然，从右上角开始也是一样的效果。</p><p>下面从左下角查找的伪代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">search(Y,t)<span class="comment">//查找t</span></span><br><span class="line">    x = M,y=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(Y[x][y] != INF &amp;&amp; Y[x][y] != -INF)<span class="comment">//未到达边界</span></span><br><span class="line">        <span class="keyword">if</span>(Y[x][y] == t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t &lt; Y[x][y])</span><br><span class="line">            x = x + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            y = y - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Loc</span>//位置定义</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">unsigned</span> M,<span class="keyword">unsigned</span> N=M&gt;</span><br><span class="line">class Youngtableau&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Youngtableau();<span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp;x)</span></span>;<span class="comment">//插入</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">extractMin</span><span class="params">()</span></span>;<span class="comment">//删除</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> matrix[<span class="number">1</span>][<span class="number">1</span>]==INF;&#125;<span class="comment">//判空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> matrix[M][N]!=INF;&#125;<span class="comment">//判满</span></span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> matrix[<span class="number">1</span>][<span class="number">1</span>];&#125;<span class="comment">//返回首元素</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">const</span> T&amp;t)</span></span>;<span class="comment">//查找</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;<span class="comment">//输出</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MinFixup</span><span class="params">(Loc loc)</span></span>;<span class="comment">//调整函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MaxFixup</span><span class="params">(Loc loc)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//底层存储</span></span><br><span class="line">    <span class="comment">//为了方便边界处理，行列多开2个空间，方便处理边界</span></span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="built_in">array</span>&lt;T,N+2&gt;,M+2&gt; matrix;</span><br><span class="line">    Loc ins;<span class="comment">//插入位置[M,N]</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Functions Definition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">unsigned</span> M,<span class="keyword">unsigned</span> N&gt;</span><br><span class="line">Youngtableau&lt;T,M,N&gt;::Youngtableau():ins(&#123;M,N&#125;)</span><br><span class="line">&#123;</span><br><span class="line">        matrix[<span class="number">0</span>].fill(-INF);</span><br><span class="line">        matrix[M+<span class="number">1</span>].fill(INF);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;matrix.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            matrix[i][<span class="number">0</span>]=-INF;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;matrix[i].size();++j)</span><br><span class="line">                matrix[i][j]=INF;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">unsigned</span> M,<span class="keyword">unsigned</span> N&gt;</span><br><span class="line"><span class="keyword">void</span> Youngtableau&lt;T,M,N&gt;::print()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]!=INF)</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; matrix[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"INF "</span>;</span><br><span class="line">            &#125;       </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">unsigned</span> M,<span class="keyword">unsigned</span> N&gt;</span><br><span class="line"><span class="keyword">void</span> Youngtableau&lt;T,M,N&gt;::insert(<span class="keyword">const</span> T&amp;x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!full())</span><br><span class="line">    &#123;</span><br><span class="line">        matrix[ins.x][ins.y]=x;</span><br><span class="line">        MaxFixup(ins);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">unsigned</span> M,<span class="keyword">unsigned</span> N&gt;</span><br><span class="line"><span class="keyword">void</span> Youngtableau&lt;T,M,N&gt;::extractMin()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!empty())</span><br><span class="line">    &#123;</span><br><span class="line">        matrix[<span class="number">1</span>][<span class="number">1</span>]=INF;</span><br><span class="line">        MinFixup(Loc&#123;<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">unsigned</span> M,<span class="keyword">unsigned</span> N&gt;</span><br><span class="line"><span class="keyword">bool</span> Youngtableau&lt;T,M,N&gt;::search(<span class="keyword">const</span> T&amp;t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x=M,y=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(matrix[x][y]!=INF&amp;&amp;matrix[x][y]!=-INF)<span class="comment">//边界检查</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t==matrix[x][y])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t&lt;matrix[x][y])</span><br><span class="line">            --x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">unsigned</span> M,<span class="keyword">unsigned</span> N&gt;</span><br><span class="line"><span class="keyword">void</span> Youngtableau&lt;T,M,N&gt;::MaxFixup(Loc loc)&#123;</span><br><span class="line">    T t=matrix[loc.x][loc.y];</span><br><span class="line">    Loc lager;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[loc.x][loc.y<span class="number">-1</span>]&gt;matrix[loc.x<span class="number">-1</span>][loc.y])</span><br><span class="line">            lager=&#123;loc.x,loc.y<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lager=&#123;loc.x<span class="number">-1</span>,loc.y&#125;;</span><br><span class="line">        <span class="keyword">if</span>(matrix[lager.x][lager.y]&gt;t)&#123;</span><br><span class="line">            matrix[loc.x][loc.y]=matrix[lager.x][lager.y];</span><br><span class="line">            loc=lager;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">    matrix[loc.x][loc.y]=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">unsigned</span> M,<span class="keyword">unsigned</span> N&gt;</span><br><span class="line"><span class="keyword">void</span> Youngtableau&lt;T,M,N&gt;::MinFixup(Loc loc)&#123;</span><br><span class="line">    T t=matrix[loc.x][loc.y];</span><br><span class="line">    Loc small;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[loc.x][loc.y+<span class="number">1</span>]&lt;matrix[loc.x+<span class="number">1</span>][loc.y])</span><br><span class="line">            small=&#123;loc.x,loc.y+<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            small=&#123;loc.x+<span class="number">1</span>,loc.y&#125;;</span><br><span class="line">        <span class="keyword">if</span>(matrix[small.x][small.y]&lt;t)&#123;</span><br><span class="line">            matrix[loc.x][loc.y]=matrix[small.x][small.y];</span><br><span class="line">            loc=small;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">    matrix[loc.x][loc.y]=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> M,<span class="keyword">unsigned</span> N=M&gt;</span><br><span class="line"><span class="keyword">void</span> Youngtableau_test(Youngtableau&lt;<span class="keyword">int</span>,M,N&gt;&amp;matrix)</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">static</span> default_random_engine e(time(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="keyword">static</span> uniform_int_distribution&lt;<span class="keyword">int</span>&gt; d(<span class="number">100</span>,<span class="number">999</span>);<span class="comment">//等概率生成3位的随机整数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Before insert"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    matrix.print();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;M*N)</span><br><span class="line">    &#123;</span><br><span class="line">       matrix.insert(d(e));</span><br><span class="line">       i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"After insert"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    matrix.print();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nInput the number to check it if in the Young tableau,(-1 to stop):\n"</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; i &amp;&amp; i!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; matrix.search(i) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pre=-INF;</span><br><span class="line">    <span class="keyword">while</span>(!matrix.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=matrix.top();</span><br><span class="line">        assert(pre&lt;=t);<span class="comment">//不满足非递减终止</span></span><br><span class="line">        pre=t;</span><br><span class="line">        matrix.extractMin();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"After delete"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    matrix.print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Youngtableau&lt;<span class="keyword">int</span>,<span class="number">5</span>,<span class="number">10</span>&gt; matrix;</span><br><span class="line">    Youngtableau_test(matrix);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;思考题6-3（Young氏矩阵）在一个-m-times-n-的Young氏矩阵（Young-tableau）中，每一行的数据都是从左到右排序的，每一列的数据都是从上到下排列的。Young氏矩阵中也会存在一些为-infty-的数据项，表示那些不存在的数据。因此，Yo
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="Young氏矩阵" scheme="http://007havegone.github.io/tags/Young%E6%B0%8F%E7%9F%A9%E9%98%B5/"/>
    
      <category term="堆" scheme="http://007havegone.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>算法导论练习14.1-7</title>
    <link href="http://007havegone.github.io/2019/08/20/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%BB%83%E4%B9%A014-1-7/"/>
    <id>http://007havegone.github.io/2019/08/20/算法导论练习14-1-7/</id>
    <published>2019-08-20T08:41:56.000Z</published>
    <updated>2019-08-20T10:16:06.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="14-1-7-说明如何在-O-nlgn-时间内，利用顺序统计树对大小为-n-的数组中的逆序对（见思考题2-4）进行计树。"><a href="#14-1-7-说明如何在-O-nlgn-时间内，利用顺序统计树对大小为-n-的数组中的逆序对（见思考题2-4）进行计树。" class="headerlink" title="14.1-7 说明如何在$O(nlgn)$时间内，利用顺序统计树对大小为$n$的数组中的逆序对（见思考题2-4）进行计树。"></a>14.1-7 说明如何在$O(nlgn)$时间内，利用顺序统计树对大小为$n$的数组中的逆序对（见思考题2-4）进行计树。</h3><p>这道题和算法导思考题2-4一致，当时采用了归并排序和线段树进行解决，在另外一篇博客中给出了题解。<a href="https://blog.csdn.net/qq_40512922/article/details/97827322" target="_blank" rel="noopener">算法导论 思考题2-4</a></p><p>这里我们将采用书中的顺序统计树（order-statistic tree）来解决。其实本质上和线段树类似，都是采用一种支持$O(lgn)$操作的数据结构，来进行统计，思考题2-4的线段树采用统计区间内数字的次数。而顺序统计树，通过记录树的大小，从而快速得出对应关键字的秩。</p><p>采用顺序统计树这里有两种方法得出逆序对。</p><p>对于数组$A[5]=(5,4,3,2,1)$。我们要求其逆序对，只需要计算对于数组中的每个数$A[i]$，计算$A[1]\rightarrow A[i-1]$之中大于$A[i]$的个数。我们可以采用插入排序排序来计算逆序对，逆序对等于每个数$A[i]$在与$A[1]\rightarrow A[i-1]$交换位置的次数，因为每交换一次位置，就消除一对逆序对，逆序对的次数等于$i-k$，($i$为$A[i]$原始位置，$k$为$A[k]$插入位置)。</p><p>基于以上思路可以建议一棵空的顺序统计树，将$A[i]$插入，然后查询$rank(A[i])$,逆序对次数加$i-rank(A[i])$。</p><p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OS_reverseCount</span><span class="params">(<span class="built_in">vector</span>&lt;pNode&lt;T&gt;&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> reverseCnt=<span class="number">0</span>;</span><br><span class="line">    OSTree&lt;T&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=vec.size();++i)<span class="comment">//遍历数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        OSTree_insert(t,vec[i<span class="number">-1</span>]);<span class="comment">//插入</span></span><br><span class="line">        reverseCnt+=i-OS_rank(t,vec[i<span class="number">-1</span>]);<span class="comment">//计算插入位置减去原先位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reverseCnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另外也可以采用另一种方式，我们先将全部的关键字插入。然后在按插入顺序查询它在顺序统计树的位序，然后将它从树中删除。那么一组没有逆序对的数组，每次我们查询它的秩应该均是1，然后将它删除。否则，说明我们在一棵顺序统计树中先取出的树不是最小的，然后有更小的后面在取出，即存在逆序对。逆序对数等于每次查询的位序$rank(A[i])-1$的和。</p><p>代码如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OS_reverseCount2</span><span class="params">(<span class="built_in">vector</span>&lt;pNode&lt;T&gt;&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">    OSTree&lt;T&gt; t;</span><br><span class="line">    <span class="keyword">int</span> reverseCnt=-vec.size();<span class="comment">//相当于每个数都减1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec)<span class="comment">//全部插入，插入顺序不重要</span></span><br><span class="line">        OSTree_insert(t,i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=vec.size();++i)<span class="comment">//按顺序取出</span></span><br><span class="line">    &#123;</span><br><span class="line">        reverseCnt+=OS_rank(t,vec[i<span class="number">-1</span>]);<span class="comment">//查询位置</span></span><br><span class="line">        OSTree_delete(t,vec[i<span class="number">-1</span>]);<span class="comment">//删除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reverseCnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第2个版本相比第一个版本耗费时间多一倍，需要删除和插入。两种方法均可以在$O(nlgn)$时间内完成对逆序对的统计。</p><p>下面是我的顺序统计树的c++实现，顺序统计树基于红黑树实现，对于红黑树的介绍和代码实现可以看之前的文章<a href>数据结构红黑树</a>和之前文章介绍的红黑树基本一致，只修改了的<code>rotate</code>函数和<code>insert</code>等需要调整属性$size$的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//定义颜色宏</span></span><br><span class="line"><span class="keyword">enum</span> COLOR&#123;RED,BLACK&#125;;</span><br><span class="line"><span class="comment">//结点定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Node&lt;T&gt;* left;</span><br><span class="line">    Node&lt;T&gt;* right;</span><br><span class="line">    Node&lt;T&gt;* p;</span><br><span class="line">    T key;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    COLOR color;</span><br><span class="line">    Node():color(BLACK),size(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    Node(<span class="keyword">const</span> T&amp; k):color(BLACK),key(k),size(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> pNode=Node&lt;T&gt;*;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OSTree</span></span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    <span class="keyword">static</span> pNode&lt;T&gt; nil;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Singleton Model</span></span><br><span class="line"><span class="comment">     * 采用local-static对象</span></span><br><span class="line"><span class="comment">     * 使模板参数相同的对象公用一个nil</span></span><br><span class="line"><span class="comment">     * 在main函数前被使用。</span></span><br><span class="line"><span class="comment">     * 具体参考 下面这篇博客</span></span><br><span class="line"><span class="comment">     * https://blog.csdn.net/qq_40512922/article/details/90589657#41_274</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> pNode&lt;T&gt; getInstance()&#123;</span><br><span class="line">        <span class="keyword">static</span> Node&lt;T&gt; one_instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;one_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    pNode&lt;T&gt; root;</span><br><span class="line">    OSTree():root(nil)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">pNode&lt;T&gt; OSTree&lt;T&gt;::nil=OSTree&lt;T&gt;::getInstance();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Function Decleration</span></span><br><span class="line"><span class="comment">    ----------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OSTree_insert</span><span class="params">(OSTree&lt;T&gt; &amp;t,pNode&lt;T&gt; z)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//插入调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OSTree_insert_fixup</span><span class="params">(OSTree&lt;T&gt; &amp;t,pNode&lt;T&gt; z)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OSTree_delete</span><span class="params">(OSTree&lt;T&gt; &amp;t,pNode&lt;T&gt; z)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//删除调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OSTree_delete_fixup</span><span class="params">(OSTree&lt;T&gt; &amp;t,pNode&lt;T&gt; x)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//从from到to的size减1的简单路径size-1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OSTree_delete_decreaseSize</span><span class="params">(pNode&lt;T&gt; from,pNode&lt;T&gt; to)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//O(1)空间复杂度迭代中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder_travel_iterative</span><span class="params">(pNode&lt;T&gt; x)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//常规递归中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder_travel_recursive</span><span class="params">(pNode&lt;T&gt; x)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//左旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left_rotate</span><span class="params">(OSTree&lt;T&gt; &amp;t,pNode&lt;T&gt; z)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//右旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">right_rotate</span><span class="params">(OSTree&lt;T&gt; &amp;t,pNode&lt;T&gt; z)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//用v代替u的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OSTree_transplant</span><span class="params">(OSTree&lt;T&gt; &amp;t,pNode&lt;T&gt; u,pNode&lt;T&gt; v)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//最小值</span></span><br><span class="line">pNode&lt;T&gt; tree_minimum(pNode&lt;T&gt; x);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//初始化vector</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getInitVec</span><span class="params">(<span class="built_in">vector</span>&lt;pNode&lt;T&gt;&gt; &amp;vec)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeVec</span><span class="params">(<span class="built_in">vector</span>&lt;pNode&lt;T&gt;&gt; &amp;vec)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//打印结点x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Node&lt;T&gt;*x)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//获取秩为i的结点</span></span><br><span class="line">pNode&lt;T&gt; OS_select(pNode&lt;T&gt; x,<span class="keyword">int</span> i);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//获取结点x的秩</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OS_rank</span><span class="params">(OSTree&lt;T&gt; &amp;t,pNode&lt;T&gt; x)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OS_reverseCount</span><span class="params">(<span class="built_in">vector</span>&lt;pNode&lt;T&gt;&gt; &amp;vec)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OS_reverseCount2</span><span class="params">(<span class="built_in">vector</span>&lt;pNode&lt;T&gt;&gt; &amp;vec)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Function Definition</span></span><br><span class="line"><span class="comment">    ----------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Node&lt;T&gt;*x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"key = "</span> &lt;&lt; x-&gt;key &lt;&lt; <span class="string">"size = "</span> &lt;&lt; x-&gt;size;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;color==BLACK)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" [BLACK]\n"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" [RED]\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder_travel_recursive</span><span class="params">(pNode&lt;T&gt; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=OSTree&lt;T&gt;::nil)</span><br><span class="line">    &#123;</span><br><span class="line">        inorder_travel_recursive(x-&gt;left);</span><br><span class="line">        print(x);</span><br><span class="line">        inorder_travel_recursive(x-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder_travel_iterative</span><span class="params">(pNode&lt;T&gt; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==OSTree&lt;T&gt;::nil)<span class="keyword">return</span>;</span><br><span class="line">    pNode&lt;T&gt; y=OSTree&lt;T&gt;::nil;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y!=x-&gt;left)</span><br><span class="line">            <span class="keyword">while</span>(x-&gt;left!=OSTree&lt;T&gt;::nil)</span><br><span class="line">                x=x-&gt;left;</span><br><span class="line">        print(x);</span><br><span class="line">        <span class="keyword">if</span>(x-&gt;right!=OSTree&lt;T&gt;::nil)</span><br><span class="line">        &#123;</span><br><span class="line">            x=x-&gt;right;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            y=x;</span><br><span class="line">            x=x-&gt;p;</span><br><span class="line">            <span class="keyword">if</span>(x==OSTree&lt;T&gt;::nil)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(y==x-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left_rotate</span><span class="params">(OSTree&lt;T&gt; &amp;t,pNode&lt;T&gt; x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pNode&lt;T&gt; y=x-&gt;right;</span><br><span class="line">    x-&gt;right=y-&gt;left;</span><br><span class="line">    <span class="keyword">if</span>(y-&gt;left!=OSTree&lt;T&gt;::nil)</span><br><span class="line">        y-&gt;left-&gt;p=x;</span><br><span class="line">    y-&gt;p=x-&gt;p;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;p==OSTree&lt;T&gt;::nil)</span><br><span class="line">        t.root=y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x-&gt;p-&gt;left==x)</span><br><span class="line">        x-&gt;p-&gt;left=y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x-&gt;p-&gt;right=y;</span><br><span class="line">    y-&gt;left=x;</span><br><span class="line">    x-&gt;p=y;</span><br><span class="line">    y-&gt;size = x-&gt;size;</span><br><span class="line">    x-&gt;size = x-&gt;left-&gt;size+x-&gt;right-&gt;size+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">right_rotate</span><span class="params">(OSTree&lt;T&gt; &amp;t,pNode&lt;T&gt; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pNode&lt;T&gt; y=x-&gt;left;</span><br><span class="line">    x-&gt;left=y-&gt;right;</span><br><span class="line">    <span class="keyword">if</span>(y-&gt;right!=OSTree&lt;T&gt;::nil)</span><br><span class="line">        y-&gt;right-&gt;p=x;</span><br><span class="line">    y-&gt;p=x-&gt;p;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;p==OSTree&lt;T&gt;::nil)</span><br><span class="line">        t.root=y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x-&gt;p-&gt;left==x)</span><br><span class="line">        x-&gt;p-&gt;left=y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x-&gt;p-&gt;right=y;</span><br><span class="line">    y-&gt;right=x;</span><br><span class="line">    x-&gt;p=y;</span><br><span class="line">    y-&gt;size = x-&gt;size;</span><br><span class="line">    x-&gt;size = x-&gt;left-&gt;size + x-&gt;right-&gt;size+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OSTree_insert</span><span class="params">(OSTree&lt;T&gt; &amp;t,pNode&lt;T&gt; z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pNode&lt;T&gt; y=OSTree&lt;T&gt;::nil;</span><br><span class="line">    pNode&lt;T&gt; x=t.root;</span><br><span class="line">    <span class="keyword">while</span>(x!=OSTree&lt;T&gt;::nil)</span><br><span class="line">    &#123;</span><br><span class="line">        y=x;</span><br><span class="line">        ++y-&gt;size;<span class="comment">// the y parent size add 1</span></span><br><span class="line">        <span class="keyword">if</span>(z-&gt;key&lt;x-&gt;key)</span><br><span class="line">            x=x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x=x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;p=y;</span><br><span class="line">    <span class="keyword">if</span>(y==OSTree&lt;T&gt;::nil)</span><br><span class="line">        t.root=z;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;key&lt;y-&gt;key)</span><br><span class="line">        y-&gt;left=z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;right=z;</span><br><span class="line">    z-&gt;left=z-&gt;right=OSTree&lt;T&gt;::nil;</span><br><span class="line">    z-&gt;color=RED;</span><br><span class="line">    z-&gt;size = <span class="number">1</span>;</span><br><span class="line">    OSTree_insert_fixup(t,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OSTree_insert_fixup</span><span class="params">(OSTree&lt;T&gt; &amp;t,pNode&lt;T&gt; z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(z-&gt;p-&gt;color==RED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(z-&gt;p==z-&gt;p-&gt;p-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            pNode&lt;T&gt; y=z-&gt;p-&gt;p-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(y-&gt;color==RED)</span><br><span class="line">            &#123;</span><br><span class="line">                z-&gt;p-&gt;color=BLACK;  <span class="comment">//case 1</span></span><br><span class="line">                y-&gt;color=BLACK;</span><br><span class="line">                z-&gt;p-&gt;p-&gt;color=RED;</span><br><span class="line">                z=z-&gt;p-&gt;p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(z==z-&gt;p-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    z=z-&gt;p;         <span class="comment">//case 2</span></span><br><span class="line">                    left_rotate(t,z);</span><br><span class="line">                &#125;</span><br><span class="line">                z-&gt;p-&gt;color=BLACK;  <span class="comment">//case 3</span></span><br><span class="line">                z-&gt;p-&gt;p-&gt;color=RED;</span><br><span class="line">                right_rotate(t,z-&gt;p-&gt;p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//end-if</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pNode&lt;T&gt; y=z-&gt;p-&gt;p-&gt;left;</span><br><span class="line">            <span class="keyword">if</span>(y-&gt;color==RED)</span><br><span class="line">            &#123;</span><br><span class="line">                z-&gt;p-&gt;color=BLACK;</span><br><span class="line">                y-&gt;color=BLACK;</span><br><span class="line">                z-&gt;p-&gt;p-&gt;color=RED;</span><br><span class="line">                z=z-&gt;p-&gt;p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(z==z-&gt;p-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    z=z-&gt;p;</span><br><span class="line">                    right_rotate(t,z);</span><br><span class="line">                &#125;</span><br><span class="line">                z-&gt;p-&gt;color=BLACK;</span><br><span class="line">                z-&gt;p-&gt;p-&gt;color=RED;</span><br><span class="line">                left_rotate(t,z-&gt;p-&gt;p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//end-else</span></span><br><span class="line">    &#125;<span class="comment">//end while</span></span><br><span class="line">    t.root-&gt;color=BLACK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">pNode&lt;T&gt; tree_minimum(pNode&lt;T&gt; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(x-&gt;left!=OSTree&lt;T&gt;::nil)</span><br><span class="line">        x=x-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OSTree_transplant</span><span class="params">(OSTree&lt;T&gt; &amp;t,pNode&lt;T&gt; u,pNode&lt;T&gt; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u-&gt;p==OSTree&lt;T&gt;::nil)</span><br><span class="line">        t.root=v;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(u==u-&gt;p-&gt;left)</span><br><span class="line">        u-&gt;p-&gt;left=v;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        u-&gt;p-&gt;right=v;</span><br><span class="line">    v-&gt;p=u-&gt;p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OSTree_delete_decreaseSize</span><span class="params">(pNode&lt;T&gt; from,pNode&lt;T&gt; to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(from!=to)</span><br><span class="line">    &#123;</span><br><span class="line">        --from-&gt;size;</span><br><span class="line">        from=from-&gt;p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OSTree_delete</span><span class="params">(OSTree&lt;T&gt; &amp;t,pNode&lt;T&gt; z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pNode&lt;T&gt; y=z;</span><br><span class="line">    pNode&lt;T&gt; x;</span><br><span class="line">    COLOR y_original_color=y-&gt;color;</span><br><span class="line">    <span class="keyword">if</span>(z-&gt;left==OSTree&lt;T&gt;::nil)</span><br><span class="line">    &#123;</span><br><span class="line">        x=z-&gt;right;</span><br><span class="line">        OSTree_delete_decreaseSize(z-&gt;p,OSTree&lt;T&gt;::nil);</span><br><span class="line">        OSTree_transplant(t,z,z-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;right==OSTree&lt;T&gt;::nil)</span><br><span class="line">    &#123;</span><br><span class="line">        x=z-&gt;left;</span><br><span class="line">        OSTree_delete_decreaseSize(z-&gt;p,OSTree&lt;T&gt;::nil);</span><br><span class="line">        OSTree_transplant(t,z,z-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        y=tree_minimum(z-&gt;right);</span><br><span class="line">        OSTree_delete_decreaseSize(y-&gt;p,OSTree&lt;T&gt;::nil);</span><br><span class="line">        y-&gt;size=z-&gt;size;<span class="comment">//y get the size of z</span></span><br><span class="line">        y_original_color=y-&gt;color;</span><br><span class="line">        x=y-&gt;right;</span><br><span class="line">        <span class="keyword">if</span>(y-&gt;p==z)</span><br><span class="line">            x-&gt;p=y;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            OSTree_transplant(t,y,y-&gt;right);</span><br><span class="line">            y-&gt;right=z-&gt;right;</span><br><span class="line">            y-&gt;right-&gt;p=y;</span><br><span class="line">        &#125;</span><br><span class="line">        OSTree_transplant(t,z,y);</span><br><span class="line">        y-&gt;left=z-&gt;left;</span><br><span class="line">        y-&gt;left-&gt;p=y;</span><br><span class="line">        y-&gt;color=z-&gt;color;</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;size=<span class="number">0</span>;<span class="comment">//set size to 0 when del</span></span><br><span class="line">    <span class="keyword">if</span>(y_original_color==BLACK)</span><br><span class="line">        OSTree_delete_fixup(t,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OSTree_delete_fixup</span><span class="params">(OSTree&lt;T&gt; &amp;t,pNode&lt;T&gt; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=t.root&amp;&amp;x-&gt;color==BLACK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x==x-&gt;p-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            pNode&lt;T&gt; w=x-&gt;p-&gt;right;<span class="comment">//brother node</span></span><br><span class="line">            <span class="keyword">if</span>(w-&gt;color==RED)</span><br><span class="line">            &#123;</span><br><span class="line">                w-&gt;color=BLACK;     <span class="comment">//case 1</span></span><br><span class="line">                x-&gt;p-&gt;color=RED;</span><br><span class="line">                left_rotate(t,x-&gt;p);</span><br><span class="line">                w=x-&gt;p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(w-&gt;left-&gt;color==BLACK&amp;&amp;w-&gt;right-&gt;color==BLACK)</span><br><span class="line">            &#123;</span><br><span class="line">                w-&gt;color=RED;   <span class="comment">//case 2</span></span><br><span class="line">                x=x-&gt;p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(w-&gt;right-&gt;color==BLACK)</span><br><span class="line">                &#123;</span><br><span class="line">                    w-&gt;left-&gt;color=BLACK;   <span class="comment">//case 3</span></span><br><span class="line">                    w-&gt;color=RED;</span><br><span class="line">                    right_rotate(t,w);</span><br><span class="line">                    w=x-&gt;p-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                w-&gt;color=x-&gt;p-&gt;color;   <span class="comment">//case 4</span></span><br><span class="line">                x-&gt;p-&gt;color=BLACK;</span><br><span class="line">                w-&gt;right-&gt;color=BLACK;</span><br><span class="line">                left_rotate(t,x-&gt;p);</span><br><span class="line">                x=t.root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//end-if</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pNode&lt;T&gt; w=x-&gt;p-&gt;left;</span><br><span class="line">            <span class="keyword">if</span>(w-&gt;color==RED)</span><br><span class="line">            &#123;</span><br><span class="line">                w-&gt;color=BLACK;     <span class="comment">//case 1</span></span><br><span class="line">                x-&gt;p-&gt;color=RED;</span><br><span class="line">                right_rotate(t,x-&gt;p);</span><br><span class="line">                w=x-&gt;p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(w-&gt;left-&gt;color==BLACK&amp;&amp;w-&gt;right-&gt;color==BLACK)</span><br><span class="line">            &#123;</span><br><span class="line">                w-&gt;color=RED;   <span class="comment">//case 2</span></span><br><span class="line">                x=x-&gt;p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(w-&gt;left-&gt;color==BLACK)</span><br><span class="line">                &#123;</span><br><span class="line">                    w-&gt;right-&gt;color=BLACK;  <span class="comment">//case 3</span></span><br><span class="line">                    w-&gt;color=RED;</span><br><span class="line">                    left_rotate(t,w);</span><br><span class="line">                    w=x-&gt;p-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                w-&gt;color=x-&gt;p-&gt;color;   <span class="comment">//case 4</span></span><br><span class="line">                x-&gt;p-&gt;color=BLACK;</span><br><span class="line">                w-&gt;left-&gt;color=BLACK;</span><br><span class="line">                right_rotate(t,x-&gt;p);</span><br><span class="line">                x=t.root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//end-else</span></span><br><span class="line">    &#125;</span><br><span class="line">    x-&gt;color=BLACK;</span><br><span class="line">&#125;</span><br><span class="line">pNode&lt;T&gt; OS_select(pNode&lt;T&gt; x,<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//add the case of nil boundary</span></span><br><span class="line">    <span class="keyword">if</span>(x==OSTree&lt;T&gt;::nil)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> r=x-&gt;left-&gt;size+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(i==r)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i&lt;r)</span><br><span class="line">        <span class="keyword">return</span> OS_select(x-&gt;left,i);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> OS_select(x-&gt;right,i-r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OS_rank</span><span class="params">(OSTree&lt;T&gt; &amp;t,pNode&lt;T&gt; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==OSTree&lt;T&gt;::nil)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> r=x-&gt;left-&gt;size+<span class="number">1</span>;</span><br><span class="line">    pNode&lt;T&gt; y=x;</span><br><span class="line">    <span class="keyword">while</span>(y!=t.root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==y-&gt;p-&gt;right)</span><br><span class="line">            r+=y-&gt;p-&gt;left-&gt;size+<span class="number">1</span>;</span><br><span class="line">        y=y-&gt;p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OS_reverseCount</span><span class="params">(<span class="built_in">vector</span>&lt;pNode&lt;T&gt;&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> reverseCnt=<span class="number">0</span>;</span><br><span class="line">    OSTree&lt;T&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=vec.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        OSTree_insert(t,vec[i<span class="number">-1</span>]);</span><br><span class="line">        reverseCnt+=i-OS_rank(t,vec[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reverseCnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OS_reverseCount2</span><span class="params">(<span class="built_in">vector</span>&lt;pNode&lt;T&gt;&gt; &amp;vec)</span></span>&#123;</span><br><span class="line">    OSTree&lt;T&gt; t;</span><br><span class="line">    <span class="keyword">int</span> reverseCnt=-vec.size();<span class="comment">//相当于每个数都减1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec)</span><br><span class="line">        OSTree_insert(t,i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=vec.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        reverseCnt+=OS_rank(t,vec[i<span class="number">-1</span>]);</span><br><span class="line">        OSTree_delete(t,vec[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reverseCnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">getInitVec</span><span class="params">(<span class="built_in">vector</span>&lt;pNode&lt;<span class="keyword">int</span>&gt;&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> default_random_engine <span class="title">e</span><span class="params">(time(<span class="literal">nullptr</span>))</span></span>;</span><br><span class="line">    <span class="keyword">static</span> uniform_int_distribution&lt;<span class="keyword">int</span>&gt; d(<span class="number">0</span>,<span class="number">50000</span>);</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:vec)&#123;</span><br><span class="line">        i=<span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        i-&gt;key=d(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">getInitVec</span><span class="params">(<span class="built_in">vector</span>&lt;pNode&lt;<span class="keyword">double</span>&gt;&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> default_random_engine <span class="title">e</span><span class="params">(time(<span class="literal">nullptr</span>))</span></span>;</span><br><span class="line">    <span class="keyword">static</span> uniform_real_distribution&lt;<span class="keyword">double</span>&gt; d(<span class="number">0</span>,<span class="number">50000</span>);</span><br><span class="line">    <span class="keyword">double</span> key;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:vec)&#123;</span><br><span class="line">        i=<span class="keyword">new</span> Node&lt;<span class="keyword">double</span>&gt;();</span><br><span class="line">        i-&gt;key=d(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeVec</span><span class="params">(<span class="built_in">vector</span>&lt;pNode&lt;T&gt;&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> i;</span><br><span class="line">        i=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OS_test_reverseCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt,y,k;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input the cnt:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;cnt;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pNode&lt;<span class="keyword">int</span>&gt;&gt; vec(cnt);</span><br><span class="line">    <span class="comment">// getInitVec(vec);//随机获取数据</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input the  key"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">        vec[i]=<span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt;(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; OS_reverseCount(vec);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; OS_reverseCount2(vec);</span></span><br><span class="line">    freeVec(vec);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OS_test_reverseCount();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;14-1-7-说明如何在-O-nlgn-时间内，利用顺序统计树对大小为-n-的数组中的逆序对（见思考题2-4）进行计树。&quot;&gt;&lt;a href=&quot;#14-1-7-说明如何在-O-nlgn-时间内，利用顺序统计树对大小为-n-的数组中的逆序对（见思考题2-4）进行计树。
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="逆序对" scheme="http://007havegone.github.io/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    
      <category term="二叉树" scheme="http://007havegone.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="顺序统计树" scheme="http://007havegone.github.io/tags/%E9%A1%BA%E5%BA%8F%E7%BB%9F%E8%AE%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Visual Studio Code写Markdown中代码块tab缩进错误</title>
    <link href="http://007havegone.github.io/2019/08/18/VSCode%E5%86%99Markdown%E4%B8%AD%E4%BB%A3%E7%A0%81%E5%9D%97tab%E7%BC%A9%E8%BF%9B%E9%94%99%E8%AF%AF/"/>
    <id>http://007havegone.github.io/2019/08/18/VSCode写Markdown中代码块tab缩进错误/</id>
    <published>2019-08-18T13:40:44.000Z</published>
    <updated>2019-08-18T16:24:03.294Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述：最近写使用markdwon写博客，本人习惯在本地用visual-studio-code编写，然后上传。vs-code自带一个侧边预览窗口（右上角）可以查看markdown文档结果。平时也是用这个。后面写博客发到自己个人的网站上时，发现有时候-tab-键缩进-4个空格，有时候缩进-8个空格。"><a href="#问题描述：最近写使用markdwon写博客，本人习惯在本地用visual-studio-code编写，然后上传。vs-code自带一个侧边预览窗口（右上角）可以查看markdown文档结果。平时也是用这个。后面写博客发到自己个人的网站上时，发现有时候-tab-键缩进-4个空格，有时候缩进-8个空格。" class="headerlink" title="问题描述：最近写使用markdwon写博客，本人习惯在本地用visual studio code编写，然后上传。vs code自带一个侧边预览窗口（右上角）可以查看markdown文档结果。平时也是用这个。后面写博客发到自己个人的网站上时，发现有时候 tab 键缩进 4个空格，有时候缩进 8个空格。"></a>问题描述：最近写使用markdwon写博客，本人习惯在本地用visual studio code编写，然后上传。vs code自带一个侧边预览窗口（右上角）可以查看markdown文档结果。平时也是用这个。后面写博客发到自己个人的网站上时，发现有时候 tab 键缩进 4个空格，有时候缩进 8个空格。</h3><p>如图：第一个图是网页上的效果，可以看到一些 tab缩进是4，有一些是8</p><p><img src="/2019/08/18/VSCode写Markdown中代码块tab缩进错误/网页上的效果.PNG" alt="网页上的效果"><br>下面是我这篇博客本地文件及效果：可以看到文件中缩进均是一个tab键，同时采用vs code的自带预览效果都是缩进4个空格。但是与实际网页的效果不同。<br><img src="/2019/08/18/VSCode写Markdown中代码块tab缩进错误/本地文件及预览效果.PNG" alt="本地文件及预览效果"><br>后面我还尝试在csdn在线的markdown编写，一个tab缩进4个空格，但是我导出markdown上传到自己个人网站还是发现有tab出错。</p><p>&emsp;一开始我以为是我的 tab-size实质错误，但是我始终的设置的是4。如下图：<br><img src="/2019/08/18/VSCode写Markdown中代码块tab缩进错误/tab-size.PNG" alt="tab-size"><br>后面我尝试使用了一款vs code中的Markdown Preview Enhanced插件，利用该插件进行预览而不是使用默认自带的预览工具。利用该工具后，还是预览上面的那段代码，发现效果和我实际网页上显示的效果一致，有部分tab缩进为8空格。<br><img src="/2019/08/18/VSCode写Markdown中代码块tab缩进错误/本地预览及效果2.PNG" alt="本地预览及效果2"></p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>最终，经过一番查找资料，我们可以将 tab缩进转换成空格来消除 tab 缩进引起问题。在vs code中我们按<code>Ctrl + Shift + p</code>，调出命令窗口，输入 convert 就可以看到下面两个命令，我们选择 <code>convert Indentation to Spaces</code>命令将文件中得到缩进转换为空格。然后我们再用 Markdown Preview Enhanced进行预览。发现此时所有的tab 都是缩进 4个空格。<br><img src="/2019/08/18/VSCode写Markdown中代码块tab缩进错误/Command.PNG" alt="Command"><br>下图是转后后的效果，完成了对tab缩进不一致的问题修复。后面我们还可以<br>再尝试命令<code>convert Indentation to Tabs</code>，我们会发现又出现刚才缩进不一致的现象。<br><img src="/2019/08/18/VSCode写Markdown中代码块tab缩进错误/修复后效果.PNG" alt="修复后效果"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述：最近写使用markdwon写博客，本人习惯在本地用visual-studio-code编写，然后上传。vs-code自带一个侧边预览窗口（右上角）可以查看markdown文档结果。平时也是用这个。后面写博客发到自己个人的网站上时，发现有时候-tab-键缩
      
    
    </summary>
    
      <category term="踩坑" scheme="http://007havegone.github.io/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
      <category term="VS Code" scheme="http://007havegone.github.io/tags/VS-Code/"/>
    
      <category term="Markdown" scheme="http://007havegone.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-红黑树</title>
    <link href="http://007havegone.github.io/2019/08/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://007havegone.github.io/2019/08/18/数据结构-红黑树/</id>
    <published>2019-08-18T07:09:10.000Z</published>
    <updated>2019-08-19T08:00:18.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-红黑树"><a href="#数据结构-红黑树" class="headerlink" title="数据结构-红黑树"></a>数据结构-红黑树</h1><h2 id="1、红黑树简介"><a href="#1、红黑树简介" class="headerlink" title="1、红黑树简介"></a>1、红黑树简介</h2><p>&emsp;红黑树（red-black tree）是一种平衡的搜索树，常见的平衡搜索树包括<code>AVL树</code>、<code>B树</code>、<code>AA树</code>、<code>treap树</code>、<code>SBT树</code>、<code>替罪羊树</code>、<code>伸展树</code>、<code>跳表</code>等。红黑树支持在最坏情况下对动态集合操作的时间复杂度为$O(lgn)$。平衡树的时间复杂度均为$O(lgn)$，但是红黑树的性能最优，有很多应用。如C++的STL中的集合(set、multiset)、映射（map、multimap），在java中的TreeSet和TreeMap数据结构均用到红黑树。</p><h2 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h2><p>&emsp;红黑树是一棵二叉搜索树，每个结点均有一个颜色位（RED or BLACK）。通过对任何一条从根到叶子的简单路径上各个接待你的颜色进行约束，红黑树确保没有一条路径会比其他路径长出2倍。因此是近似平衡的。</p><h3 id="红黑树结点"><a href="#红黑树结点" class="headerlink" title="红黑树结点"></a>红黑树结点</h3><p>&emsp;红黑树每个结点包括基本的5个域：Color、left、right、p、key。如果一个结点没有子结点或父节点，则该结点相应指针指向 NIL。我们可以把 NIL实现为 空指针（nullptr）或 哨兵结点。我们可以把 NIL视为指向叶结点（外部结点）的指针，而把带有关键字的结点视为内部结点。</p><h3 id="红黑树的5个性质"><a href="#红黑树的5个性质" class="headerlink" title="红黑树的5个性质"></a>红黑树的5个性质</h3><p>1、每个结点为BLACK或BLACK<br>2、根节点颜色为BLACK<br>3、每个叶结点（NIL）为BLACK。<br>4、如果一个结点为RED，那么它的两个子结点均为BLACK<br>5、对于每个结点，该结点到其所有后代叶结点的简单路径上，均包含数据相同的BLACK结点。</p><p><strong>在后面的实现中，NIL采用哨兵来实现。</strong></p><p>下面是一个红黑树的示例图：<br><img src="/2019/08/18/数据结构-红黑树/红黑树示例图.PNG" alt="红黑树示例图"><br>该树满足上面红黑树的5个性质。在后面的具体实现中，我们令根和子结点为空的结点相应的指针指向 $T.nil$。<br>&emsp;<strong>定理：对于n个结点一棵红黑树，它的高度之多为 $2lg(n+1)$</strong>。具体证明过程看算法导论。</p><h2 id="2、红黑树的操作"><a href="#2、红黑树的操作" class="headerlink" title="2、红黑树的操作"></a>2、红黑树的操作</h2><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>&emsp;红黑树是基于旋转来维持平衡的，类是有<code>伸展树</code>，<code>AVL树</code>。也有无旋转的平衡搜索树，如：<code>替罪羊树</code>、<code>fhq reap树</code>。几乎所有的平衡树都是基于旋转来进行操作。通过旋转来维持平衡树的性质，同时可以保持树的中序遍历结果不变。</p><p>红黑树的旋转只有左旋和右旋。分别是左旋和右旋的示意图。</p><p><img src="/2019/08/18/数据结构-红黑树/旋转.PNG" alt="平衡树旋转操作"><br>下面是<code>LEFT-ROTATE</code>的伪代码，对树$T$中的$x$进行左旋，其中假设$x.right  != T.nil$，且根节点的父节点为$T.nil$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LEFT-ROTATE(T,x)</span><br><span class="line">    y = x.right<span class="comment">//获取x的右孩子</span></span><br><span class="line">    x.right = y.left<span class="comment">//获取新的右孩子</span></span><br><span class="line">    <span class="keyword">if</span> y.left != T.nil</span><br><span class="line">        y.left.p = x</span><br><span class="line">    y.p = x.p<span class="comment">//更新与父亲结点间的链接</span></span><br><span class="line">    <span class="keyword">if</span> x.p == T.nil</span><br><span class="line">        T.root = y</span><br><span class="line">    elseif x == x.p.left</span><br><span class="line">        x.p.left = y</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x.p.right = y</span><br><span class="line">    y.left = x<span class="comment">//将x作为y的左孩子</span></span><br><span class="line">    x.p = y</span><br></pre></td></tr></table></figure></p><p>右旋的操作与左旋的操作对称，因此只需要将其中出现的<code>left</code>和<code>right</code>进行对调即可。</p><p>下面是左旋和右旋的实例操作。<br><img src="/2019/08/18/数据结构-红黑树/右旋实例.PNG" alt="对结点12右旋"><br><img src="/2019/08/18/数据结构-红黑树/左旋实例.PNG" alt="对结点12左旋"></p><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>红黑树的插入操作（<code>RB-INSERT</code>）与BST的插入操作基本一致，插入操作后，需要额外的操作，如通过旋转，变换颜色等操作进行调整，使之满足红黑树的性质，这些操作在<code>RB-INSERT-FIXUP</code>中完成。</p><p>下面是插入操作<code>RB-INSERT</code>的伪代码，将结点$z$，插入$T$中合适为止。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT(T,z)</span><br><span class="line">    y = T.nil<span class="comment">//父节点为止</span></span><br><span class="line">    x = T.root<span class="comment">//插入位置</span></span><br><span class="line">    <span class="keyword">while</span> x != T.nil</span><br><span class="line">        y = x</span><br><span class="line">        <span class="keyword">if</span> z.key &lt; x.key</span><br><span class="line">            x = x.left</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x.right</span><br><span class="line">    z.p = y</span><br><span class="line">    <span class="keyword">if</span> y == T.nil</span><br><span class="line">        T.root = z</span><br><span class="line">    elseif z.key &lt; y.key</span><br><span class="line">        y.left = z</span><br><span class="line">    <span class="keyword">else</span> y.right = z</span><br><span class="line">    z.left = z.right = T.nil</span><br><span class="line">    z.color = RED</span><br><span class="line">    RB-INSERT-FIXUP(T,z)<span class="comment">//对树进行调整</span></span><br></pre></td></tr></table></figure></p><p>这里不具体证明算法的正确性，可以参考算法导论。</p><p>下面是<code>RB-INSERT-FIXUP</code>的伪代码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT-FIXUP(T,z)</span><br><span class="line">    <span class="keyword">while</span> z.p.color == RED</span><br><span class="line">        <span class="keyword">if</span> z.p == z.p.p.left</span><br><span class="line">            y = z.p.p.left<span class="comment">//uncle node</span></span><br><span class="line">            <span class="keyword">if</span> y.color == RED</span><br><span class="line">                z.p.color = BLACK<span class="comment">//case 1</span></span><br><span class="line">                y.color = BLACK<span class="comment">//case 1</span></span><br><span class="line">                z.p.p.color = RED<span class="comment">//case 1</span></span><br><span class="line">                z = z.p.p<span class="comment">//case 1</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span> z == z.p.right</span><br><span class="line">                    z = z.p<span class="comment">//case 2</span></span><br><span class="line">                    LEFT-ROTATE(T,z)<span class="comment">//case 2</span></span><br><span class="line">                z.p.color = BLACK<span class="comment">//case 3</span></span><br><span class="line">                z.p.p.color = RED<span class="comment">//case 3</span></span><br><span class="line">                RIGHT-ROTATE(T,z.p.p)<span class="comment">//case 3</span></span><br><span class="line">        <span class="keyword">else</span>(same as then clause</span><br><span class="line">                with <span class="string">"right"</span> <span class="keyword">and</span> <span class="string">"left"</span> exchanged)</span><br><span class="line">    T.root.color = BLACK</span><br></pre></td></tr></table></figure></p><p>&emsp;实际上红黑树的插入调整操作一共有6种情况，但是当$x.p$为右子树时，与作为左子树的情况相对称，因此，只需要将处理左子树的情况中的<code>left</code>和<code>right</code>进行对调即可。后面将结合例子讲以上这三种情况。这三种情况并不是相互独立，其中 case 2 完成后就可以变为 case 3。</p><p>&emsp;在红黑树的插入调整操作中，case 1 通过变色来上升$z$，使$z$的叔结点代码中的$y$变为黑色转化为case 2、3，而case 2 和case 3各通过旋转，最终使其满足红黑树性质。因此只有case 1 可以不断迭代，直至根节点时，它的$z.p = T.nil$。此时恒成立推出，因此时间复杂度为$lgn$。</p><h4 id="情况-1：z的叔结点y为红色"><a href="#情况-1：z的叔结点y为红色" class="headerlink" title="情况 1：z的叔结点y为红色"></a>情况 1：z的叔结点y为红色</h4><p>如图所示，$z$所指为当前发生冲突的结点，它与$z.p$颜色均为红色。同时叔结点$y$为红色。此时$z$是左孩子还是右孩子均属该情况。根据上面case 1的伪代码，实质上通过将父节点$z.p$ 和叔结点$y$变为黑色，同时令$z.p.p$变为新的$z$，令它为红色。<strong>通过这样的操作，实质上是将$z$转移上升，最终或者到达根节点，那么推出while后置根节点为黑色，或者使之得到新的叔结点y的颜色为黑色，转化为case 2 or 3</strong>。<br><img src="/2019/08/18/数据结构-红黑树/INSERTcase1.PNG" alt="RB-INSERT-FIXUP case 1"></p><h4 id="情况-2：z的叔结点y为黑色的且z是一个右孩子"><a href="#情况-2：z的叔结点y为黑色的且z是一个右孩子" class="headerlink" title="情况 2：z的叔结点y为黑色的且z是一个右孩子"></a>情况 2：z的叔结点y为黑色的且z是一个右孩子</h4><h4 id="情况-3：z的叔结点y为黑色的且z是一个左孩子"><a href="#情况-3：z的叔结点y为黑色的且z是一个左孩子" class="headerlink" title="情况 3：z的叔结点y为黑色的且z是一个左孩子"></a>情况 3：z的叔结点y为黑色的且z是一个左孩子</h4><p>如图所示，在case2、3中，此时叔结点$y$为黑色。如果为case 2，当前$z$为有右孩子，那么将$z$变为$z.p$，同时对结点$z$进行一次左旋，使之变为情况3。在case 3中，将此时$z$为左孩子，将$z.p$置为黑色，同时将$z.p.p$置为红色，对$z.p.p$进行一次右旋。完成case 3的操作后，此时已经满足了红黑树的性质。<br><strong>对于case 2而言，实际是通过旋转和变色，使$z$转化为一个左孩子，然后在case 3中，我们通过旋转和变色，相当于将C的黑色传递给B，令B代替C继续连接上层结点，同时满足红黑树的性质</strong>。</p><p><img src="/2019/08/18/数据结构-红黑树/INSERTcase23.PNG" alt="RB-INSERT-FIXUP case 2 and 3"><br>&emsp;无论是从case 2到case 3还是直接从case 1到case 3。最多进行2次旋转，可在常数时间内完成，结合case 1。<code>RB-TREE-FIXUP</code>的时间复杂度为$O(lgn)$。因此，对于一次插入操作，总的时间复杂度为$O(lgn)$。</p><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>&emsp;红黑树的删除操作（<code>RB-DELETE</code>）相比插入操作更复杂一点。类似BST的实现，删除某个结点，利用该结点的后继代替该结点位置，若后继存在右孩子，将其右孩子代替后继的位置。处理完成后，类似插入操作，需要对树进行调整，从而满足红黑树的性质，该过程通过RB-DELETE-FIXUP函数完成。<br>下面使删除操作的伪代码，将树$T$中的结点$z$删除。</p><p>删除过程中，需要采用一个结点替换另外一个结点的位置，采用<code>RB-TRANSPLANT(T,x,y)</code>实现，该函数实现用$y$结点（可以为空，我们的T.nil采用哨兵实现，一定存在，因此可以当成内部结点处理）。</p><p>下面是<code>RB-TRANSPLANT</code>的伪代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RB-TRANSPLANT(T,u,v)</span><br><span class="line">    <span class="keyword">if</span> u.p == T.nil<span class="comment">//u为根节点</span></span><br><span class="line">        T.root = v</span><br><span class="line">    elseif u == u.p.left</span><br><span class="line">        u.p.left = v</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        u.p.right = v</span><br><span class="line">    v.p = u.p</span><br></pre></td></tr></table></figure></p><p>下面是删除操作<code>TREE-DELETE</code>的伪代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">RB-DELETE(T,z)</span><br><span class="line">    y = z</span><br><span class="line">    y_original_color = y.color</span><br><span class="line">    <span class="keyword">if</span> z.left == T.nil<span class="comment">//左子树为空，采用右子树代替z</span></span><br><span class="line">        x = z.right</span><br><span class="line">        RB-TRANSPLANT(T,z,z.right)</span><br><span class="line">    elseif z.right == T.nil<span class="comment">//右子树为空，采用左子树代替z</span></span><br><span class="line">        x = z.right</span><br><span class="line">        RB-TRANSPLANT(T,z,z.left)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y = TREE-MINIMUM(z.right)<span class="comment">//采用后继代替</span></span><br><span class="line">        y_original_color = y.color</span><br><span class="line">        x = y.right</span><br><span class="line">        <span class="keyword">if</span> y.p == z<span class="comment">//后继是z的右孩子</span></span><br><span class="line">            x.p = y</span><br><span class="line">        <span class="keyword">else</span> RB-TRANSPLANT(T,y,y.right)<span class="comment">//不是右孩子，需要将y用其右孩子替换</span></span><br><span class="line">             y.right = z.right</span><br><span class="line">             y.right.p = y</span><br><span class="line">        RB-TRANSPLANT(T,z,y)</span><br><span class="line">        y.left = z.left</span><br><span class="line">        y.left.p = y</span><br><span class="line">        y.color = z.color</span><br><span class="line">    <span class="keyword">if</span> y_original_color == BLACK <span class="comment">//被取走的后继是黑色，需要进行调整</span></span><br><span class="line">        RB-DELETE-FIXUP(T,x)</span><br></pre></td></tr></table></figure></p><p>&emsp;删除操作中$y$记录被删除的结点$z$或作为替换$z$的结点，同时$y_original_color$记录它的颜色。同时记录$y$的右子树$x$，它是替换$y$的结点，同时后面可能需要对$x$为根的子树进行调整。</p><ul><li>假设$z$只有单个孩子或没有孩子，那么$y = z$即是被删除的结点。 $x = x.right$为替换$y$的结点。同时记录$y_original_color$，如果$y_original_color$为红色，$\because y = z$最多只有一个孩子，删除它后用它的孩子代替，不会影响红黑树的性质。否则如果$y$为黑色，那么将会引起$x$为根的子树的黑高减1，需要进行调整。即最后一行判断语句。</li><li>假设$z$存在两个孩子，那么取$y =$TREE-MINIMUM($x.right$)，此时$y$记录替换$z$的结点。同时更新$y_original_color$和$x$。如果$y$是$z$的右孩子，此时我们令$x.p = y$，后面只需要执行<code>RB-TRANSPLANT(T,z,y)</code>用$y$替换$z$，更新$y$的左子树链接，否则，需要用$x = y.right$先替换$y$，更新$y$的右子树链接。和上面相同，用$y$替换$z$，如果$y$的颜色是黑色，会引起$x$为根的子树的黑高-1，需要后面进行调整。</li></ul><p><strong>详细的证明参考算法导论</strong></p><p>最后是<code>RB-DELETE-FIXUP</code>的伪代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">RB-DELETE-FIXUP(T,x)</span><br><span class="line">    <span class="keyword">while</span> x != T.root AND x.color == BLACK</span><br><span class="line">        <span class="keyword">if</span> x == x.p.left</span><br><span class="line">            w = x.p.right<span class="comment">//brother node</span></span><br><span class="line">            <span class="keyword">if</span> w.color == RED</span><br><span class="line">                w.color = BLACK<span class="comment">//case 1</span></span><br><span class="line">                x.p.color = RED<span class="comment">//case 1</span></span><br><span class="line">                LEFT-ROTATE(T,x.w)<span class="comment">//case 1</span></span><br><span class="line">                w = w.p.right<span class="comment">//case 1</span></span><br><span class="line">            <span class="keyword">if</span>  w.left.color == BLAKC AND w.right.color == BLACK</span><br><span class="line">                w.color = RED<span class="comment">//case 2</span></span><br><span class="line">                x = x.p<span class="comment">//case 2</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span> w.right.color == BLACK</span><br><span class="line">                    w.color = RED<span class="comment">//case 3</span></span><br><span class="line">                    w.left.color =BLACK<span class="comment">//case 3</span></span><br><span class="line">                    RIGHT-ROTATE(T,w)<span class="comment">//case 3</span></span><br><span class="line">                    w = x.p.right<span class="comment">//case 3</span></span><br><span class="line">                w.color = x.p.color<span class="comment">//case 4</span></span><br><span class="line">                x.p.color = BLACK<span class="comment">//case 4</span></span><br><span class="line">                w.right.color = BLACK<span class="comment">//case 4</span></span><br><span class="line">                LEFT-ROTATE(T,x.p)<span class="comment">//case 4</span></span><br><span class="line">                x = T.root<span class="comment">//case 4</span></span><br><span class="line">        <span class="keyword">else</span> (same as then clause with <span class="string">"right"</span> <span class="keyword">and</span> <span class="string">"left"</span> exchanged)</span><br><span class="line">    x.color = BLACK</span><br></pre></td></tr></table></figure><p>&emsp;上面讲到，用删除 $y$ 或 $y$ 代替$z$后，如果$y_original_color$为黑色，会引起$x$为根的子树的黑高减1。<strong>对于这个黑高减1，我们可以把它理解为 将$y$ 的黑色加到了结点$x$上，此时$x$为双黑色或红黑色，RB-DELETE-FIXUP的过程实质上就是通过旋转和变色等操作，将结点$x$上多出来的黑色抽取出来，放在另一个节点上，然后通过调整树，使之满足红黑树的性质</strong>。</p><p>红黑树的删除调整操作中，可以分为8种情况，类似插入调整操作。删除调整操作根据结点$x$是左孩子还是右孩子分为对称的4种操作。这里实现$x$为左孩子的情形，当$x$为右孩子时，只需要将处理左孩子的情况中出现的<code>left</code>和<code>right</code>进行对调即可。</p><p>首先注意，<strong>$while$循环时，$x$始终指向双黑色结点，直到$x$到达根节点，或者$x.color  = RED$,即$x$抽取出黑色，放置到其他点上，并满足红黑树的性质。</strong> </p><p>这里简单概述下这4种情况。这4种情况并不是相互独立的。</p><ul><li>对于case 1，兄弟结点$w$为红色时，那么可以通过旋转变色获取$w$的一个黑色孩子，作为自己新的兄弟。当$x$的兄弟为黑色时，此时转化为case 2，3，4。</li><li>在$w$的孩子均为黑色结点时，此时为case 2，我们可以将$x$和$w$的黑色抽出，传递给$x.p$，此时$x.p$成为新的$x$进入下一轮循环。</li><li>若$w$左孩子为红色，右孩子为黑色，此时为case 3，然后我们通过旋转和变色，令$w$的右孩子为红色，从而转化为case 4。</li><li>当case 4时，$w$为红色，同时它的右孩子为红色，然后通过旋转和变色，将$w$的黑色抽取出来，放置在原来的父结点上，同时令$x = T.root$跳出循环。</li></ul><p>下面将具体讨论$x$为左孩子的4种情况。</p><h4 id="情况-1：x的兄弟结点w是红色的"><a href="#情况-1：x的兄弟结点w是红色的" class="headerlink" title="情况 1：x的兄弟结点w是红色的"></a>情况 1：x的兄弟结点w是红色的</h4><p>&emsp;如图，此时结点$x$为双黑色，结点$w$为红色，那么根据红黑树的性质4，$w$的父子结点均为黑色。我们将$x.p$和$w$的颜色交换，然后对$x.p$进行进行一次左旋，最后更新$w$，通过这样的操作，我们将原来$w$的一个黑色的孩子作为$x$的兄弟。从而换为case 2，3，4。<br><img src="/2019/08/18/数据结构-红黑树/Deletecase1.PNG" alt="RB-DELETE-FIXUP case 1"></p><h4 id="情况-2：x的兄弟结点w是黑色的，而且w的两个子结点都是黑色的"><a href="#情况-2：x的兄弟结点w是黑色的，而且w的两个子结点都是黑色的" class="headerlink" title="情况 2：x的兄弟结点w是黑色的，而且w的两个子结点都是黑色的"></a>情况 2：x的兄弟结点w是黑色的，而且w的两个子结点都是黑色的</h4><p>&emsp;如图，<strong>其中灰色的结点对颜色无要求，既可以是红色也可以是黑色，实际编程中，不存在灰色结点。</strong><br>此时，$w$为黑色，同时孩子均为黑色。此时，我们将$w.color = RED$，该操作实质上是将$x$和$w$的黑色抽出，放置到$x.p$中，然后$x = x.p$，此时$x.p$称为新的$x$，因为此时它具有双重颜色，或者红黑色，或者双黑色。如果是通过case 1转化为case 2，那么新的$x$为红黑色，此时将会跳出循环，同时，我们令$x.color = BLACK$，完成后，此时成功将$x$的黑色抽出放在另一个结点上，同时满足红黑树性质。如果$x.p$原来为黑色，那么它将变为双黑色，则进入下一次$while$循环。</p><p>最坏情况下，每次$w$和它的孩子均是黑色，此时时间复杂度为$lg(n)$。</p><p><img src="/2019/08/18/数据结构-红黑树/Deletecase2.PNG" alt="RB-DELETE-FIXUP case 2"></p><h4 id="情况-3：x的兄弟结点w是黑色的，w的左孩子是红色的，w的右孩子是黑色的。"><a href="#情况-3：x的兄弟结点w是黑色的，w的左孩子是红色的，w的右孩子是黑色的。" class="headerlink" title="情况 3：x的兄弟结点w是黑色的，w的左孩子是红色的，w的右孩子是黑色的。"></a>情况 3：x的兄弟结点w是黑色的，w的左孩子是红色的，w的右孩子是黑色的。</h4><p>&emsp;在case 2下面的else分支时，此时$w$为黑色，进入该分支，说明$w$的左子树或者右子树为红色。我们的最终目的是使$w$的右孩子为红色结点。因此，在下面的 <code>if  x.right.color == BLACK</code>分支中，说明$w$的左孩子为红色，此时，我们通过交换$w$和$w.left$的颜色，然后对$w$进行一次右旋，从而使$w$获得一个红色的右孩子，最后更新$w = x.p.right$，成功为case 4。如果$if$分支不成立，说明本身具备红色的右孩子，后面的操作也不需要关注左孩子的颜色，此时即为case 4。<br>如图：<br><img src="/2019/08/18/数据结构-红黑树/Deletecase3.PNG" alt="RB-DELETE-FIXUP case 3"></p><h4 id="情况-4：x的兄弟结点w是黑色的，w的右孩子是红色的"><a href="#情况-4：x的兄弟结点w是黑色的，w的右孩子是红色的" class="headerlink" title="情况 4：x的兄弟结点w是黑色的，w的右孩子是红色的"></a>情况 4：x的兄弟结点w是黑色的，w的右孩子是红色的</h4><p>&emsp;如图，当$w$为红色，其他的右孩子是红色时，此时，我们可以交换$x.p$和$w$的颜色，同时将$x.right$置为黑色，然后左旋$x.p$结点。最终满足红黑树性质。<strong>令$x.p$为黑色，实质上是使$x$为根的子树的黑高加1，相当于抽取出，x为黑色，此时x满足性质1，x为根的子树黑高加1满足性质5，同时w的左子树，即图中的C的黑高不变。但是此时$w$的右子树黑高减1，但是我们可以通过将$w.right$即图中的E置为黑色，从而使其黑高不变，此时整体满足红黑树性质</strong>，置$x = T.root$退出循环。</p><p><img src="/2019/08/18/数据结构-红黑树/Deletecase4.PNG" alt="在这里插入图片描述"></p><p>对于<code>RB-DELETE-FIXUP</code>唯一可能进行迭代的是case 2，沿树上升至多$O(lgn)$次期间不进行任何旋转，对于case 1，3，4的旋转操作，最多尽量3次。因此<code>RB-DELETE-FIXUP</code>的时间复杂度为$O(lgn)$。</p><h2 id="3、红黑树的实现"><a href="#3、红黑树的实现" class="headerlink" title="3、红黑树的实现"></a>3、红黑树的实现</h2><p>下面红黑树采用C++实现，为了和上面的伪代码形式一致，便于理解，没有采用类封装操作，只包含一些C++特性。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//定义颜色宏</span></span><br><span class="line"><span class="keyword">enum</span> COLOR&#123;RED,BLACK&#125;;</span><br><span class="line"><span class="comment">//结点定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Node&lt;T&gt;* left;</span><br><span class="line">    Node&lt;T&gt;* right;</span><br><span class="line">    Node&lt;T&gt;* p;</span><br><span class="line">    T key;</span><br><span class="line">    COLOR color;</span><br><span class="line">    Node():color(BLACK)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//结点指针定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> pNode=Node&lt;T&gt;*;</span><br><span class="line"><span class="comment">//红黑树定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RBTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> pNode&lt;T&gt; nil;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Singleton Model</span></span><br><span class="line"><span class="comment">     * 采用local-static对象</span></span><br><span class="line"><span class="comment">     * 使模板参数相同的对象公用一个nil</span></span><br><span class="line"><span class="comment">     * 在main函数前被使用。</span></span><br><span class="line"><span class="comment">     * 具体参考 下面这篇博客</span></span><br><span class="line"><span class="comment">     * https://blog.csdn.net/qq_40512922/article/details/90589657#41_274</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> pNode&lt;T&gt; getInstance()&#123;</span><br><span class="line">        <span class="keyword">static</span> Node&lt;T&gt; one_instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;one_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    pNode&lt;T&gt; root;</span><br><span class="line">    RBTree():root(nil)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//初始化 nil</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">pNode&lt;T&gt; RBTree&lt;T&gt;::nil=RBTree&lt;T&gt;::getInstance();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Function Decleration</span></span><br><span class="line"><span class="comment">    ----------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RBTree_insert</span><span class="params">(RBTree&lt;T&gt; &amp;t,pNode&lt;T&gt; z)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//插入调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RBTree_insert_fixup</span><span class="params">(RBTree&lt;T&gt; &amp;t,pNode&lt;T&gt; z)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RBTree_delete</span><span class="params">(RBTree&lt;T&gt; &amp;t,pNode&lt;T&gt; z)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//删除调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RBTree_delete_fixup</span><span class="params">(RBTree&lt;T&gt; &amp;t,pNode&lt;T&gt; x)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//O(1)空间复杂度迭代中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder_travel_iterative</span><span class="params">(pNode&lt;T&gt; x)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//常规递归中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder_travel_recursive</span><span class="params">(pNode&lt;T&gt; x)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//结点x的后继</span></span><br><span class="line">pNode&lt;T&gt; tree_successor(pNode&lt;T&gt; x);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//利用后继函数在O(n)有序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_travel_successor</span><span class="params">(pNode&lt;T&gt; x)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//左旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left_rotate</span><span class="params">(RBTree&lt;T&gt; &amp;t,pNode&lt;T&gt; z)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//右旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">right_rotate</span><span class="params">(RBTree&lt;T&gt; &amp;t,pNode&lt;T&gt; z)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//结点x为根的子树的最小值</span></span><br><span class="line">pNode&lt;T&gt; tree_minimum(pNode&lt;T&gt; x);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//初始化Vector</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getInitVec</span><span class="params">(<span class="built_in">vector</span>&lt;pNode&lt;T&gt;&gt; &amp;vec)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeVec</span><span class="params">(<span class="built_in">vector</span>&lt;pNode&lt;T&gt;&gt; &amp;vec)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//打印结点x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Node&lt;T&gt;*x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Function Definition</span></span><br><span class="line"><span class="comment">    ----------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Node&lt;T&gt;*x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x-&gt;key;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;color==BLACK)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"[BLACK] "</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"[RED] "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder_travel_recursive</span><span class="params">(pNode&lt;T&gt; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=RBTree&lt;T&gt;::nil)</span><br><span class="line">    &#123;</span><br><span class="line">        inorder_travel_recursive(x-&gt;left);</span><br><span class="line">        print(x);</span><br><span class="line">        inorder_travel_recursive(x-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder_travel_iterative</span><span class="params">(pNode&lt;T&gt; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==RBTree&lt;T&gt;::nil)<span class="keyword">return</span>;</span><br><span class="line">    pNode&lt;T&gt; y=RBTree&lt;T&gt;::nil;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y!=x-&gt;left)</span><br><span class="line">            <span class="keyword">while</span>(x-&gt;left!=RBTree&lt;T&gt;::nil)</span><br><span class="line">                x=x-&gt;left;</span><br><span class="line">        <span class="keyword">if</span>(x-&gt;right!=RBTree&lt;T&gt;::nil)</span><br><span class="line">        &#123;</span><br><span class="line">            x=x-&gt;right;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            y=x;</span><br><span class="line">            x=x-&gt;p;</span><br><span class="line">            <span class="keyword">if</span>(x==RBTree&lt;T&gt;::nil)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(y==x-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left_rotate</span><span class="params">(RBTree&lt;T&gt; &amp;t,pNode&lt;T&gt; x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pNode&lt;T&gt; y=x-&gt;right;</span><br><span class="line">    x-&gt;right=y-&gt;left;</span><br><span class="line">    <span class="keyword">if</span>(y-&gt;left!=RBTree&lt;T&gt;::nil)</span><br><span class="line">        y-&gt;left-&gt;p=x;</span><br><span class="line">    y-&gt;p=x-&gt;p;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;p==RBTree&lt;T&gt;::nil)</span><br><span class="line">        t.root=y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x-&gt;p-&gt;left==x)</span><br><span class="line">        x-&gt;p-&gt;left=y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x-&gt;p-&gt;right=y;</span><br><span class="line">    y-&gt;left=x;</span><br><span class="line">    x-&gt;p=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">right_rotate</span><span class="params">(RBTree&lt;T&gt; &amp;t,pNode&lt;T&gt; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pNode&lt;T&gt; y=x-&gt;left;</span><br><span class="line">    x-&gt;left=y-&gt;right;</span><br><span class="line">    <span class="keyword">if</span>(y-&gt;right!=RBTree&lt;T&gt;::nil)</span><br><span class="line">        y-&gt;right-&gt;p=x;</span><br><span class="line">    y-&gt;p=x-&gt;p;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;p==RBTree&lt;T&gt;::nil)</span><br><span class="line">        t.root=y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x-&gt;p-&gt;left==x)</span><br><span class="line">        x-&gt;p-&gt;left=y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x-&gt;p-&gt;right=y;</span><br><span class="line">    y-&gt;right=x;</span><br><span class="line">    x-&gt;p=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RBTree_insert</span><span class="params">(RBTree&lt;T&gt; &amp;t,pNode&lt;T&gt; z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pNode&lt;T&gt; y=RBTree&lt;T&gt;::nil;</span><br><span class="line">    pNode&lt;T&gt; x=t.root;</span><br><span class="line">    <span class="keyword">while</span>(x!=RBTree&lt;T&gt;::nil)</span><br><span class="line">    &#123;</span><br><span class="line">        y=x;</span><br><span class="line">        <span class="keyword">if</span>(z-&gt;key&lt;x-&gt;key)</span><br><span class="line">            x=x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x=x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;p=y;</span><br><span class="line">    <span class="keyword">if</span>(y==RBTree&lt;T&gt;::nil)</span><br><span class="line">        t.root=z;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;key&lt;y-&gt;key)</span><br><span class="line">        y-&gt;left=z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;right=z;</span><br><span class="line">    z-&gt;left=z-&gt;right=RBTree&lt;T&gt;::nil;</span><br><span class="line">    z-&gt;color=RED;</span><br><span class="line">    RBTree_insert_fixup(t,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RBTree_insert_fixup</span><span class="params">(RBTree&lt;T&gt; &amp;t,pNode&lt;T&gt; z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(z-&gt;p-&gt;color==RED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(z-&gt;p==z-&gt;p-&gt;p-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            pNode&lt;T&gt; y=z-&gt;p-&gt;p-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(y-&gt;color==RED)</span><br><span class="line">            &#123;</span><br><span class="line">                z-&gt;p-&gt;color=BLACK;<span class="comment">//case 1</span></span><br><span class="line">                y-&gt;color=BLACK;</span><br><span class="line">                z-&gt;p-&gt;p-&gt;color=RED;</span><br><span class="line">                z=z-&gt;p-&gt;p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(z==z-&gt;p-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    z=z-&gt;p;<span class="comment">//case 2</span></span><br><span class="line">                    left_rotate(t,z);</span><br><span class="line">                &#125;</span><br><span class="line">                z-&gt;p-&gt;color=BLACK;<span class="comment">//case 3</span></span><br><span class="line">                z-&gt;p-&gt;p-&gt;color=RED;</span><br><span class="line">                right_rotate(t,z-&gt;p-&gt;p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//end-if</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pNode&lt;T&gt; y=z-&gt;p-&gt;p-&gt;left;</span><br><span class="line">            <span class="keyword">if</span>(y-&gt;color==RED)</span><br><span class="line">            &#123;</span><br><span class="line">                z-&gt;p-&gt;color=BLACK;</span><br><span class="line">                y-&gt;color=BLACK;</span><br><span class="line">                z-&gt;p-&gt;p-&gt;color=RED;</span><br><span class="line">                z=z-&gt;p-&gt;p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(z==z-&gt;p-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    z=z-&gt;p;</span><br><span class="line">                    right_rotate(t,z);</span><br><span class="line">                &#125;</span><br><span class="line">                z-&gt;p-&gt;color=BLACK;</span><br><span class="line">                z-&gt;p-&gt;p-&gt;color=RED;</span><br><span class="line">                left_rotate(t,z-&gt;p-&gt;p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//end-else</span></span><br><span class="line">    &#125;<span class="comment">//end while</span></span><br><span class="line">    t.root-&gt;color=BLACK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">pNode&lt;T&gt; tree_minimum(pNode&lt;T&gt; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(x-&gt;left!=RBTree&lt;T&gt;::nil)</span><br><span class="line">        x=x-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RBTree_transplant</span><span class="params">(RBTree&lt;T&gt; &amp;t,pNode&lt;T&gt; u,pNode&lt;T&gt; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u-&gt;p==RBTree&lt;T&gt;::nil)</span><br><span class="line">        t.root=v;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(u==u-&gt;p-&gt;left)</span><br><span class="line">        u-&gt;p-&gt;left=v;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        u-&gt;p-&gt;right=v;</span><br><span class="line">    v-&gt;p=u-&gt;p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RBTree_delete</span><span class="params">(RBTree&lt;T&gt; &amp;t,pNode&lt;T&gt; z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pNode&lt;T&gt; y=z;</span><br><span class="line">    pNode&lt;T&gt; x;</span><br><span class="line">    COLOR y_original_color=y-&gt;color;</span><br><span class="line">    <span class="keyword">if</span>(z-&gt;left==RBTree&lt;T&gt;::nil)</span><br><span class="line">    &#123;</span><br><span class="line">        x=z-&gt;right;</span><br><span class="line">        RBTree_transplant(t,z,z-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;right==RBTree&lt;T&gt;::nil)</span><br><span class="line">    &#123;</span><br><span class="line">        x=z-&gt;left;</span><br><span class="line">        RBTree_transplant(t,z,z-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        y=tree_minimum(z-&gt;right);</span><br><span class="line">        y_original_color=y-&gt;color;</span><br><span class="line">        x=y-&gt;right;</span><br><span class="line">        <span class="keyword">if</span>(y-&gt;p==z)</span><br><span class="line">            x-&gt;p=y;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            RBTree_transplant(t,y,y-&gt;right);</span><br><span class="line">            y-&gt;right=z-&gt;right;</span><br><span class="line">            y-&gt;right-&gt;p=y;</span><br><span class="line">        &#125;</span><br><span class="line">        RBTree_transplant(t,z,y);</span><br><span class="line">        y-&gt;left=z-&gt;left;</span><br><span class="line">        y-&gt;left-&gt;p=y;</span><br><span class="line">        y-&gt;color=z-&gt;color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(y_original_color==BLACK)</span><br><span class="line">        RBTree_delete_fixup(t,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RBTree_delete_fixup</span><span class="params">(RBTree&lt;T&gt; &amp;t,pNode&lt;T&gt; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=t.root&amp;&amp;x-&gt;color==BLACK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x==x-&gt;p-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            pNode&lt;T&gt; w=x-&gt;p-&gt;right;<span class="comment">//兄弟</span></span><br><span class="line">            <span class="keyword">if</span>(w-&gt;color==RED)</span><br><span class="line">            &#123;</span><br><span class="line">                w-&gt;color=BLACK;<span class="comment">//case 1</span></span><br><span class="line">                x-&gt;p-&gt;color=RED;</span><br><span class="line">                left_rotate(t,x-&gt;p);</span><br><span class="line">                w=x-&gt;p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(w-&gt;left-&gt;color==BLACK&amp;&amp;w-&gt;right-&gt;color==BLACK)</span><br><span class="line">            &#123;</span><br><span class="line">                w-&gt;color=RED;<span class="comment">//case 2</span></span><br><span class="line">                x=x-&gt;p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(w-&gt;right-&gt;color==BLACK)</span><br><span class="line">                &#123;</span><br><span class="line">                    w-&gt;left-&gt;color=BLACK;<span class="comment">//case 3</span></span><br><span class="line">                    w-&gt;color=RED;</span><br><span class="line">                    right_rotate(t,w);</span><br><span class="line">                    w=x-&gt;p-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                w-&gt;color=x-&gt;p-&gt;color;<span class="comment">//case 4</span></span><br><span class="line">                x-&gt;p-&gt;color=BLACK;</span><br><span class="line">                w-&gt;right-&gt;color=BLACK;</span><br><span class="line">                left_rotate(t,x-&gt;p);</span><br><span class="line">                x=t.root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//end-if</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pNode&lt;T&gt; w=x-&gt;p-&gt;left;<span class="comment">//兄弟</span></span><br><span class="line">            <span class="keyword">if</span>(w-&gt;color==RED)</span><br><span class="line">            &#123;</span><br><span class="line">                w-&gt;color=BLACK;<span class="comment">//case 1</span></span><br><span class="line">                x-&gt;p-&gt;color=RED;</span><br><span class="line">                right_rotate(t,x-&gt;p);</span><br><span class="line">                w=x-&gt;p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(w-&gt;left-&gt;color==BLACK&amp;&amp;w-&gt;right-&gt;color==BLACK)</span><br><span class="line">            &#123;</span><br><span class="line">                w-&gt;color=RED;<span class="comment">//case 2</span></span><br><span class="line">                x=x-&gt;p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(w-&gt;left-&gt;color==BLACK)</span><br><span class="line">                &#123;</span><br><span class="line">                    w-&gt;right-&gt;color=BLACK;<span class="comment">//case 3</span></span><br><span class="line">                    w-&gt;color=RED;</span><br><span class="line">                    left_rotate(t,w);</span><br><span class="line">                    w=x-&gt;p-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                w-&gt;color=x-&gt;p-&gt;color;<span class="comment">//case 4</span></span><br><span class="line">                x-&gt;p-&gt;color=BLACK;</span><br><span class="line">                w-&gt;left-&gt;color=BLACK;</span><br><span class="line">                right_rotate(t,x-&gt;p);</span><br><span class="line">                x=t.root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//end-else</span></span><br><span class="line">    &#125;</span><br><span class="line">    x-&gt;color=BLACK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">pNode&lt;T&gt; RBTree_search(RBTree&lt;T&gt; t,T key)</span><br><span class="line">&#123;</span><br><span class="line">    pNode&lt;T&gt; x=t.root;</span><br><span class="line">    <span class="keyword">while</span>(x!=RBTree&lt;T&gt;::nil)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(key==x-&gt;key)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;x-&gt;key)</span><br><span class="line">            x=x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x=x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">pNode&lt;T&gt; tree_successor(pNode&lt;T&gt; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;right!=RBTree&lt;T&gt;::nil)</span><br><span class="line">        <span class="keyword">return</span> tree_minimum(x-&gt;right);</span><br><span class="line">    pNode&lt;T&gt; y=x-&gt;p;</span><br><span class="line">    <span class="keyword">while</span>(y!=RBTree&lt;T&gt;::nil&amp;&amp;x==y-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        x=y;</span><br><span class="line">        y=y-&gt;p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_travel_successor</span><span class="params">(pNode&lt;T&gt; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==RBTree&lt;T&gt;::nil)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    x=tree_minimum(x);</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        print(x);</span><br><span class="line">        x=tree_successor(x);</span><br><span class="line">    &#125;<span class="keyword">while</span>(x!=RBTree&lt;T&gt;::nil);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *特例化 integer类型的随机初始化模板。</span></span><br><span class="line"><span class="comment"> *因为下面的 uniform_int_distrbution只支持整型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">getInitVec</span><span class="params">(<span class="built_in">vector</span>&lt;pNode&lt;<span class="keyword">int</span>&gt;&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> default_random_engine <span class="title">e</span><span class="params">(time(<span class="literal">nullptr</span>))</span></span>;</span><br><span class="line">    <span class="keyword">static</span> uniform_int_distribution&lt;<span class="keyword">int</span>&gt; d(<span class="number">0</span>,<span class="number">50000</span>);</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:vec)&#123;</span><br><span class="line">        i=<span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        i-&gt;key=d(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *特例化double类型的随机初始化模板</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">getInitVec</span><span class="params">(<span class="built_in">vector</span>&lt;pNode&lt;<span class="keyword">double</span>&gt;&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> default_random_engine <span class="title">e</span><span class="params">(time(<span class="literal">nullptr</span>))</span></span>;</span><br><span class="line">    <span class="keyword">static</span> uniform_real_distribution&lt;<span class="keyword">double</span>&gt; d(<span class="number">0</span>,<span class="number">50000</span>);</span><br><span class="line">    <span class="keyword">double</span> key;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:vec)&#123;</span><br><span class="line">        i=<span class="keyword">new</span> Node&lt;<span class="keyword">double</span>&gt;();</span><br><span class="line">        i-&gt;key=d(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeVec</span><span class="params">(<span class="built_in">vector</span>&lt;pNode&lt;T&gt;&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">delete</span> i;</span><br><span class="line">    i=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RBTree_property_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input the cnt:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; cnt;</span><br><span class="line">    RBTree&lt;<span class="keyword">int</span>&gt; T;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pNode&lt;<span class="keyword">int</span>&gt;&gt; vec(cnt);</span><br><span class="line">    getInitVec(vec);</span><br><span class="line">    <span class="keyword">clock_t</span> sta=clock();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec)</span><br><span class="line">        RBTree_insert(T,i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:vec)</span><br><span class="line">        RBTree_delete(T,i);</span><br><span class="line">    <span class="keyword">clock_t</span> interval=clock()-sta;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"CLOCKS_PER_SEC = "</span> &lt;&lt; CLOCKS_PER_SEC &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"succed\n"</span> &lt;&lt; interval &lt;&lt; <span class="string">" clocks (when CLOCKS_PER_SEC=1000,equal to ms)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; interval/CLOCKS_PER_SEC &lt;&lt; <span class="string">" s"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RBTree_property_test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构-红黑树&quot;&gt;&lt;a href=&quot;#数据结构-红黑树&quot; class=&quot;headerlink&quot; title=&quot;数据结构-红黑树&quot;&gt;&lt;/a&gt;数据结构-红黑树&lt;/h1&gt;&lt;h2 id=&quot;1、红黑树简介&quot;&gt;&lt;a href=&quot;#1、红黑树简介&quot; class=&quot;header
      
    
    </summary>
    
      <category term="数据结构" scheme="http://007havegone.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="红黑树" scheme="http://007havegone.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
      <category term="平衡树" scheme="http://007havegone.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
      <category term="数据结构" scheme="http://007havegone.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>算法导论思考题12-1</title>
    <link href="http://007havegone.github.io/2019/08/17/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E6%80%9D%E8%80%83%E9%A2%9812-1/"/>
    <id>http://007havegone.github.io/2019/08/17/算法导论思考题12-1/</id>
    <published>2019-08-17T06:12:32.000Z</published>
    <updated>2019-08-17T07:16:29.033Z</updated>
    
    <content type="html"><![CDATA[<h3 id="12-1（带有相同关键字的二叉搜索树）相同关键字给二叉搜索树的实现带来了问题。"><a href="#12-1（带有相同关键字的二叉搜索树）相同关键字给二叉搜索树的实现带来了问题。" class="headerlink" title="12-1（带有相同关键字的二叉搜索树）相同关键字给二叉搜索树的实现带来了问题。"></a>12-1（带有相同关键字的二叉搜索树）相同关键字给二叉搜索树的实现带来了问题。</h3><h4 id="a-emsp-当用TREE-INSERT将-n-个其中带有相同关键字的数据插入到一棵初始为空的二叉搜索树中时，其渐进性能是多少？"><a href="#a-emsp-当用TREE-INSERT将-n-个其中带有相同关键字的数据插入到一棵初始为空的二叉搜索树中时，其渐进性能是多少？" class="headerlink" title="a. &emsp;当用TREE-INSERT将$n$个其中带有相同关键字的数据插入到一棵初始为空的二叉搜索树中时，其渐进性能是多少？"></a>a. &emsp;当用<code>TREE-INSERT</code>将$n$个其中带有相同关键字的数据插入到一棵初始为空的二叉搜索树中时，其渐进性能是多少？</h4><p>最坏情况下，所有关键字相同，那么将形成一个单链。时间复杂度为$O(n^2)$。</p><p>&emsp;建议通过在第5行之前测试$z.key = x.key$和在11行之前测试$z.key = y.key$的方法，来对<code>TREE-INSERT</code>改进。如果相等，根据下面的策略之一来实现。对于每个策略，得到将$n$个其中带有相同关键字的数据插入到一棵初始为空的二叉搜索树中的渐进性能。（对第5行描述的策略时比较$x$和$z$的关键字，用于第11行的策略是用$y代替$x$。）</p><hr><h4 id="b-emsp-在结点x设置一个布尔标志-x-b-，并根据-x-b-的值，置-x-为-x-left-或-x-right-。当插入一个结点与x关键字相同的结点时，每次访问-x-时交替地-x-b-为FALSE或TRUE。"><a href="#b-emsp-在结点x设置一个布尔标志-x-b-，并根据-x-b-的值，置-x-为-x-left-或-x-right-。当插入一个结点与x关键字相同的结点时，每次访问-x-时交替地-x-b-为FALSE或TRUE。" class="headerlink" title="b.&emsp;在结点x设置一个布尔标志$x.b$，并根据$x.b$的值，置$x$为$x.left$或$x.right$。当插入一个结点与x关键字相同的结点时，每次访问$x$时交替地$x.b$为FALSE或TRUE。"></a>b.&emsp;在结点x设置一个布尔标志$x.b$，并根据$x.b$的值，置$x$为$x.left$或$x.right$。当插入一个结点与x关键字相同的结点时，每次访问$x$时交替地$x.b$为FALSE或TRUE。</h4><p>采用这种策略时，多个相同关键字插入时，每个结点的左右子树高度叉不超过1。将形成一棵平衡的二叉搜索树，并在只有在第$k$层填充后，才会填充下一层。因此渐进性能为$\Theta(nlgn)$。下面时图示。下面的结点关键字均相同。</p><p><img src="/2019/08/17/算法导论思考题12-1/12b.PNG" alt></p><hr><h4 id="c-emsp-在-x-处设置一个与-x-关键字相同的结点列表，并将-z-插入到该表中。"><a href="#c-emsp-在-x-处设置一个与-x-关键字相同的结点列表，并将-z-插入到该表中。" class="headerlink" title="c.&emsp;在$x$处设置一个与$x$关键字相同的结点列表，并将$z$插入到该表中。"></a>c.&emsp;在$x$处设置一个与$x$关键字相同的结点列表，并将$z$插入到该表中。</h4><p>相当于在结点处采用一个链表存储相同关键字的结点。因此，树的高度为0，采用前插法的方式，总的时间复杂度$O(n)$。</p><hr><h4 id="d-emsp-随机设置-x-为-x-left-或-x-right-。（给出最坏情况性能，并非形式化的导出期望运行时间。）"><a href="#d-emsp-随机设置-x-为-x-left-或-x-right-。（给出最坏情况性能，并非形式化的导出期望运行时间。）" class="headerlink" title="d.&emsp;随机设置$x$为$x.left$或$x.right$。（给出最坏情况性能，并非形式化的导出期望运行时间。）"></a>d.&emsp;随机设置$x$为$x.left$或$x.right$。（给出最坏情况性能，并非形式化的导出期望运行时间。）</h4><p>最坏情况下，所有结点均插入左子树或右子树。每次操作为$O(n)$，总的时间复杂度为$O(n^2)$。期望运行时间，即选择左子树或右子树的概率相同，因此树会大致平衡，树的高度为$O(lgn)$。总的时间复杂度为$nlgn(n)$。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;12-1（带有相同关键字的二叉搜索树）相同关键字给二叉搜索树的实现带来了问题。&quot;&gt;&lt;a href=&quot;#12-1（带有相同关键字的二叉搜索树）相同关键字给二叉搜索树的实现带来了问题。&quot; class=&quot;headerlink&quot; title=&quot;12-1（带有相同关键字的二
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="二叉搜索树" scheme="http://007havegone.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法导论练习12.3</title>
    <link href="http://007havegone.github.io/2019/08/12/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%BB%83%E4%B9%A012-3/"/>
    <id>http://007havegone.github.io/2019/08/12/算法导论练习12-3/</id>
    <published>2019-08-12T05:53:18.000Z</published>
    <updated>2019-08-12T10:01:08.532Z</updated>
    
    <content type="html"><![CDATA[<p>12.3-1&emsp;给出TREE-INSERT过车过程的一个递归版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现1</span></span><br><span class="line">TREE-INSERT(T,z)</span><br><span class="line">    <span class="keyword">if</span> T.root = NIL <span class="comment">//空树</span></span><br><span class="line">        T.root = z</span><br><span class="line">        z.p = NIL</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">//非空，递归查找合适位置</span></span><br><span class="line">        TREE-INSERT-RECURSIVE(T.root,z)</span><br><span class="line"></span><br><span class="line">TREE-INSERT-RECURSIVE(x,z)</span><br><span class="line">    <span class="keyword">if</span> z.key &lt; x.key</span><br><span class="line">        <span class="keyword">if</span> x.left = NIL</span><br><span class="line">            x.left = z</span><br><span class="line">            z.p = x</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TREE-INSERT-RECURSIVE(x.left,z)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> x.right = NIL</span><br><span class="line">            x.right = z</span><br><span class="line">            z.p = x</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TREE-INSERT-RECURSIVE(x.right,z)</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现2</span></span><br><span class="line"><span class="comment">//调用 TREE-INSERT-CURSIVE(NIL,T.root,z)</span></span><br><span class="line"><span class="comment">//  y为父节点，x为插入位置</span></span><br><span class="line">TREE-INSERT-CURSIVE(y,x,z)</span><br><span class="line">    <span class="keyword">if</span> x != NIL</span><br><span class="line">        <span class="keyword">if</span> z.key &lt; x.key</span><br><span class="line">            TREE-INSERT-CURSIVE(x,x.left,z)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TREE-INSERT-CURSIVE(x,x.right,z)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    z.p = y</span><br><span class="line">    <span class="keyword">if</span> y == NIL</span><br><span class="line">        T.root = z</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> z.key &lt; y.key</span><br><span class="line">        y.left = z</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y.right = z</span><br></pre></td></tr></table></figure><hr><p>12.3-2&emsp;假设通过反复向一棵树中插入互不相同的关键字来构造一棵二叉搜索树。证明：在这棵树中查找关键字所检查过的结点数目等于先前插入这个关键字所检查的结点数目加1。</p><p>证明：根据书中TREE-INSERT的算法，我们插入一个结点，从根节点开始，判断合适位置插入。再次查找它时，我们沿着之前插入时判断的结点的路径（新插入的结点不会出现在该路径上，因此路径相同），最后再多检查结点本身，因此次数+1。</p><hr><p>12.3-3&emsp;对于给定$n$个关键字集合，可以通过先构造包含这些数据的一颗二叉搜索树（反复使用TREE-INSERT逐个插入这些数），然后按中序遍历输出这些数的方法，来对它们排序。这个排序算法的最坏情况运行时间和最好情况运行时间各是多少？</p><p>最坏情况下是BST的高度为$n$，即按已经排序的方式插入。此时运行时间为$\Theta(n^2)$。在最佳情况下，BST的形状是平衡的，意味着它的高度不超过$O(lgn)$。此时运行时间为$O(nlgn)$，在题目12.1-5中已经说明最坏情况的需要$\Omega(nlgn)$。</p><hr><p>12.3-4&emsp;删除操作可交换吗？可交换的含义是，先删除$x$再删除$y$留下的结果树与先删除$y$再删除$x$留下的结果树完全一样。如果是，说明为什么？否则，给出一个反例。</p><p>不可以交换，反例如下：</p><p><img src="/2019/08/12/算法导论练习12-3/3-4.PNG" alt></p><p>先删除1，再删除2，不同于先删除2，再删除1</p><hr><p>12.3-5&emsp;假设为每个结点换一种设计，属性$x.p$指向父亲，属性$x.succ$指向$x$的后继。给出使用这种表示法的二叉搜索树$T$上SEARCH、INSERT和DELETE操作的伪代码。这些伪代码再$O(h)$时间内执行完，其中$h$为$T$的高度。（提示：应该设计一个返回某个结点的双亲的子过程）。</p><p>未解决。有好的想法的可以私我。</p><hr><p>12.3-6&emsp;当TREE-DELETE中的结点$z$有两个孩子时，应该选择结点$y$作为它的前驱，而不是作为它的后继。如果这样做，对TREE-DELETE应该做哪些什么必要的修改？一些人提出了一个公平的策略，为前驱和后继赋予相等的优先级，这样得到了较好的实验性能。如何对TREE-DELETE进行修改来实现这样一种公平策略？</p><p>第一个问题：如果转换成删除前驱，只需要在TREE-DELETE中将有两个孩子的情况修改。</p><p>下面是我的伪代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TREE-DELETE(T,z)</span><br><span class="line">    <span class="keyword">if</span> z.left == NIL</span><br><span class="line">        TRANSPLANT(T,z,z.right)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> z.right == NIL</span><br><span class="line">        TRANSPLANT(T,z,z.left)</span><br><span class="line">    <span class="keyword">else</span> y = TREE-MAXIMUM(z.left)</span><br><span class="line">        <span class="keyword">if</span> y.p != z</span><br><span class="line">            TRANSPLANT(T,y,y.left)</span><br><span class="line">            y.left = z.left</span><br><span class="line">            y.left.p = y</span><br><span class="line">        TREESPLANT(T,z,y)</span><br><span class="line">        y.right = z.right</span><br><span class="line">        y.right.p = y</span><br></pre></td></tr></table></figure><p>第二个问题：要实现前驱后继相等的优先级，当有两个孩子时，可以采用一个随机数来决定采用前驱替换还是后继替换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TREE-DELETE(T,z)</span><br><span class="line">    <span class="keyword">if</span> z.left == NIL</span><br><span class="line">        TRANSPLANT(T,z,z.right)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> z.right == NIL</span><br><span class="line">        TRANSPLANT(T,z,z.left)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        LorR = getRandomBool</span><br><span class="line">        <span class="keyword">if</span> LorR == <span class="literal">true</span></span><br><span class="line">            。。。<span class="comment">//替换后继</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            。。。<span class="comment">//替换前驱</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;12.3-1&amp;emsp;给出TREE-INSERT过车过程的一个递归版本&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="二叉搜索树" scheme="http://007havegone.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法导论练习12.2</title>
    <link href="http://007havegone.github.io/2019/08/09/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%BB%83%E4%B9%A012-2/"/>
    <id>http://007havegone.github.io/2019/08/09/算法导论练习12-2/</id>
    <published>2019-08-08T17:22:44.000Z</published>
    <updated>2019-08-12T08:18:11.140Z</updated>
    
    <content type="html"><![CDATA[<p>12.2-1&emsp;假设一棵二叉搜索树中的结点在1到1000之间，现在想要查找值为363得到结点，下面序列那个不是查找过的序列。</p><p>a. $2,252,401,398,330,344,397,363$。<br>b. $924,220,911,244,898,258,362,363$。<br>c. $925,202,911,240,912,245,363$。<br>d. $2,399,387,219,266,382,381,278,363$。<br>e. $935,278,347,621,299,392,358,363$。</p><p>因为这是查找BST过程中的一个序列，因此根据该序列构造BST，如果满足BST的性质，那么就是查找的序列，否则不是。其中c和e不满足。</p><hr><p>12.2-2&emsp;写出TREE-MINIMUM和TREE-MAXIMUM的递归版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据书上的版本写的，书中没有判断x是否为空的情况</span></span><br><span class="line">TREE-MINIMUM(x)</span><br><span class="line"> <span class="keyword">if</span> x.left == NIL</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"> <span class="keyword">return</span> TREE-MINIMUM(x.left);</span><br><span class="line"></span><br><span class="line">TREE-MAXIMUM(x)</span><br><span class="line"> <span class="keyword">if</span> x.right == NIL</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"> <span class="keyword">return</span> TREE-MAXIMUM(x.right)</span><br></pre></td></tr></table></figure><hr><p>12.2-3&emsp;写出过程TREE-PREDECESSOR的伪代码</p><p>与书上的TREE-SUCCESSOR想对称<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TREE-PREDECESSOR</span><br><span class="line"> <span class="keyword">if</span> x.left != NIL</span><br><span class="line">    <span class="keyword">return</span> TREE-MAXIMUM(x.left)</span><br><span class="line"> y = x.p</span><br><span class="line"> <span class="keyword">while</span> y != NIL <span class="keyword">and</span> y.left == x</span><br><span class="line">    x = y</span><br><span class="line">    y = y.p</span><br><span class="line"><span class="keyword">return</span> y</span><br></pre></td></tr></table></figure></p><hr><p>12.2-4&emsp;Bunyan教授认为他发现了一个二叉搜索树的重要性质。假设在一棵二叉搜索树中查找一个关键字$k$，查找结束于一个树叶。考虑三个集合：$A$为查找路径左边的关键字集合；$B$为u查找路径上的关键字集合；$C$为查找路径右边的关键字集合。Bunyan教授声称：$\forall a \in A,b \in B, c \in C$，一定满足$a \leq b \leq c$。请给出该教授这个论断的一个最小可能的反例。</p><p><img src="/2019/08/09/算法导论练习12-2/2-3.jpg" alt></p><p>查找5，那么$B=\{1,4,5\},A=\{2\},C=\{\}$, 显然不成立。</p><hr><p>12.2-5&emsp;证明：如果一棵二叉搜索树中一个结点有两个孩子，那么它的后继没有左孩子，它的前驱没有右孩子。</p><p>证明：反证法，设结点为$x$，它的前驱为$pre$，那么对于BST的中序遍历序列为 $&lt;\dotsc-pre-x-\dotsc&gt;$ ，假如$pre$存在右孩子$ppret$，那么在中序遍历时，遍历完成$pre$后接着遍历$ppre$，这与之前中序遍历的序列相矛盾。即$x$的前驱$pre$不存在右孩子。同理$x$的后继结点不存在左孩子。</p><hr><p>12.2-6&emsp;考虑一棵二叉搜索树$T$，其关键字互不相同。证明：如果$T$中一个结点$x$的右子树为空，且$x$有一个后继$y$，那么$y$一定是$x$的最底层的祖先，并且左孩子也是$x$的祖先。（注意到，每个结点都是它自己的祖先。）</p><p>证明：<br>&emsp;首先确定$y$是$x$的祖先，如果$y$不是$x$的祖先，设$x,y$的第一个共同祖先为$z$，那么根据BST的性质有，$x &lt; z &lt; y$<strong>（因为x没有右子树，那么y只能存在于z的右子树，而x存在于z的左子树，否则就无法满足y为x后继即 x&lt;y的关系）</strong>，那么$x$的后继不再是$y$，因此假设不成立。$y$为$x$的祖先得证。<br>&emsp;接下来证明$y.left$是$x$的祖先。假设$y.left$不是$x$的祖先，那么$y.right$将是$x$的祖先，意味着$x &gt; y$，矛盾。因此$y.left$是$x$的祖先。<br>&emsp;最后证明$y$是$x$的最底层祖先，同时$y.left$也是$x$的祖先。假设$y$不是$x$的最底层祖先但是$y.left$是$x$的祖先，令$z$表示最底层祖先，$z$一定是$y$的左子树，因此有$z &lt; y$，意味着$z$是$x$的后继，矛盾，假设不成立。</p><hr><p>12.2-7&emsp;对于一棵有$n$个结点的二叉搜索树，有另一个方法实现中序遍历，先调用TREE-MINUMUM找到这棵树中的最小元素，然后再调用n-1次的TREE-SUCCESSOR。证明：该算法的时间复杂度为$\Theta(n)$。</p><p>证明：我们要想证明这个边界，其实不难实现，可以通过再TREE-MINIMUM和TREE-SUCCESSOR中统计访问边的次数，对于BST是树，因此满足<code>边的次数=顶点数-1</code>。不难发现每条边访问次数不超过两次，同时每个顶点需要访问依次，因此时间复杂度为$\Theta(n)$</p><p>下面证明对于每一条边最多访问两次：一次从下降（从高到低），一次上升（从低到高）</p><p>考虑在树中的一个点$u$,还有它的孩子$v$。我们需要先访问从$(u,v)$，才能访问$(v,u)$。对于下降，只有出现在TREE-MINIMUM，对于上升，只有出现在TREE-SUCCRSSOR并且该结点没有右孩子。</p><p>假设$v$是$u$的左孩子</p><p>   在打印$u$之前，我们需要打印$u$的左子树，保证下降的遍历边$(u,v)$<br>   $v$为根的左子树遍历完成后，打印$u$。从$v$为根的左子树的最大结点,调用TREE-SUCCESSOR中，上升遍历边(u,v)。当$u$的左子树遍历完成后，边$(u,v)$不再访问。</p><p>假设$v$是$u$的右孩子</p><p>   当$u$打印后，TREE-SUCCESSOR(u)被调用，为了访问$v$为根的右子树的最小元素，需要下降的遍历边$(u,v)$。</p><p>   当$u$的右子树遍历完成后，$v$为根的右子树的最大结点，调用的TREE-SUCCRSSOR，上升遍历边$(u,v)$。当$u$的右子树遍历完成后，边$(u,v)$不再访问。</p><p>因此，每条边访问次数不会超过2次。时间复杂度为$\Theta(n)$</p><hr><p>12.2-8&emsp;证明：在一棵高度为$h$的二叉搜索树中，不论从哪个结点开始，$k$次连续的TREE-SUCCESSOR调用所需时间为$\Theta(k+h)$。</p><p>我们记调用TREE-SUCCESSOR的结点为$x$，令$y$为$x$的第$k$个后继结点,$z$为$x,y$的最底层公共祖先。连续调用TREE-SUCCESSOR类似树的遍历，每条边的遍历次数不超过2次，所以我们不会检查一个结点超过3次。另外，任何结点关键字不是在$x,y$之间最多检查一次，发生在一条从$<x-\dotsc-\dotsc z>$或$<y-\dotsc-\dotsc -z>$ (路径)。这些路径的长度由$y$限制,因此最坏情况时间复杂度为$3k+2h=O(k+h)$。</y-\dotsc-\dotsc></x-\dotsc-\dotsc></p><hr><p>12.2-9&emsp;设$T$是一颗二叉搜索树，其关键字互不相同；设$x$是一个叶结点，$y$为其父结点。证明：$y.key$或者$T$树中大于$x.key$的最小关键字，或者是$T$树中小于$x.key$的最大关键字。</p><p>证明：假设$x$是$y$的左孩子，那么$x$的后继是$y$，即$y.key$是$T$树种大于$x.key$的最小关键字，若$x$是$y$的右孩子，那么$y$的前驱是$x$，即$y.key$是$T$树小于$x.key$的最大关键字。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;12.2-1&amp;emsp;假设一棵二叉搜索树中的结点在1到1000之间，现在想要查找值为363得到结点，下面序列那个不是查找过的序列。&lt;/p&gt;
&lt;p&gt;a. $2,252,401,398,330,344,397,363$。&lt;br&gt;b. $924,220,911,244,898,
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="二叉搜索树" scheme="http://007havegone.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法导论练习12.1</title>
    <link href="http://007havegone.github.io/2019/08/08/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%BB%83%E4%B9%A012-1/"/>
    <id>http://007havegone.github.io/2019/08/08/算法导论练习12-1/</id>
    <published>2019-08-08T15:54:03.000Z</published>
    <updated>2019-08-09T02:46:16.411Z</updated>
    
    <content type="html"><![CDATA[<p>12.1-1&emsp;对于关键字集合$\{1,4,5,10,16,17,21\}$，分别画出高度为2、3、4、5和6的二叉搜索树。</p><p><strong>这里说明一下：算法导论中定义的高度是根节点到叶节点的最大距离</strong></p><pre><code>高度为2：      高度为3：                高度为4：    10              10                      5   /  \            /  \                    /  \  4    17         4   16                  4    10 / \   /\        / \   \                 /      \1   5 16 21     1   5   17              1        16                         \                         \                          21                        17                                                     \                                                      21高度为5：           高度为6：    4                       1   / \                       \  1   5                       4       \                       \        10                      5         \                       \          16                      10           \                        \            17                       16             \                         \              21                        17                                           \                                           21</code></pre><hr><p>12.1-2&emsp;二叉搜索树的性质与最小堆性质之间有什么不同？能使用最小堆性质在$O(n)$时间内按序输出一颗n个结点树的关键字吗？可以的话，说明如何做，否则解释理由。</p><p>最小堆是一棵近似的完全二叉树(Perfect Binary Tree),满足堆中每个结点小于等于子结点。但是左右孩子之间的没有确定的大小关系。要想按序输出最小堆，需要使用堆排序的时间复杂度为$\Omega(nlgn)$。</p><hr><p>12.1-3&emsp;设计一个执行中序遍历的非递归算法。（提示：一个容易的方法是使用栈作为辅助数组结构；另一种较复杂但比较简介的做法是不使用栈，但要假设能测试两个指针是否相等）。</p><p>这个问题和算法导论练习10.4-3和10.4-5的题目一致。我在另外一篇博客已经讲过，大家可以看下。<br><a href="https://blog.csdn.net/qq_40512922/article/details/98873841" target="_blank" rel="noopener">算法导论10.4-5题解</a></p><hr><p>12.1-4&emsp;对于一棵有n个结点的树，请设计在$\Theta(n)$时间内完成的先序遍历算法和后序遍历算法。</p><p>下面是我的实现代码，分别给出了先序和后序遍历的递归和非递归实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NIL -1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Tree *left;</span><br><span class="line">Tree *right;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTree</span><span class="params">(Tree *&amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; key;</span><br><span class="line">    <span class="keyword">if</span>(key==NIL)&#123;</span><br><span class="line">        t=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t=<span class="keyword">new</span> Tree();</span><br><span class="line">    t-&gt;key=key;</span><br><span class="line">    createTree(t-&gt;left);</span><br><span class="line">    createTree(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Tree* x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x-&gt;key &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder_recursion</span><span class="params">(Tree* x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        preOrder_recursion(x-&gt;left);</span><br><span class="line">        preOrder_recursion(x-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder_byStack</span><span class="params">(Tree *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Tree*&gt; sta;</span><br><span class="line">    Tree *p=x;</span><br><span class="line">    <span class="keyword">while</span>(p||!sta.empty())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        print(p);</span><br><span class="line">        sta.push(p);</span><br><span class="line">        p=p-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    p=sta.top();</span><br><span class="line">    sta.pop();</span><br><span class="line">    p=p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder_recursion</span><span class="params">(Tree *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        postOrder_recursion(x-&gt;left);</span><br><span class="line">        postOrder_recursion(x-&gt;right);</span><br><span class="line">        print(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder_byStack</span><span class="params">(Tree *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree *pre=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Tree*&gt; sta;</span><br><span class="line">    <span class="keyword">while</span>(x||!sta.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(x)<span class="comment">//达到左子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            sta.push(x);</span><br><span class="line">            x=x-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        x=sta.top();</span><br><span class="line">        <span class="comment">//没有右子树或右子树已访问</span></span><br><span class="line">        <span class="keyword">if</span>(!x-&gt;right||x-&gt;right==pre)&#123;</span><br><span class="line">            sta.pop();</span><br><span class="line">            print(x);</span><br><span class="line">            pre=x;</span><br><span class="line">            x=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            x=x-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree *head;</span><br><span class="line">    createTree(head);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"先序遍历递归版:\n"</span>;</span><br><span class="line">    preOrder_recursion(head);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n先序遍历非递归版:\n"</span>;</span><br><span class="line">    preOrder_byStack(head);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n后序遍历递归版:\n"</span>;    </span><br><span class="line">    postOrder_recursion(head);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n后序遍历非递归版:\n"</span>;        </span><br><span class="line">    postOrder_byStack(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这有两组测试数据，分别是题目12.1-1高度为2和6的二叉树。</p><p>数据1：<br><code>10 4 1 -1 -1 5 -1 -1 17 16 -1 -1 21 -1 -1</code><br>结果：<br>先序： <code>10 4 1 5 17 16 21</code><br>后序： <code>1 5 4 16 21 17 10</code>  </p><p>数据2：<br><code>1 -1 4 -1 5 -1 10 -1 16 -1 17 -1 21 -1 -1</code><br>结果：<br>先序：<code>1 4 5 10 16 17 21</code><br>后序：<code>21 17 16 10 5 4 1</code></p><hr><p>12.1-5&emsp;因为在基于比较排序模型中，完成n个元素的排序，其最坏情况下需要$\Omega(nlgn)$时间。证明：任何基于比较的算法从n个元素的任意序列中构造一棵二叉搜索树，其最坏情况需要$\Omega(nlgn)$的时间。</p><p>证明：反证法，假设我们我可以在最坏情况$\omicron(nlgn)$下完成BST的建立。那么对于排序来说，我们可以通过构造BST树，然后遍历BST来实现。</p><p>根据<code>定理12.1</code>，我们可以在$\Theta(n)$的时间内完成对BST的遍历。那么意味着我们在$\omicron(nlgn)$的时间内完成对$n$个元素的排序算法。这与Chapter 8的基于比较的排序算法的下界为$\Omega(nlgn)$相矛盾。</p><p>因此，假设不成立。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;12.1-1&amp;emsp;对于关键字集合$\{1,4,5,10,16,17,21\}$，分别画出高度为2、3、4、5和6的二叉搜索树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里说明一下：算法导论中定义的高度是根节点到叶节点的最大距离&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="二叉搜索树" scheme="http://007havegone.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法导论练习10.4-5二叉树遍历</title>
    <link href="http://007havegone.github.io/2019/08/08/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%BB%83%E4%B9%A010.4-5%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    <id>http://007havegone.github.io/2019/08/08/算法导论练习10.4-5二叉树遍历/</id>
    <published>2019-08-08T06:00:03.000Z</published>
    <updated>2019-08-18T08:12:41.152Z</updated>
    
    <content type="html"><![CDATA[<p>10.4-5 给定一个n结点的二叉树，写出一个$O(n)$时间的非递归过程，将该树的每一个结点的关键字输出。要求除该树本身的存储空间外只能使用固定量的额外存储空间，且中过程中不得修改该树，即使是暂时的修改也不允许。</p><p>要完成$O(1))$的空间内遍历该树，需要每个结点需要能访问其父节点进行回溯。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Tree *parent;</span><br><span class="line">    Tree *left;</span><br><span class="line">    Tree *right;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><ol><li>访问左孩子</li><li>访问右孩子</li><li>从左孩子返回，访问根节点，进入右孩子访问</li><li>从右孩子返回，整棵树访问完成，回溯直到为根节点或该结点是父节点的左孩子</li></ol><p>下面是测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NIL -1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Tree* left;</span><br><span class="line">    Tree* right;</span><br><span class="line">    Tree* parent;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    Tree():left(<span class="literal">nullptr</span>),right(<span class="literal">nullptr</span>),parent(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Tree* t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t-&gt;key &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTree</span><span class="params">(Tree *&amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; key;</span><br><span class="line">    <span class="keyword">if</span>(key==NIL)&#123;</span><br><span class="line">        t=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t=<span class="keyword">new</span> Tree();</span><br><span class="line">    t-&gt;key=key;</span><br><span class="line">    createTree(t-&gt;left);</span><br><span class="line">    createTree(t-&gt;right);</span><br><span class="line">    <span class="comment">//存在子结点，更细父指针</span></span><br><span class="line">    <span class="keyword">if</span>(t-&gt;left)</span><br><span class="line">        t-&gt;left-&gt;parent=t;</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;right)</span><br><span class="line">        t-&gt;right-&gt;parent=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder_travel</span><span class="params">(Tree *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(h)</span><br><span class="line">    &#123;</span><br><span class="line">        inorder_travel(h-&gt;left);</span><br><span class="line">        print(h);</span><br><span class="line">        norder_travel(h-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用stack非递归版本，结点不需要parent指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder_byStack</span><span class="params">(Tree*h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Tree*&gt; sta;</span><br><span class="line">    Tree *p=h;</span><br><span class="line">    <span class="keyword">while</span>(p || !sta.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            sta.push(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p=sta.top();sta.pop();</span><br><span class="line">        print(p);</span><br><span class="line">        p=p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有使用栈的版本，通过h和pre之间的关系进行遍历。</span></span><br><span class="line"><span class="comment">// 回溯需要parent指针。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder_noStack</span><span class="params">(Tree* h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!h)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//pre作为前驱，判断从左孩子还是右孩子返回</span></span><br><span class="line">    Tree* pre=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//找到左结点</span></span><br><span class="line">        <span class="keyword">if</span>(pre!=h-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(h-&gt;left)</span><br><span class="line">                h=h-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        print(h);</span><br><span class="line">        <span class="comment">//存在右结点则进入</span></span><br><span class="line">        <span class="keyword">if</span>(h-&gt;right)&#123;</span><br><span class="line">            h=h-&gt;right;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右孩子返回时，回溯直到根结点的父节点或是父节点的左孩子</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            pre=h;</span><br><span class="line">            h=h-&gt;parent;</span><br><span class="line">            <span class="keyword">if</span>(h==<span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(pre==h-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree* head;</span><br><span class="line">    createTree(head);</span><br><span class="line">    inorder_travel(head);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    inorder_byStack(head);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    inorder_noStack(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试数据:<br>    1 2 4 7 -1 -1 -1 5 8 -1 -1 -1 3 6 -1 9 -1 -1 -1</p><p>树的形状是：<br><img src="/2019/08/08/算法导论练习10.4-5二叉树遍历/二叉树.jpg" alt></p><p>中序遍历结果：<br>    7 4 2 8 5 1 6 9 3</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;10.4-5 给定一个n结点的二叉树，写出一个$O(n)$时间的非递归过程，将该树的每一个结点的关键字输出。要求除该树本身的存储空间外只能使用固定量的额外存储空间，且中过程中不得修改该树，即使是暂时的修改也不允许。&lt;/p&gt;
&lt;p&gt;要完成$O(1))$的空间内遍历该树，需要每
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="二叉树" scheme="http://007havegone.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="中序遍历" scheme="http://007havegone.github.io/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>Win10中shift+鼠标右键调出cmd窗口</title>
    <link href="http://007havegone.github.io/2019/08/07/Win10%E4%B8%ADshift-%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE%E8%B0%83%E5%87%BAcmd%E7%AA%97%E5%8F%A3/"/>
    <id>http://007havegone.github.io/2019/08/07/Win10中shift-鼠标右键调出cmd窗口/</id>
    <published>2019-08-07T08:06:33.000Z</published>
    <updated>2019-08-07T09:57:56.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Win10中shift-鼠标右键调出cmd窗口"><a href="#Win10中shift-鼠标右键调出cmd窗口" class="headerlink" title="Win10中shift+鼠标右键调出cmd窗口"></a>Win10中shift+鼠标右键调出cmd窗口</h1><p>最近Win10系统更新，更新后发现之前按shift+鼠标右键时，菜单栏里面的cmd选项不见了，取而代之的是 Powershell窗口。用习惯了了cmd还是有点不习惯powershell。</p><p>下面是我Win10更新后shift+鼠标右键的选项栏的效果：</p><p><img src="/2019/08/07/Win10中shift-鼠标右键调出cmd窗口/无cmd.jpg" alt></p><p>&emsp;这里不做cmd和powershell的比较。简单来说powershell像是cmd的一个超集，不仅仅支持cmd的命令，还额外支持.net命令，也支持部分常用的Linux命令。powershell的字体颜色比cmd丰富点。但是相应的powershell所占用的资源更多，有时候我在powershell运行命令可以感觉到明显的延迟感。（可能电脑开的进程比较多）不过cmd较少遇到这种情况。</p><h2 id="1、在shift-鼠标右键中添加cmd。"><a href="#1、在shift-鼠标右键中添加cmd。" class="headerlink" title="1、在shift+鼠标右键中添加cmd。"></a>1、在shift+鼠标右键中添加cmd。</h2><p>用到的工具是注册表。</p><ol><li>按 <code>Win + R</code> 或 <code>鼠标右键window</code> 打开运行窗口</li></ol><p><img src="/2019/08/07/Win10中shift-鼠标右键调出cmd窗口/运行窗口.jpg" alt></p><ol><li>输入 <code>regedit</code> 调出注册表</li></ol><p><img src="/2019/08/07/Win10中shift-鼠标右键调出cmd窗口/注册表.jpg" alt></p><ol><li>在注册表中定位到：<code>\HKEY_CLASSES_ROOT\Directory\Background\shell\cmd</code>，将右侧的<code>HideBasedOnVelocityId</code>重命名为<code>ShowBasedOnVelocityId</code>即可。</li></ol><p><img src="/2019/08/07/Win10中shift-鼠标右键调出cmd窗口/改名.jpg" alt></p><ol><li>同样的，如果想要关闭右键powershell，只要修改定位到：<code>\HKEY_CLASSES_ROOT\Directory\Background\shell\Powershell</code>,将右侧的<code>ShowBasedOnVelocityId</code>重命名为<code>HideBasedOnVelocityId</code>即可。</li></ol><hr><p><strong>注意事项：</strong> 修改的过程中可能会遇到权限不足的情况，无法进行编辑。</p><h2 id="2、权限修改"><a href="#2、权限修改" class="headerlink" title="2、权限修改"></a>2、权限修改</h2><ol><li>这时候右键cmd文件夹或powershell文件夹选择权限项。</li></ol><p><img src="/2019/08/07/Win10中shift-鼠标右键调出cmd窗口/右键权限.jpg" alt></p><ol><li>在权限面板中：<code>组或用户名</code>一栏选择自己的用户，在下边的<code>Users的权限控制</code>选择上<code>完全控制</code>。然后点击下面的<code>高级</code>。</li></ol><p><img src="/2019/08/07/Win10中shift-鼠标右键调出cmd窗口/权限.jpg" alt></p><ol><li>在高级面板中：点击顶部的<code>更改所有者</code>，<code>输入要选择的对象名称</code>处输入当前账号名称，譬如输入xxx，再点<code>检查名称</code>并确定。回到上级菜单后继续确定即可。</li></ol><p><img src="/2019/08/07/Win10中shift-鼠标右键调出cmd窗口/更改所有者.jpg" alt></p><ol><li>然后再修改注册表名即可。</li></ol><hr><h2 id="3、最终效果："><a href="#3、最终效果：" class="headerlink" title="3、最终效果："></a>3、最终效果：</h2><p><img src="/2019/08/07/Win10中shift-鼠标右键调出cmd窗口/修改后效果.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Win10中shift-鼠标右键调出cmd窗口&quot;&gt;&lt;a href=&quot;#Win10中shift-鼠标右键调出cmd窗口&quot; class=&quot;headerlink&quot; title=&quot;Win10中shift+鼠标右键调出cmd窗口&quot;&gt;&lt;/a&gt;Win10中shift+鼠标右键调
      
    
    </summary>
    
      <category term="操作系统" scheme="http://007havegone.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://007havegone.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Win10" scheme="http://007havegone.github.io/tags/Win10/"/>
    
      <category term="cmd" scheme="http://007havegone.github.io/tags/cmd/"/>
    
  </entry>
  
  <entry>
    <title>算法导论思考题9-2</title>
    <link href="http://007havegone.github.io/2019/08/02/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E6%80%9D%E8%80%83%E9%A2%989-2/"/>
    <id>http://007havegone.github.io/2019/08/02/算法导论思考题9-2/</id>
    <published>2019-08-01T16:13:03.000Z</published>
    <updated>2019-08-03T09:38:55.804Z</updated>
    
    <content type="html"><![CDATA[<h3 id="9-2-emsp-带权中位数-对分别具体以正权重-w-1-w-2-dotsb-w-n-且满足-sum-i-1-n-w-i-1-的-n-个互异的元素-x-1-x-2-dotsb-x-n-来说，带权中位数-x-k-较小中位数-是满足如下条件的元素："><a href="#9-2-emsp-带权中位数-对分别具体以正权重-w-1-w-2-dotsb-w-n-且满足-sum-i-1-n-w-i-1-的-n-个互异的元素-x-1-x-2-dotsb-x-n-来说，带权中位数-x-k-较小中位数-是满足如下条件的元素：" class="headerlink" title="9-2&emsp;(带权中位数)对分别具体以正权重$w_1,w_2,\dotsb,w_n$,且满足$\sum_{i=1}^{n}{w_i=1}$的$n$个互异的元素$x_1,x_2,\dotsb,x_n$来说，带权中位数$x_k$(较小中位数)是满足如下条件的元素："></a>9-2&emsp;(带权中位数)对分别具体以正权重$w_1,w_2,\dotsb,w_n$,且满足$\sum_{i=1}^{n}{w_i=1}$的$n$个互异的元素$x_1,x_2,\dotsb,x_n$来说，带权中位数$x_k$(较小中位数)是满足如下条件的元素：</h3><script type="math/tex; mode=display">\sum_{x_i < x_k}w_i <\frac{1}{2} \quad和\quad\sum_{x_i > x_k}w_i \leq \frac{1}{2}</script><p>例如，如果元素是$0.1  ,0.35  ,0.05  ,0.1  ,0.15  ,0.05  ,0.2$，并且每个元素的权重等于本身(即对所有$i=1,2,\dotsb,7都有w_i=x_i$)，那么中位数是0.1，而带全中位数是0.2。</p><h3 id="a-emsp-证明：如果对所有-i-1-2-dotsb-n-都有-w-i-1-n-，那么-x-1-x-2-dotsb-x-n-的中位数就是-x-i-的带权中位数。"><a href="#a-emsp-证明：如果对所有-i-1-2-dotsb-n-都有-w-i-1-n-，那么-x-1-x-2-dotsb-x-n-的中位数就是-x-i-的带权中位数。" class="headerlink" title="a.&emsp; 证明：如果对所有$i=1,2,\dotsb,n$都有$w_i=1/n$，那么$x_1,x_2,\dotsb,x_n$的中位数就是$x_i$的带权中位数。"></a>a.&emsp; 证明：如果对所有$i=1,2,\dotsb,n$都有$w_i=1/n$，那么$x_1,x_2,\dotsb,x_n$的中位数就是$x_i$的带权中位数。</h3><p>证明：$x_i,x_2,\dotsb,n$的中位数（<strong>题目给的是低中位数</strong>）是$x_k=x$那么就有：</p><script type="math/tex; mode=display">\begin{aligned}    |\{x_i| 1 \leq i \leq n,x_i < x\}| &< n/2 \\    |\{x_i| 1 \leq i \leq n,x_i > x\}| &\leq n/2\end{aligned}</script><p>这里解释下:</p><p>第1个式子是小于中位数的个数，因为是低中位数，无论集合是奇数偶数个都是小于$n/2$；</p><p>第2个式子是大于中位数的个数，当集合个数是奇数是，也是小于$n/2$，当集合个数为偶数时，等号成立。</p><p>同时因为每一个元素的权值都是置为$1/n$，那么就有：</p><script type="math/tex; mode=display">\begin{aligned}    \sum_{x_i<x}{w_i} &= \sum_{x_i<x}{\frac{1}{n}}  \\                      &= \frac{1}{n}·\sum_{x_i<x}1  \\                      &= \frac{1}{n}·|\{x_i| 1 \leq i \leq n,x_i <x\}|  \\                      &< \frac{1}{n} · \frac{n}{2}  \\                      &= \frac{1}{2}\end{aligned}</script><p>满足带权中位数的第一个条件。同理，我们有：</p><script type="math/tex; mode=display">\begin{aligned}    \sum_{x_i>x}{w_i} &= \sum_{x_i>x}{\frac{1}{n}}  \\                      &= \frac{1}{n}·\sum_{x_i>x}1  \\                      &= \frac{1}{n}·|\{x_i| 1 \leq i \leq n,x_i > x\}| \\                      &\leq \frac{1}{n}·\frac{n}{2} \\                      &=\frac{1}{2}\end{aligned}</script><p>第二个条件得证。因此当集合X的每个元素的权重都是$1/n$时，$x_1,x_2,\dotsb,x_n$的中位数$x_k=x$，同时也是带权中位数。</p><hr><h3 id="b-emsp-利用排序，设计一个最坏情况下-O-nlgn-时间的算法，可以得到-n-个元素的带权中位数。"><a href="#b-emsp-利用排序，设计一个最坏情况下-O-nlgn-时间的算法，可以得到-n-个元素的带权中位数。" class="headerlink" title="b.&emsp; 利用排序，设计一个最坏情况下$O(nlgn)$时间的算法，可以得到$n$个元素的带权中位数。"></a>b.&emsp; 利用排序，设计一个最坏情况下$O(nlgn)$时间的算法，可以得到$n$个元素的带权中位数。</h3><p><strong>Step1</strong>、可以对元素$x_1,x_2,\dotsb,x_n$采用归并排序或者堆排序算法来升序排序。</p><p><strong>Step2</strong>、然后从最小$x_1$开始，从左往右遍历每一个，将权值累加起来，当权值超过$1/2$，那么最后一个导致超过$1/2$的元素就是带权中位数。</p><p>Step1时间复杂度为$O(nlgn)$，Step2时间复杂度为$O(n)$。满足题目要求。</p><hr><h3 id="c-emsp-说明如何利用像9-3节的SELECT这样的线性时间中位数算法，在-Theta-n-最坏情况时间内求出带权中位数。"><a href="#c-emsp-说明如何利用像9-3节的SELECT这样的线性时间中位数算法，在-Theta-n-最坏情况时间内求出带权中位数。" class="headerlink" title="c.&emsp;说明如何利用像9.3节的SELECT这样的线性时间中位数算法，在$\Theta(n)$最坏情况时间内求出带权中位数。"></a>c.&emsp;说明如何利用像9.3节的SELECT这样的线性时间中位数算法，在$\Theta(n)$最坏情况时间内求出带权中位数。</h3><p>线性时间查找带权中位数的思想是二分查找。算法工作流程如下:</p><p>1、问题规模$n \leq 2$，可以在$O(1)$情况下暴力解决。</p><p>2、问题规模$n &gt; 2$时，我们先找到集合$X$的中位数$x_k =x$，将集合$X$用$x_k$划分为两个集合，下面称为$L=\{x_i|1 \leq i \leq n,x_i &lt; x\}$和$G=\{x_i|1 \leq i \leq n,x_i &gt;x\}$,然后计算$W_L$和$W_G$（两部分的权重）。根据$W_G$和$W_G$的权重情况，可以分为3种情况处理：</p><script type="math/tex; mode=display">\begin{cases}   a、 x_k即为带权中位数 &    W_L < 1/2 \ and \ W_G <1/2   \\   b、 在集合L中查找     &          W_L>1/2             \\   c、 在集合G中查找     &          W_G>1/2   \end{cases}</script><p>在处理b、c情况时，我们为了避免下一次划分时重复计算$W_L$和$W_G$，对于情况b：我们可以将$w_k=w_k+W_G$，然后将$x_k$加入下一步要进行查找的集合$L$中。</p><p>下面时该算法的伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">WEIGHTED-MEDIUM(X)</span><br><span class="line">    <span class="comment">//规模小于等于2，O(1)解决</span></span><br><span class="line">    <span class="keyword">if</span> X.size = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x[<span class="number">1</span>]</span><br><span class="line">    elseif x.size = <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> w[<span class="number">1</span>]&gt;=w[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">return</span> x1</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> x2</span><br><span class="line">    <span class="comment">//规模 &gt;2，取中位数，二分递归进行</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        find the Medium x[k] in X[<span class="number">1</span>,..,n]</span><br><span class="line">        partition the <span class="built_in">set</span> X by x[k] into L,G</span><br><span class="line">        computer WL=sum of w[i] in the <span class="built_in">set</span> L</span><br><span class="line">                 WG=sum of w[i] in the <span class="built_in">set</span> G</span><br><span class="line">        <span class="keyword">if</span> WL&lt;<span class="number">1</span>/<span class="number">2</span> <span class="keyword">and</span> WG &lt; <span class="number">1</span>/<span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> x[k]</span><br><span class="line">        elseif WL &gt; <span class="number">1</span>/<span class="number">2</span></span><br><span class="line">            w[k]=w[k]+WG</span><br><span class="line">            X'&lt;--&#123;x[i] in X | x[i] &lt;= x[k]&#125;</span><br><span class="line">            <span class="keyword">return</span> WEIGHT-MEDIUM(X')</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            w[k]=w[k]+WL</span><br><span class="line">            X'&lt;--&#123;x[i] in X | x[i] &gt;= x[k]&#125;</span><br><span class="line">            <span class="keyword">return</span> WEIGHTED-MEDIUM(X')</span><br></pre></td></tr></table></figure><p><strong>算法分析</strong>：在对数组的每一次递归过程中，取中位数$x_k$，划分集合X和计算$W_L,W_R$的时间复杂度均为$O(n)$。最差情况下满足以下递归式：</p><script type="math/tex; mode=display">    T(n)=T(n/2+1)+\Theta(n)</script><p>下一次递归，划分的集合是原来的一半元素，同时还有$x_k$，因此为$T(2n+1)$。<br>这个递归式和快速选择(线性选择算法)的递推式接近，该算法的时间复杂度$T(n)=\Theta(n)$。</p><hr><p><strong>邮局位置问题</strong>的定义如下，给定权重分别为$w_1,w_2,\dotsb,w_n$的$n$个点$p_1,p_2,\dotsb,p_n$，我们希望找到一个点$p$(不一定是输入点中的一个)，使得$\sum_{i=1}^{n}{w_id(p,p_i)}$最小，这里$d(a,b)$表示点$a$和$b$之间的距离。</p><h3 id="d-emsp-证明：对一维邮局位置问题，带权中位数是最好的解决方法，其中，每个点都是一个实数，点-a-和-b-之间的距离是-d-a-b-a-b-。"><a href="#d-emsp-证明：对一维邮局位置问题，带权中位数是最好的解决方法，其中，每个点都是一个实数，点-a-和-b-之间的距离是-d-a-b-a-b-。" class="headerlink" title="d.&emsp;证明：对一维邮局位置问题，带权中位数是最好的解决方法，其中，每个点都是一个实数，点$a$和$b$之间的距离是$d(a,b)=|a-b|$。"></a>d.&emsp;证明：对一维邮局位置问题，带权中位数是最好的解决方法，其中，每个点都是一个实数，点$a$和$b$之间的距离是$d(a,b)=|a-b|$。</h3><p>&emsp;采用$x_1,x_2,\dotsb,x_n$表示$n$个点的坐标，每个点相应的权值为$w_1,w_2,\dotsb,w_n$，令$x=x_k$为带权中位数。</p><p>&emsp;对于任意点$p$，我们设函数$f(p)=\sum_{i=1}^n{w_i|p-x_i|}$，我们需要找出令该函数最小值的点。令$y$是除$x$外的任意点，我们通过证明$f(y)-f(x) \geq 0$来检验带权中位数$x$是最优解。我们可以分为下面两种情况来讨论：$y &gt; x$和 $x &gt; y$。对于$\forall  x,y$有：</p><script type="math/tex; mode=display">\begin{aligned}    f(y)-f(x) &=\sum_{i=1}^{n}{w_i|y-x_i|} -\sum_{i=1}^{n}{w_i |x-x_i|}    \\              &=\sum_{i=1}^{n}{w_i(|y-x_i|-|x-x_i|)}\end{aligned}</script><p>1、 当$y&gt;x$时，对于上面式子中的$|y-x_i|-|x-x_i|$可以分为三种情况：</p><p>&emsp;1.1、$x &lt; y \leq x_i$</p><script type="math/tex; mode=display">\frac{|y-x|+|y-x_i|=|x-x_i| \quad AND \quad |y-x|=y-x}{\to |y-x_i|-|x-x_i|=-|y-x|=x-y}</script><p>&emsp;1.2、$x &lt; x_i \leq y$</p><script type="math/tex; mode=display">\frac{|y-x_i| \geq 0 \quad AND \quad |x-x_i| \leq y-x}{\to |y-x_i|-|x-x_i| \geq -(y-x) = x-y}</script><p>&emsp;1.3、$x_i \leq x &lt; y$，类似1.1</p><script type="math/tex; mode=display">\frac{|x-x_i|+|y-x|=|y-x_i| \quad AND \quad |y-x|=y-x}{\to |y-x_i|-|x-x_i|=|y-x|=y-x}</script><p>解释一下上面这么写的原因，如：1.1，$d(x,x_i)==d(x,y)+d(y,x_i)$，绝对值内的减法理解为距离计算，配凑出与我们要求的式子，进行等价转换，后面方便处理。</p><p><strong>其实对于1.1和1.3我们简单根据正负情况消去绝对值符号也行。</strong></p><p>&emsp;将前两种情况($x &lt; x_i$)与第三种情况分开($x_i \leq x$)。。我们有：</p><script type="math/tex; mode=display">\begin{aligned}    f(y)-f(x) &= \sum_{i=1}^{n}{w_i(|y-x_i|-|x-x_i|)}   \\              &\geq \sum_{x<x_i}{w_i(x-y)}+\sum_{x \geq x_i}{w_i(y-x)}  \\              &= (y-x)\left(\sum_{x \geq x_i}{w_i}-\sum_{x < x_i}{w_i}\right)\end{aligned}</script><p>结合$x_k$的性质，我们有：</p><script type="math/tex; mode=display">\begin{aligned}    \sum_{x_i < x}{w_i} <1/2 \quad    \underrightarrow{implies} & \sum_{x_i \leq x}{w_i} \geq 1/2    \\    和 \sum_{x_i>x}{w_i} &\leq 1/2  \\    \therefore \sum_{x \geq x_i}{w_i}-\sum_{x < x_i}{w_i} &\geq 0\end{aligned}</script><p>又$\because y-x &gt;0$，$\therefore f(y)-f(x) \geq 0$</p><p>2、当$x &gt; y$时，我们同样将$|y-x_i|-|x-x_i|$分为下面三种情况：</p><p>&emsp;2.1、$x_i \leq y &lt; x$</p><script type="math/tex; mode=display">\frac{|y - x_i|+|x - y|=|x-x_i|\quad AND \quad |x-y|=x-y}{\to |y-x_i|-|x-x_i|=-|x-y|=y-x}</script><p>&emsp;2.2、$y \leq x_i &lt; x$</p><script type="math/tex; mode=display">\frac{|y-x_i \geq 0| \quad AND \quad |x_-x_i| \leq x-y}{\to |y-x_i|-|x-x_i| \geq -(x-y)=y-x}</script><p>&emsp;2.3、$y &lt; x \leq x_i$,类似情况1</p><script type="math/tex; mode=display">\frac{|x-y|+|x-x_i|=|y-x_i| AND |x-y|=x-y}{\to |y-x_i|-|x-x_i|=|x-y|=x-y}</script><p>&emsp;和之前处理一样，分为前两种情况为$x_i &lt; x$，第三种情况为$x \leq x_i$，我们有：</p><script type="math/tex; mode=display">\begin{aligned}   f(y)-f(x) &=\sum_{i=1}^{n}{w_i(|y-x_i|-|x-x_i|)}   \\             &\geq \sum_{x_i<x}{w_i(y-x)} +\sum_{x\leq x_i}{w_i(x-y)}   \\             &=(y-x)\left(\sum_{x_i<x}{w_i}-\sum_{x \leq x_i}{w_i} \right)\\\end{aligned}</script><p>同上，$\because x$是带权中位数，有:</p><script type="math/tex; mode=display">\begin{aligned}    \sum_{x_i < x}{w_i} &< 1/2  \\     和 \sum_{x_i >x}{w_i} \leq 1/2 \quad &\underrightarrow{implies}     \sum_{x_i \geq x}{w_i} > 1/2    \\    \therefore \sum_{x_i < x}{w_i}-\sum_{x \leq x_i}{w_i} &>0\end{aligned}</script><p>又 $\because y-x&gt;0 \therefore f(y)-f(x)&gt;0$。</p><p>综上：</p><script type="math/tex; mode=display">f(y)-f(x)\begin{cases}    \geq 0 & y > x\\      >  0 & x > y\end{cases}</script><p>因此，带权中位数$x=x_k$是一维邮局问题的最优解,得证。</p><hr><h3 id="e-emsp-请给出二位邮局位置问题的最好解决方法：其中的点是-x-y-的二位坐标形式，点-a-x-1-y-1-与-b-x-2-y-2-之间的距离是-Manhattan-距离-曼哈顿距离-出租车距离-街区距离-，即-d-a-b-x-1-x-2-y-1-y-2"><a href="#e-emsp-请给出二位邮局位置问题的最好解决方法：其中的点是-x-y-的二位坐标形式，点-a-x-1-y-1-与-b-x-2-y-2-之间的距离是-Manhattan-距离-曼哈顿距离-出租车距离-街区距离-，即-d-a-b-x-1-x-2-y-1-y-2" class="headerlink" title="e.&emsp;请给出二位邮局位置问题的最好解决方法：其中的点是$(x,y)$的二位坐标形式，点$a=(x_1,y_1)$与$b=(x_2,y_2)$之间的距离是$Manhattan$距离(曼哈顿距离/出租车距离/街区距离)，即$d(a,b)=|x_1-x_2|+|y_1-y_2|$"></a>e.&emsp;请给出二位邮局位置问题的最好解决方法：其中的点是$(x,y)$的二位坐标形式，点$a=(x_1,y_1)$与$b=(x_2,y_2)$之间的距离是$Manhattan$距离(曼哈顿距离/出租车距离/街区距离)，即$d(a,b)=|x_1-x_2|+|y_1-y_2|$</h3><p>&emsp;我们采用一对坐标来表示每个点$p_i=(x_i,y_i)$，同时每个点相应的权值为$w_i$。因此，我们的目标转变为找到一个点$p=(x,y)$使下面的函数达到最小值：</p><script type="math/tex; mode=display">f(x,y)=\sum_{i=1}^{n}{w_i(|x-x_i|+|y-y_i|)}</script><p>&emsp;我们可以将函数$f(x,y)$转变为两个等价的一元函数相加:</p><script type="math/tex; mode=display">\begin{aligned}    f(x,y)&=g(x)+h(y)\\     其中，g(x) &=\sum_{i=1}^{n}{w_i|x-x_i|}  \\     h(y) &=\sum_{i=1}^{n}{w_i|y-y_i|}\end{aligned}</script><p>我们要使$f(x,y)$取得最小值，可以单独的对每一维度进行处理，因为$g(x)$不依赖于变量$y，h(y)$不依赖于变量$x$。因此：</p><script type="math/tex; mode=display">\begin{aligned}    \min_{x,y}{f(x,y)} &= \min_{x,y}{(g(x)+h(y))}   \\                       &= \min_{x} \left(\min_{y}(g(x)+h(y))\right) \\                       &= \min_{x} \left(g(x)+ \min_{y}h(y) \right) \\                       &= \min_{x}g(x)+\min_{y}h(y)\end{aligned}</script><p>&emsp;原先的二维问题，现在问题就转变为求2个一维最优解问题。和我们上面问题$d$一样，因此，我们只要分别求$x、y$维度上的带权中位数，设为$x_k,y_k$。最终答案记为$(x_k,y_k)$。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;9-2-emsp-带权中位数-对分别具体以正权重-w-1-w-2-dotsb-w-n-且满足-sum-i-1-n-w-i-1-的-n-个互异的元素-x-1-x-2-dotsb-x-n-来说，带权中位数-x-k-较小中位数-是满足如下条件的元素：&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="中位数" scheme="http://007havegone.github.io/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>算法导论练习9.3-8两个有序数组的中位数</title>
    <link href="http://007havegone.github.io/2019/08/01/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%BB%83%E4%B9%A09-3-8%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://007havegone.github.io/2019/08/01/算法导论练习9-3-8两个有序数组的中位数/</id>
    <published>2019-08-01T10:16:30.000Z</published>
    <updated>2019-08-18T13:36:55.403Z</updated>
    
    <content type="html"><![CDATA[<h3 id="9-3-8-emsp-设X-1-n-和Y-1-n-为两个数组，每个都包含n个有序的元素，请设计一个-O-lgn-时间的算法找出数组X和Y中所有2n个元素的中位数。"><a href="#9-3-8-emsp-设X-1-n-和Y-1-n-为两个数组，每个都包含n个有序的元素，请设计一个-O-lgn-时间的算法找出数组X和Y中所有2n个元素的中位数。" class="headerlink" title="9.3-8&emsp;设X[1..n]和Y[1..n]为两个数组，每个都包含n个有序的元素，请设计一个$O(lgn)$时间的算法找出数组X和Y中所有2n个元素的中位数。"></a>9.3-8&emsp;设X[1..n]和Y[1..n]为两个数组，每个都包含n个有序的元素，请设计一个$O(lgn)$时间的算法找出数组X和Y中所有2n个元素的中位数。</h3><p><strong>下面假设中位数(低中位数，数组长度偶数时较小的那个)在数组$X$中。如果要求中间两个数的均值，只需要在该基础之上修改一点就好。</strong></p><p>a、$X[k]=m$为中位数，对于数组$X$,有$k$个元素小于等于$X[k]$，同时有$n-k$个元素大于等于$X[k]$。当两个数组合并有序时，对于中位数来说，共有$n$个元素小于等于$X[k]$，n个元素大于等于$X[k]$。那么对于数组$Y$来说，有$n-k$个元素小于等于$X[k]$，$n-(n-k)=k$个元素大于等于$X[k]$。那么就存在以下不等式：</p><script type="math/tex; mode=display">Y[n-k] \leq X[k] \leq Y[n-k+1],1 \leq k < n</script><p>b、$若X[k]$不是中位数。且中位数为$X[k’] \,(1 \leq k’ &lt; k &lt; n)$，那么就有：</p><script type="math/tex; mode=display">Y[n-k'] \leq X[k'] \leq Y[n-k'+1]</script><p>那么对于$X[k]$来说，有：</p><script type="math/tex; mode=display">\begin{aligned}  Y[n-k+1] &\leq Y[n-k'] \leq X[k'] < X[k] \\               Y[n-k+1] &< X[k]  \end{aligned}</script><p>c、$若X[k]$不是中位数。且中位数为$X[k’]  (1 \leq k &lt; k’ &lt; n)$，那么就有：</p><script type="math/tex; mode=display">Y[n-k'] \leq X[k'] \leq Y[n-k'+1]</script><p>那么对于$X[k]$来说，有：</p><script type="math/tex; mode=display">\begin{aligned}    X[k] &< X[k'] \leq Y[n-k'+1] \leq Y[n-k] \\                X[k] &< Y[n-k]\end{aligned}</script><p>d、在递归的过程中，我们要注意一个递归的一个边界问题，在实际的编程中，对于数组$A[L,..R]，1 \leq L \leq R \leq n$。我们取$k=(L+R)/2,k \in [1,n]$, 当$k=n$时，那么对于上面三种情况会出现$Y[n-k]=Y[0]$是一个空数组，对于这种情况，其实只需判断$X[k]=X[n] \leq Y[1]$。</p><p>利用上面的性质，就可以在$O(1)$的时间内判断$X[k]$是否时中位数。对于一个数组区间$X[L,R]$。我们采用二分的思想，取中点$k=(L+R)/2$，判断上面的条件，如果满足条件a或d，那么$X[k]$就是中位数，如果是条件b，那么说明$k$偏大，我们在左子区间继续二分查找，否则为条件c，我们在右子区间继续二分查找。这样的一个二分查找过程的时间复杂度为$\Theta(lgn)$。</p><p>上面给出性质的是假设中位数在数组$X$的分析，如果中位数不在数组$X$中，在查找的过程中到达边界而不满足$X[k]$为中位数的a条件，我们可以返回一个标志如NOTFIND。此时中位数一定在数组$Y$中，我们进行同样的操作。最差情况下进行$2lgn$次查找。时间复杂度仍为为$\Theta(lgn)$。</p><p>下面是伪代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Two-Array-Medium(X,Y)</span><br><span class="line">n &lt;-- X.length  <span class="comment">//与数组Y长度相同</span></span><br><span class="line">medium = Find-Medium(X,Y,<span class="number">1</span>,n,n)<span class="comment">//先尝试在数组X查找</span></span><br><span class="line"><span class="keyword">if</span> medium = NOTFIND<span class="comment">//未找到，在Y数组查找</span></span><br><span class="line">    medium = Find-Medium(Y,X,<span class="number">1</span>,n,n)</span><br><span class="line"><span class="keyword">return</span> medium</span><br><span class="line"></span><br><span class="line">Find-Medium(A,B,low,high,n)</span><br><span class="line"><span class="keyword">if</span> low &gt; high</span><br><span class="line">    <span class="keyword">return</span> NOTFIND</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    k = (high+low)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> k=n <span class="keyword">and</span> A[n]&lt;=B[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> A[n]</span><br><span class="line">    elseif k &lt; n <span class="keyword">and</span> B[n-k] &lt;= A[k] &lt;= B[n-k+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> A[k]</span><br><span class="line">    elseif B[n-k+<span class="number">1</span>] &lt; A[k]</span><br><span class="line">        <span class="keyword">return</span> Find-Medium(A,B,low,k<span class="number">-1</span>,n)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Find-Medium(A,B,k+<span class="number">1</span>,high,n)</span><br></pre></td></tr></table></figure><p>实际编程中，数组从0开始稍微改动下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTFIND 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数n为数组长度,此时边界为n-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMedium</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> B[],<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&gt;R)</span><br><span class="line">        <span class="keyword">return</span> NOTFIND;</span><br><span class="line">    <span class="keyword">int</span> k=(L+R)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// k=n-1时要独立一个分支，否则第二个if会越界</span></span><br><span class="line">    <span class="keyword">if</span>(k==(n<span class="number">-1</span>)&amp;&amp;A[k]&lt;=B[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> A[k];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;(n<span class="number">-1</span>)&amp;&amp;B[n-k<span class="number">-2</span>]&lt;=A[k]&amp;&amp;A[k]&lt;=B[n-k<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> A[k];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(B[n-k<span class="number">-1</span>]&lt;A[k])</span><br><span class="line">        <span class="keyword">return</span> findMedium(A,B,L,k<span class="number">-1</span>,n);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> findMedium(A,B,k+<span class="number">1</span>,R,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TwoArrayMedium</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> B[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=NOTFIND;</span><br><span class="line">    <span class="keyword">if</span>((ret=findMedium(A,B,<span class="number">0</span>,len<span class="number">-1</span>,len))==NOTFIND)</span><br><span class="line">        ret=findMedium(B,A,<span class="number">0</span>,len<span class="number">-1</span>,len);<span class="comment">//不在数组A,继续在B中查找</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">unsigned</span> N&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getRandomArray</span><span class="params">(T (&amp;arr)[N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//随机生成2000以内的随机数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> default_random_engine <span class="title">e</span><span class="params">(time(<span class="literal">nullptr</span>))</span></span>;</span><br><span class="line">    <span class="keyword">static</span> uniform_int_distribution&lt;T&gt; d(<span class="number">0</span>,<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:arr)</span><br><span class="line">        i=d(e);</span><br><span class="line">    sort(arr,arr+N);<span class="comment">//数组排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[LEN];</span><br><span class="line">    <span class="keyword">int</span> B[LEN];</span><br><span class="line">    getRandomArray(A);</span><br><span class="line">    getRandomArray(B);</span><br><span class="line">    <span class="keyword">int</span> C[<span class="number">2</span>*LEN];</span><br><span class="line">    copy(A,A+LEN,C);</span><br><span class="line">    copy(B,B+LEN,C+LEN);</span><br><span class="line">    sort(C,C+<span class="number">2</span>*LEN);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:C)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"中位数为:"</span> &lt;&lt; TwoArrayMedium(A,B,LEN) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个问题我只求了低中位数，因为数组总长度为$2n$恒为偶数，因此如果要求中间两个数的均值。只需要在上面代码的基础上稍微改下，加上$k+1$位置的数，然后除2即可达到。<strong>（注意：如果k求出是X数组的最后一位，那么高中位数在数组Y中）</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;9-3-8-emsp-设X-1-n-和Y-1-n-为两个数组，每个都包含n个有序的元素，请设计一个-O-lgn-时间的算法找出数组X和Y中所有2n个元素的中位数。&quot;&gt;&lt;a href=&quot;#9-3-8-emsp-设X-1-n-和Y-1-n-为两个数组，每个都包含n个有
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="中位数" scheme="http://007havegone.github.io/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    
      <category term="二分查找" scheme="http://007havegone.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>算法导论思考题6-2</title>
    <link href="http://007havegone.github.io/2019/07/31/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E6%80%9D%E8%80%83%E9%A2%986-2/"/>
    <id>http://007havegone.github.io/2019/07/31/算法导论思考题6-2/</id>
    <published>2019-07-31T12:02:23.000Z</published>
    <updated>2019-08-18T13:36:26.369Z</updated>
    
    <content type="html"><![CDATA[<h3 id="6-2（对d叉堆的分析）d叉堆与二叉堆很类似，但（一个可能的例外是）其中的每个非叶节点有d个孩子，而不是仅仅2个。"><a href="#6-2（对d叉堆的分析）d叉堆与二叉堆很类似，但（一个可能的例外是）其中的每个非叶节点有d个孩子，而不是仅仅2个。" class="headerlink" title="6-2（对d叉堆的分析）d叉堆与二叉堆很类似，但（一个可能的例外是）其中的每个非叶节点有d个孩子，而不是仅仅2个。"></a>6-2（对d叉堆的分析）d叉堆与二叉堆很类似，但（一个可能的例外是）其中的每个非叶节点有d个孩子，而不是仅仅2个。</h3><p>a.&emsp;如何在一个数组中表示一个d叉堆？</p><p>假设数组从$A[1]$开始,它作为根，那么$A[1]$有d个孩子分别是$A[2]…A[d+1]$，共d个。那么对于$A[2]…A[d+1]$共d个结点，一共有$d^2$个结点，从$A[d+2]….A[d^2+d+1]$。依次类推。那么对于一个编号为$i$的结点的第$j$个孩子$(1 \leq j \leq d)$，</p><p>D-ARY-Parent(i)<br>return $\lfloor (i-2)/d+1 \rfloor$</p><p>D-ARY-Child(i,j)<br>return $\lfloor d(i-1)+j+1$</p><p>i的d个结点从$d(i-1)+2到di+1$。</p><p>结合画图，不难推出。</p><p>自己可以通过 <strong>D-ARY-Parent(D-ARY-Child(i,j))=i</strong> 来验证一下。二叉堆是当$d=2$时的一个特例。</p><hr><p>b.&emsp;包含n个元素的d叉堆的高度是多少?请用n和d表示。</p><p>类似二叉堆的推导过程。不难的得出一个n个元素的d叉堆，有$\Theta(log_dn)=\Theta(lgn/lgd)$。</p><hr><p>c.&emsp;请给出EXTRACT-MAX在d叉堆上的一个有效实现，并用d和n表示出它的时间复杂度。</p><p>对于d叉堆的EXTRACT-MAX实现，与树中二叉堆的实现相同，只需要修改MAX-HEAPIFY在下放的过程中，是与d个孩子比较，而不是2个孩子。对于每一层的下放，最差情况下比较d次。那么对于一个n个结点的d叉堆来说。EXTRACT-MAX的时间复杂度为 $\Theta(dlog_dn)=\Theta(dlgn/lgd)$。</p><hr><p>d.&emsp;给出INSERT在d叉最大堆上的一个有效实现，并用d和n表示它的时间复杂度。</p><p>树中给出的二叉堆的MAX-HEAP-INSERT的实现同样适用与d叉堆。该过程只需要访问结点的parent结点，其他并没有改变。最坏情况下时间复杂度为$\Theta(h)$。h为d叉堆的高度，前面已求出，$h=\Theta(lgn/lgd)$。</p><hr><p>e.&emsp;给出INCREASE-KEY(A,i,k)的一个有效实现，当$k&lt;A[i]$时，它会触发一个错误，否则执行$A[i]=k$,并更新相应的d叉最大堆。请用d和n表示出它的时间复杂度。</p><p>跟书本的实现一致。只需要将计算parent的结点的公式替换即可。最坏情况下的时间复杂度为$\Theta(h)=\Theta(log_dn)=\Theta(lgn/lgd)$。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;6-2（对d叉堆的分析）d叉堆与二叉堆很类似，但（一个可能的例外是）其中的每个非叶节点有d个孩子，而不是仅仅2个。&quot;&gt;&lt;a href=&quot;#6-2（对d叉堆的分析）d叉堆与二叉堆很类似，但（一个可能的例外是）其中的每个非叶节点有d个孩子，而不是仅仅2个。&quot; clas
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="d叉堆" scheme="http://007havegone.github.io/tags/d%E5%8F%89%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>算法导论思考题4-1</title>
    <link href="http://007havegone.github.io/2019/07/31/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E6%80%9D%E8%80%83%E9%A2%984-1/"/>
    <id>http://007havegone.github.io/2019/07/31/算法导论思考题4-1/</id>
    <published>2019-07-30T16:42:47.000Z</published>
    <updated>2019-07-31T06:55:58.117Z</updated>
    
    <content type="html"><![CDATA[<h3 id="4-1（递归式例子）对下列每个递归式，给出T-n-的渐进上界和渐进下界。假定-n-leq2-时T-n-时常数。给出尽量紧确的界，并验证其正确性。"><a href="#4-1（递归式例子）对下列每个递归式，给出T-n-的渐进上界和渐进下界。假定-n-leq2-时T-n-时常数。给出尽量紧确的界，并验证其正确性。" class="headerlink" title="4-1（递归式例子）对下列每个递归式，给出T(n)的渐进上界和渐进下界。假定 $n\leq2$时T(n)时常数。给出尽量紧确的界，并验证其正确性。"></a>4-1（递归式例子）对下列每个递归式，给出T(n)的渐进上界和渐进下界。假定 $n\leq2$时T(n)时常数。给出尽量紧确的界，并验证其正确性。</h3><p>不会主方法的先看一下这篇博客：<a href="https://blog.csdn.net/qq_40512922/article/details/96932368" target="_blank" rel="noopener">https://blog.csdn.net/qq_40512922/article/details/96932368</a></p><p>a.&emsp;$T(n)=2T(n/2)+n^4$</p><p>证明：有$a=2,b=2,n^{log_ba}=n$，$f(n)=f(n^4)=\Omega(n^{\epsilon+1})$，其中$\epsilon=3$。下面证明正则条件：$\exists c&lt;1,af(n/b)\leq cf(n)$</p><script type="math/tex; mode=display">2f(n/2)=\frac{n^4}{8} \leq cn^4</script><p>当 $c=1/8$时,显然成立。因此$T(n)=\Theta(f(n))=\Theta(n^4)$</p><hr><p>b.&emsp;$T(n)=T(7n/10)+n$</p><p>证明：有$a=1,b=10/7,n^{log_ba}=1$，$f(n)=n=\Omega(n^{\epsilon+0})$，其中$\epsilon=1$，下面证明正则条件：$\exists c&lt;1,af(n/b)\leq cf(n)$</p><script type="math/tex; mode=display">f(7n/10)=7n/10 \leq cn</script><p>当$c=7/10$时，显然成立。因此$T(n)=\Theta(f(n))=\Theta(n)$</p><hr><p>c.&emsp;$T(n)=16T(n/4)+n^2$</p><p>证明：有$a=16,b=4,n^{log_ba}=n^2$，$f(n)=n^2=\Theta(n^2)$。</p><p>因此，$T(n)=\Theta(nlgn)$。</p><hr><p>d.&emsp;$T(n)=7T(n/3)+n^2$</p><p>证明：有$a=7,b=3,n^{log_ba}\approx n^{1.7}$，$f(n)=n^2=\Omega(n^{1.7+\epsilon})$，其中$\epsilon=0.3$，下面证明正则条件。</p><script type="math/tex; mode=display">7f(n/3)=\frac{7n^2}{9} \leq cn^2</script><p>当$c=7/9$时，显然成立。因此$T(n)=\Theta(f(n))=\Theta(n^2)$</p><hr><p>e.&emsp;$T(n)=7T(n/2)+n^2$</p><p>证明：有$a=7,b=2,n^{log_ba}\approx n^{2.8}$，$f(n)=n^2=O(n^{2.8-\epsilon})$，其中$\epsilon=0.8$。</p><p>因此$T(n)=\Theta(n^{log_ba})=\Theta(n^{log_27})$</p><hr><p>f.&emsp;$T(n)=2T(n/4)+\sqrt n$</p><p>证明：有$a=2,b=4,n^{log_ba}=n^{0.5}$，$f(n)=n^{0.5}=\Theta(n^0.5)$。<br>因此，$T(n)=\Theta(f(n)lgn)=\Theta(\sqrt{n}lgn)$</p><hr><p>g.&emsp;$T(n)=T(n-2)+n^2$</p><p>证明：</p><script type="math/tex; mode=display">T(n)=\sum_{i=0}^{n}{(2i)^2}=\frac{2n(n+1)(2n+1)}{3}+T(0) = \Theta(n^3)</script><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;4-1（递归式例子）对下列每个递归式，给出T-n-的渐进上界和渐进下界。假定-n-leq2-时T-n-时常数。给出尽量紧确的界，并验证其正确性。&quot;&gt;&lt;a href=&quot;#4-1（递归式例子）对下列每个递归式，给出T-n-的渐进上界和渐进下界。假定-n-leq2-时T
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="主方法" scheme="http://007havegone.github.io/tags/%E4%B8%BB%E6%96%B9%E6%B3%95/"/>
    
      <category term="算法分析" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>算法导论思考题2-4</title>
    <link href="http://007havegone.github.io/2019/07/30/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E6%80%9D%E8%80%83%E9%A2%982-4/"/>
    <id>http://007havegone.github.io/2019/07/30/算法导论思考题2-4/</id>
    <published>2019-07-30T09:41:22.000Z</published>
    <updated>2019-07-30T14:42:17.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思考题2-4（逆序对）-假设A-1-n-是一个有-n-个不同数的数组，若iA-j-，则对偶-i-j-称为A的一个逆序对-inversion-。"><a href="#思考题2-4（逆序对）-假设A-1-n-是一个有-n-个不同数的数组，若iA-j-，则对偶-i-j-称为A的一个逆序对-inversion-。" class="headerlink" title="思考题2-4（逆序对） 假设A[1..n]是一个有$n$个不同数的数组，若iA[j]，则对偶(i,j)称为A的一个逆序对(inversion)。"></a>思考题2-4（逆序对） 假设A[1..n]是一个有$n$个不同数的数组，若i<j且a[i]>A[j]，则对偶(i,j)称为A的一个逆序对(inversion)。</j且a[i]></h2><h3 id="a-列出数组-的5个逆序对。"><a href="#a-列出数组-的5个逆序对。" class="headerlink" title="a.列出数组$$的5个逆序对。"></a>a.列出数组$<2,3,8,6,1>$的5个逆序对。</2,3,8,6,1></h3><p>&emsp;逆序对有$(1,5),(2,5),(3,4),(3,5),(4,5)$</p><hr><h3 id="b-有集合-1-2-dots-n-中的元素构成的什么数组具有最多的逆序对？它有多少逆序对？"><a href="#b-有集合-1-2-dots-n-中的元素构成的什么数组具有最多的逆序对？它有多少逆序对？" class="headerlink" title="b.有集合$\{1,2,\dots,n\}$中的元素构成的什么数组具有最多的逆序对？它有多少逆序对？"></a>b.有集合$\{1,2,\dots,n\}$中的元素构成的什么数组具有最多的逆序对？它有多少逆序对？</h3><p>&emsp; 当数组为 $\{1,2,\dots,n\}$为逆序时，即$\{n,n-1,\dots,1\}$时逆序对最多。对于 $\forall i,j \in [1,n],(i,j)$均为逆序对。此时共有逆序对$(_n^2)=n(n-1)/2$</p><hr><p>c.插入排序的运行时间与输入数组中逆序对的数量之间是什么关系?证明你的回答。</p><p>&emsp;假设数组$A$初始时存在逆序对$(k,j)$，那么有$k<j$和$a[k]<a[j]$。在1-8行外层for循环中，每次令$key=a[j]$，$i=j-1$，在5-7行的while循环中，有$a[i]>key$，即存在一对逆序对，while循环的一次迭代，将$A[i]$后移一位，最终前$j$个元素处于有序，此时消除了前$j$个元素的逆序对。对于7-9的一次循环，相当于消除一对逆序对。因此，插入排序的运行时间和数组的逆序对之间呈线性关系。</j$和$a[k]<a[j]$。在1-8行外层for循环中，每次令$key=a[j]$，$i=j-1$，在5-7行的while循环中，有$a[i]></p><hr><p>d.给出一个确定在n个元素的任何排列中逆序对数量的算法，最坏情况需要$\Theta(nlgn)$的时间。</p><p>&emsp;对于这个问题，可以采用归并排序统计逆序对量，或者采用线段树。下面给出具体思路</p><p><strong>1、归并排序</strong></p><p>计算数组的逆序对数量，可以采用归并排序二分的思想。对于一个数组来说逆序对的来源可以分为3种情况。</p><p>对于一个数组 $A[left,right],mid=(left+right)/2$<br>(1) 两个都在左半数组，$left \leq i \leq j \leq mid，A[i] &gt; A[j]$<br>(2) 两个都在右半数组，$mid+1 \leq i \leq j \leq right,A[i] &gt; A[j]$<br>(3) 左右各一个，$left \leq i \leq mid &lt; j \leq right,A[i] &gt; A[j]$</p><p>根据上面的思路，只需要对归并排序的代码稍微改动即可。下面是我的实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InversionCount</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">总的逆序对等于左子数组的内部逆序对+右子数组的内部逆序对+来自左和右形成的逆序对</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">cnt+=MergeSort(A,l,m);<span class="comment">//第1种情况</span></span><br><span class="line">cnt+=MergeSort(A,m+<span class="number">1</span>,r);<span class="comment">//第2种情况</span></span><br><span class="line">cnt+=Merge1(A,l,m,r);<span class="comment">//第3种情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//书种归并排序采用哨兵的版本</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Merge1</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> l,<span class="keyword">int</span> m,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> inv_cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *L=<span class="keyword">new</span> <span class="keyword">int</span>[m-l+<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> *R=<span class="keyword">new</span> <span class="keyword">int</span>[r-m+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l,k=<span class="number">0</span>;i&lt;=m;)</span><br><span class="line">L[k++]=A[i++];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=m+<span class="number">1</span>,k=<span class="number">0</span>;i&lt;=r;)</span><br><span class="line">R[k++]=A[i++];</span><br><span class="line"><span class="keyword">int</span> LenA=m-l+<span class="number">1</span>;<span class="comment">//左子数组的长度</span></span><br><span class="line">L[m-l+<span class="number">1</span>]=R[r-m]=INF;<span class="comment">//设置哨兵</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=l,i=<span class="number">0</span>,j=<span class="number">0</span>;k&lt;=r;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(L[i]&lt;=R[j])<span class="comment">//i&lt;j且A[i]&lt;=A[j]，没有逆序对</span></span><br><span class="line">A[k++]=L[i++];</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//i&lt;j且A[i]&gt;A[j]</span></span><br><span class="line"><span class="keyword">if</span>(L[i]!=INF)&#123;<span class="comment">//这里有可能左侧数组先达到尾部，此时防止INF引起额外累加。</span></span><br><span class="line">                <span class="comment">//大于A[j]的数量=LenA-i(小于A[i]的数量，数组从0开始)</span></span><br><span class="line">inv_cnt+=LenA-i;</span><br><span class="line">&#125;</span><br><span class="line">A[k++]=R[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// printf("l = %d r = %d cnt = %d\n",l,r,inv_cnt);</span></span><br><span class="line"><span class="keyword">return</span> inv_cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不用哨兵处理会更方便点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Merge2</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> l,<span class="keyword">int</span> m,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *B=<span class="keyword">new</span> <span class="keyword">int</span>[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> i=l,j=m+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> inv_cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=m&amp;&amp;j&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[i]&lt;=A[j])</span><br><span class="line">B[k++]=A[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">inv_cnt+=m-i+<span class="number">1</span>;</span><br><span class="line">B[k++]=A[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=m)</span><br><span class="line">B[k++]=A[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=r)</span><br><span class="line">B[k++]=A[j++];</span><br><span class="line">k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;)</span><br><span class="line">&#123;</span><br><span class="line">A[i++]=B[k++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> inv_cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> A[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> B[]=&#123;<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> C[]=&#123;<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> D[]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; InversionCount::MergeSort(A,<span class="number">0</span>,<span class="number">7</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; InversionCount::MergeSort(B,<span class="number">0</span>,<span class="number">7</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; InversionCount::MergeSort(C,<span class="number">0</span>,<span class="number">5</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; InversionCount::MergeSort(D,<span class="number">0</span>,<span class="number">4</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2、线段树</strong></p><p>可以采用线段树来处理，这里不打算具体展开线段树的内容，后面有时间再整理一个关于线段树的专题。下面介绍算法思路。</p><p>1、为数组$A[1,n]$建立线段树，区间统计$[left,rigth]的数目，初始化均为0$，如果数据范围较大数据比较分散，可以先进行一次离散化。</p><p>2、依次对$A[1,n] \in [min,man]$的每个元素进行以下操作，假设$A[i]=k$,则对线段树查找区间$[k+1,max]$的大小，加入逆序对数量中，然后令$A[k]+1$。</p><p>上面的操作相当于遍历数组A，对于每一个元素，查找当前在它前面大于它的元素个数，然后累加起来，得到逆序对。遍历数组时间为$O(n)$，每进行一次查找操作为$O(lgn)$，总的的时间复杂度为$O(nlgn)$。</p><p>下面时代码实现，常规的线段树模板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lchild (x&lt;&lt;1) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rchild (x&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> A[N&lt;&lt;<span class="number">2</span>|<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A[x]=A[lchild]+A[rchild];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立线段树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left==right)&#123;</span><br><span class="line">A[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(left,mid,lchild);</span><br><span class="line">build(mid+<span class="number">1</span>,right,rchild);</span><br><span class="line">update(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询区间[L,R]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L&lt;=left&amp;&amp;right&lt;=R)</span><br><span class="line"><span class="keyword">return</span> A[x];</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">ret+=query(left,mid,L,R,lchild);</span><br><span class="line"><span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">ret+=query(mid+<span class="number">1</span>,right,L,R,rchild);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改 A[x]=k的结点+1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left==right)&#123;</span><br><span class="line">++A[x];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i&lt;=mid)</span><br><span class="line">modify(i,left,mid,lchild);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">modify(i,mid+<span class="number">1</span>,right,rchild);</span><br><span class="line">update(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[]=&#123;<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">build(<span class="number">1</span>,<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:arr)</span><br><span class="line">&#123;</span><br><span class="line">cnt+=query(<span class="number">1</span>,<span class="number">10</span>,i+<span class="number">1</span>,<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">modify(i,<span class="number">1</span>,<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思考题2-4（逆序对）-假设A-1-n-是一个有-n-个不同数的数组，若iA-j-，则对偶-i-j-称为A的一个逆序对-inversion-。&quot;&gt;&lt;a href=&quot;#思考题2-4（逆序对）-假设A-1-n-是一个有-n-个不同数的数组，若iA-j-，则对偶-i-j
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="排序" scheme="http://007havegone.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="逆序对" scheme="http://007havegone.github.io/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    
      <category term="线段树" scheme="http://007havegone.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法导论第二章插入排序</title>
    <link href="http://007havegone.github.io/2019/07/29/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://007havegone.github.io/2019/07/29/算法导论第二章插入排序/</id>
    <published>2019-07-29T10:00:17.000Z</published>
    <updated>2019-07-30T08:59:20.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法导论-第二章插入排序实现"><a href="#算法导论-第二章插入排序实现" class="headerlink" title="算法导论 第二章插入排序实现"></a>算法导论 第二章插入排序实现</h1><p>&emsp;插入排序算法是时间复杂度为 $O(n)$，输入规模$n$较小时，插入排序往往能有较好的效果。</p><p>&emsp;最优情况：数据整体有序，无需须交换元素，时间复杂度$O(n)$</p><p>&emsp;最坏情况：数据整体逆序，每个元素要 $1~n-1$次，时间复杂度为 $O(n^2)$。</p><p>&emsp;插入排序中的常数因子较小使得在$n$在较小的时候，在很多情况能够运行更快。作为归并排序，快速排序等算法在小规模时处理的问题时的子程序。</p><p>书中的伪代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSERTION-SORT(A)</span><br><span class="line"><span class="number">1</span> <span class="keyword">for</span> j = <span class="number">2</span> to A.length</span><br><span class="line"><span class="number">2</span> key = A[j]</span><br><span class="line"><span class="number">3</span> <span class="comment">//Insert A[j] into the sorted sequence[1..j-1]</span></span><br><span class="line"><span class="number">4</span>i = j<span class="number">-1</span></span><br><span class="line"><span class="number">5</span><span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key</span><br><span class="line"><span class="number">6</span>A[i+<span class="number">1</span>] = A[i]</span><br><span class="line"><span class="number">7</span>i = i+<span class="number">1</span></span><br><span class="line"><span class="number">8</span>A[i+<span class="number">1</span>] = key</span><br></pre></td></tr></table></figure></p><p>具体实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数组存放位置为[0,len-1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//升序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertSortInc</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len;++j)&#123;</span><br><span class="line"><span class="keyword">int</span> i=j<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> key=A[j];</span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;A[i]&gt;key)&#123;</span><br><span class="line">A[i+<span class="number">1</span>]=A[i];</span><br><span class="line">--i;</span><br><span class="line">&#125;</span><br><span class="line">A[i+<span class="number">1</span>]=key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//降序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertSortDec</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> i=j<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> key=A[j];</span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;A[i]&lt;key)&#123;</span><br><span class="line">A[i+<span class="number">1</span>]=A[i];</span><br><span class="line">--i;</span><br><span class="line">&#125;</span><br><span class="line">A[i+<span class="number">1</span>]=key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法导论-第二章插入排序实现&quot;&gt;&lt;a href=&quot;#算法导论-第二章插入排序实现&quot; class=&quot;headerlink&quot; title=&quot;算法导论 第二章插入排序实现&quot;&gt;&lt;/a&gt;算法导论 第二章插入排序实现&lt;/h1&gt;&lt;p&gt;&amp;emsp;插入排序算法是时间复杂度为 $O
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="排序" scheme="http://007havegone.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法导论思考题1-1</title>
    <link href="http://007havegone.github.io/2019/07/29/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E6%80%9D%E8%80%83%E9%A2%981-1/"/>
    <id>http://007havegone.github.io/2019/07/29/算法导论思考题1-1/</id>
    <published>2019-07-29T09:42:42.000Z</published>
    <updated>2019-07-30T08:59:25.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法导论-思考题1-1"><a href="#算法导论-思考题1-1" class="headerlink" title="算法导论-思考题1-1"></a>算法导论-思考题1-1</h1><h3 id="1-1（运行时间的比较）假设求解问题的算法需要-f-n-微秒-microseconds-，对下表中每个函数-f-n-和时间-t-可以确定在时间-t-内求解问题的最大规模-n-。"><a href="#1-1（运行时间的比较）假设求解问题的算法需要-f-n-微秒-microseconds-，对下表中每个函数-f-n-和时间-t-可以确定在时间-t-内求解问题的最大规模-n-。" class="headerlink" title="1-1（运行时间的比较）假设求解问题的算法需要 $f(n)$微秒(microseconds)，对下表中每个函数$f(n)$和时间$t$可以确定在时间$t$内求解问题的最大规模$n$。"></a>1-1（运行时间的比较）假设求解问题的算法需要 $f(n)$微秒(microseconds)，对下表中每个函数$f(n)$和时间$t$可以确定在时间$t$内求解问题的最大规模$n$。</h3><p><strong>中文版给的$f(n)$单位是毫秒，但看了原版，发现单位是微秒(microseconds)，故下面采用微秒来计算。</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">函数\时间</th><th style="text-align:center">1秒钟</th><th style="text-align:center">1分钟</th><th style="text-align:center">1小时</th><th style="text-align:center">1天</th><th style="text-align:center">1月</th><th style="text-align:center">1年</th><th style="text-align:center">1世纪</th></tr></thead><tbody><tr><td style="text-align:center">$lgn$</td><td style="text-align:center">$2^{10^6}$</td><td style="text-align:center">$2^{6\times 10^7}$</td><td style="text-align:center">$2^{3.6 \times 10^9}$</td><td style="text-align:center">$2^{8.64 \times 10^{10}}$</td><td style="text-align:center">$2^{2.592 \times 10^{12}}$</td><td style="text-align:center">$2^{3.1536 \times 10^{13}}$</td><td style="text-align:center">$2^{3.1536 \times 10^{15}}$</td></tr><tr><td style="text-align:center">$\sqrt n$</td><td style="text-align:center">$10^{12}$</td><td style="text-align:center">$3.6 \times 10^{15}$</td><td style="text-align:center">$1.296 \times10^{19}$</td><td style="text-align:center">$7.465 \times 10^{21}$</td><td style="text-align:center">$6.718 \times 10^{24}$</td><td style="text-align:center">$9.945 \times 10^{26}$</td><td style="text-align:center">$9.945 \times 10^{30}$</td></tr><tr><td style="text-align:center">$n$</td><td style="text-align:center">$10^6$</td><td style="text-align:center">$6 \times 10^7$</td><td style="text-align:center">$3.6 \times 10^9$</td><td style="text-align:center">$8.64 \times 10^{10}$</td><td style="text-align:center">$2.592 \times 10^{12}$</td><td style="text-align:center">$3.1536 \times 10^{13}$</td><td style="text-align:center">$3.1536 \times 10^{15}$</td></tr><tr><td style="text-align:center">$nlgn$</td><td style="text-align:center">$62746$</td><td style="text-align:center">$2.8 \times 10^6$</td><td style="text-align:center">$1.3 \times 10^8$</td><td style="text-align:center">$2.7 \times 10^9$</td><td style="text-align:center">$7.1 \times 10^{10}$</td><td style="text-align:center">$7.9 \times 10^{11}$</td><td style="text-align:center">$6.8 \times 10^{13}$</td></tr><tr><td style="text-align:center">$n^2$</td><td style="text-align:center">$1000$</td><td style="text-align:center">$7745$</td><td style="text-align:center">$60000$</td><td style="text-align:center">$293938$</td><td style="text-align:center">$1609968$</td><td style="text-align:center">$5615692$</td><td style="text-align:center">$56175382$</td></tr><tr><td style="text-align:center">$n^3$</td><td style="text-align:center">$100$</td><td style="text-align:center">$391$</td><td style="text-align:center">$1532$</td><td style="text-align:center">$4420$</td><td style="text-align:center">$13736$</td><td style="text-align:center">$31593$</td><td style="text-align:center">$146677$</td></tr><tr><td style="text-align:center">$2^n$</td><td style="text-align:center">$19$</td><td style="text-align:center">$25$</td><td style="text-align:center">$31$</td><td style="text-align:center">$36$</td><td style="text-align:center">$41$</td><td style="text-align:center">$44$</td><td style="text-align:center">$51$</td></tr><tr><td style="text-align:center">$n!$</td><td style="text-align:center">$9$</td><td style="text-align:center">$11$</td><td style="text-align:center">$12$</td><td style="text-align:center">$13$</td><td style="text-align:center">$15$</td><td style="text-align:center">$16$</td><td style="text-align:center">$17$</td></tr></tbody></table></div><p>$1s=10^6us$</p><p>$1min=6 \times 10^7us$</p><p>$1h=3.6 \times 10^9us$</p><p>$1D=8.64 \times 10^{10}us$</p><p>$1Mon=2.592 \times 10^{12}us$ （1个月30天）</p><p>$1Y=3.1536 \times 10^{13}us$  （365天）</p><p>$1C=3.1536 \times 10^{15}us$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法导论-思考题1-1&quot;&gt;&lt;a href=&quot;#算法导论-思考题1-1&quot; class=&quot;headerlink&quot; title=&quot;算法导论-思考题1-1&quot;&gt;&lt;/a&gt;算法导论-思考题1-1&lt;/h1&gt;&lt;h3 id=&quot;1-1（运行时间的比较）假设求解问题的算法需要-f-n-微
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>算法导论练习9.1-1找第二小的元素</title>
    <link href="http://007havegone.github.io/2019/07/26/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%BB%83%E4%B9%A09-1-1%E6%89%BE%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>http://007havegone.github.io/2019/07/26/算法导论练习9-1-1找第二小的元素/</id>
    <published>2019-07-26T13:08:35.000Z</published>
    <updated>2019-08-08T17:13:51.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法导论9-1-1找第二小的元素"><a href="#算法导论9-1-1找第二小的元素" class="headerlink" title="算法导论9.1-1找第二小的元素"></a>算法导论9.1-1找第二小的元素</h1><h2 id="1、证明：在最坏情况下，找到n个元素中第二小的元素需要-n-lceil-lgn-rceil-2-次比较。（提示：可以同时找到最小元素）"><a href="#1、证明：在最坏情况下，找到n个元素中第二小的元素需要-n-lceil-lgn-rceil-2-次比较。（提示：可以同时找到最小元素）" class="headerlink" title="1、证明：在最坏情况下，找到n个元素中第二小的元素需要 $n+ \lceil lgn  \rceil -2$次比较。（提示：可以同时找到最小元素）"></a>1、证明：在最坏情况下，找到n个元素中第二小的元素需要 $n+ \lceil lgn  \rceil -2$次比较。（提示：可以同时找到最小元素）</h2><p>做以下断言：无论采用何种比较算法，在寻找最小元素的过程中，第二小的元素一定与最小元素做过比较。<br>显然，因为第二小的元素直到遇到最小元素前，一定会胜出进入下一轮。如果最小元素没有与第二小元素相比较，则无法得出该元素是最小的关系。  </p><p>因此，要想是我们找到最小元素的比较次数最少，就需要在寻找最小元素的过程中与最小元素发生比较的次数尽量的少。  </p><p>由于每次我们只能取两个元素进行比较，从而考虑每一轮将我们比较元素两两比较，较小的元素进入下一轮（如比较元素有奇数个，落单的直接进入下一轮），这样比较所得的最小元素比较过的元素是最少的（每轮只有一个）。  </p><p>我们将比较过程转化为二叉树（以数组 [7,8,1,3,4,5,9]为例）:</p><p><img src="/2019/07/26/算法导论练习9-1-1找第二小的元素/二叉树.jpg" alt="二叉树"></p><h3 id="1-证明-n-1"><a href="#1-证明-n-1" class="headerlink" title="1.证明 $n-1$"></a>1.证明 $n-1$</h3><p>其中，除了叶节点外，每个结点都是一次比较的结果。因此该算法中，比较次数为树中度为2的结点数。根据二叉树的性子可以得出比较次数为 $n-1$ （二叉树：度为2的结点数=叶子叶子结点数-1）。可以看出树的每一层只有一个结点与最小元素比较，达到了下界，因此是最优的。</p><p>这里的 $n-1$ 次比较下界还有另外的思路。可以把每个元素看成一个集合。集合中用最小元素代表这个集合。初始状态下 $n$个点都是单独的集合，比较后相当于把集合做合并。合并后用最小值代表这个集合。那么初始状态下的 $n$ 个集合，至少经过 $n-1$ 次合并才能得到1个集合。  </p><h3 id="2-证明-lceil-lg-rceil-1"><a href="#2-证明-lceil-lg-rceil-1" class="headerlink" title="2.证明 $\lceil lg \rceil -1$"></a>2.证明 $\lceil lg \rceil -1$</h3><p>可以看出，与最小元素比较的次数为树高h-1（根节点的高度为1）。有因为叶节点数个数为n。从而有： $n \leq 2^{h-1}$，故有 $h-1 = \lceil lg n \rceil$,即与最小元素比较的次数至少为 $\lceil lg n \rceil$。  </p><p>从这 $\lceil lg n \rceil$个元素中找到的最小元素即是第二小的元素。最坏情况下第二小元素第一轮遇到最小元素被淘汰，从而在寻找最小元素的过程中，我们无法得到其他元素与第二小元素比较大小关系。这种情况下，要在 $\lceil lg n \rceil$个元素中找到最小元素需要 $\lceil lg n \rceil - 1$次比较。</p><p>综上：最坏情况下，要找到第二小的元素所需的比较次数为 $n + \lceil lg n\rceil -2$ 次比较。</p><h2 id="2-算法实现："><a href="#2-算法实现：" class="headerlink" title="2.算法实现："></a>2.算法实现：</h2><p>&emsp; 根据上面的解释。我们其实只要找到最小元素，然后在最小元素比较过程中比较过的元素记录下来，然后我们在这堆元素（上面证明共$\lceil lg n\rceil$个）中找最小元素即可。</p><p>&emsp;具体实现：对于每一个元素，采用数组或链表的结构，每次比较后胜出的元素记录与它比较的元素在原数组的下标，同时自身进入下一轮的比较，根据上面的图可知，每经过一轮比较，元素被筛选掉一半，直至最终仅剩一个元素时，它就是最小元素，返回与它比较元素的元素集合。最终在该集合中寻找第二小元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt;<span class="comment">//记录比较次数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        srand(time(<span class="literal">nullptr</span>));</span><br><span class="line">        for_each(vec.begin(),vec.end(),[](<span class="keyword">int</span> &amp;v)&#123;v=rand();&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSmallestAndCollection(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;* paths)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始状太全是胜者进入下一轮</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; winnerIndex(vec.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;winnerIndex.size();++i)winnerIndex[i]=i;</span><br><span class="line">        <span class="comment">//直到胜者唯一</span></span><br><span class="line">        <span class="keyword">while</span>(winnerIndex.size()!=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            winnerIndex=compareAndStore(vec,winnerIndex,paths);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> paths[winnerIndex[<span class="number">0</span>]];<span class="comment">//最终剩一个返回对于的path</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findSecondSmallest</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *paths)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> smallest2=INF;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path=Solution::findSmallestAndCollection(vec,paths);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:path)<span class="comment">//最 lgn个元素的最小值即是第二小元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vec[i]&lt;smallest2)&#123;</span><br><span class="line">            Solution::cnt++;<span class="comment">//比较次数+1</span></span><br><span class="line">            smallest2=vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> smallest2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; compareAndStore(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;winnerIndex,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;* paths)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> sz=winnerIndex.size();</span><br><span class="line">        <span class="keyword">if</span>(sz&amp;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(winnerIndex[sz<span class="number">-1</span>]);</span><br><span class="line">            --sz;</span><br><span class="line">            <span class="comment">//这里为了方便，奇数个元素时最后一个直接加入，同时数组大小-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;sz;i+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//小的加入ret进入下一轮，同时记录它的比较元素下标</span></span><br><span class="line">            <span class="keyword">if</span>(arr[winnerIndex[i]]&lt;=arr[winnerIndex[i<span class="number">-1</span>]])&#123;</span><br><span class="line">                ret.push_back(winnerIndex[i]);</span><br><span class="line">                paths[winnerIndex[i]].push_back(winnerIndex[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ret.push_back(winnerIndex[i<span class="number">-1</span>]);</span><br><span class="line">                paths[winnerIndex[i<span class="number">-1</span>]].push_back(winnerIndex[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Solution::cnt++;<span class="comment">//比较次数+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Solution::cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showTopTen</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(vec.begin(),vec.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size()&amp;&amp;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; vec[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入元素个数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; len;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(len);Solution::init(vec);<span class="comment">//产生len个随机数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *comparePath=<span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;[vec.size()];<span class="comment">//建立每个元素比较的路径</span></span><br><span class="line"><span class="keyword">int</span> smallest2=Solution::findSecondSmallest(vec,comparePath);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Second smallest element :"</span>&lt;&lt;smallest2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Compare time O(n+lgn-2) \n Std:"</span> &lt;&lt; (len+<span class="built_in">ceil</span>(<span class="built_in">log</span>(len)/<span class="built_in">log</span>(<span class="number">2</span>))<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nExtra:"</span> &lt;&lt; Solution::cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    showTopTen(vec);<span class="comment">//打印vec最小的10个元素</span></span><br><span class="line">    <span class="keyword">delete</span>[] comparePath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p>该算法主要注重比较次数，但是空间复杂度不乐观（保存比较路径），时间复杂度为 $O(n)$。适合于那种一次比较需要耗费大量时间的值。下面有两篇我解决该题参考的博客。</p><h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><p>只涉及证明：</p><p>博客1：<a href="https://blog.csdn.net/qq_33382034/article/details/53495036" target="_blank" rel="noopener">https://blog.csdn.net/qq_33382034/article/details/53495036</a>  </p><p>包括证明和算法实现（python）</p><p>博客2：<a href="http://windmissing.github.io/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/2015-12/9.1-1-second_smallest_element.html" target="_blank" rel="noopener">http://windmissing.github.io/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/2015-12/9.1-1-second_smallest_element.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法导论9-1-1找第二小的元素&quot;&gt;&lt;a href=&quot;#算法导论9-1-1找第二小的元素&quot; class=&quot;headerlink&quot; title=&quot;算法导论9.1-1找第二小的元素&quot;&gt;&lt;/a&gt;算法导论9.1-1找第二小的元素&lt;/h1&gt;&lt;h2 id=&quot;1、证明：在最坏情
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>主方法求解递归式</title>
    <link href="http://007havegone.github.io/2019/07/22/%E4%B8%BB%E6%96%B9%E6%B3%95%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E5%BC%8F/"/>
    <id>http://007havegone.github.io/2019/07/22/主方法求解递归式/</id>
    <published>2019-07-22T15:49:10.000Z</published>
    <updated>2019-07-30T08:59:09.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主方法求解递归式"><a href="#主方法求解递归式" class="headerlink" title="主方法求解递归式"></a>主方法求解递归式</h1><p>&emsp;&emsp;在分析递归的算法时，主方法可以较快的计算出算法的时间复杂度<br>主方法可以用于满足以下形式的递归式。</p><script type="math/tex; mode=display">T(n)=aT(n/b)+f(n)</script><p>其中$a\geq1和b&gt;1$是常数，$f(n)$是渐进函数。<br>&emsp;&emsp;主方法描述的算法：将原本规模为$n$的问题，分解为 $a$ 个规模为 $n/b$ 的子问题，其中 $a,b\in \mathbb{Z^+}$，函数 $f(n)$ 包含了问题分解和子问题合并的代价。</p><p>下面是归并排序的递归式:</p><script type="math/tex; mode=display">T(n)=\begin{cases}\Theta(1) & 若n=1 \\2T(n/2)+\Theta(n) & 若n>1 \\\end{cases}</script><p>其中，$a=2, b=2, f(n)=\Theta(n^2)。$<br>&emsp;&emsp;在具体处理过程中,会遇到 $n/b$ 可能不是整数的情况。可以将 $a$ 项 $T(n/b)$全都替换为$T(\lfloor n/b \rfloor)或T(\lceil n/b\rceil)$ 并不会影响递归式的渐进性质。</p><hr><h3 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h3><p>主定理：$a\geq1和b&gt;1$是常数，$f(n)$是一个函数，$T(n)$是定义在非负整数上的递归式:</p><script type="math/tex; mode=display">T(n)=aT(n/b)+f(n)</script><p>其中将 $n/b$ 解释为$\lfloor n/b \rfloor或\lceil n/b\rceil$。那么$T(n)$有如下渐近界：</p><p> 1.若对某个常数 $\epsilon &gt;0$有 $f(n)= O(n^{log_ba-\epsilon})$ ,则 $T(n)=\Theta(n^{log_ba})。$</p><p> 2.若$f(n)=\Theta(n^{log_ba})$，则 $T(n)=\Theta(n^{log_ba} lgn)$</p><p> 3.若对某个常数$\epsilon&gt;0$ 有 $f(n)=\Omega(n^{log_ba+\epsilon})$，且对某个常数 $c&lt;1$ 和所有足够大的 $n$ 有 $af(n/b)\leq cf(n)$，则 $T(n)=\Theta(f(n))$。 </p><p>&emsp;&emsp;实际上就是将函数 $f(n)$ 和函数 $n^{log_ba}$ 进行比较。如情况1和情况3，两者的较大者决定了递归式的解。对于情况2，则再乘上一个对数因子 $lgn$ ，解为 $T(n)=\Theta(n^{loa_ba}  lgn)=\Theta(f(n) lgn)$。</p><p><strong>注意:</strong> 对于第1种情况和第3种情况的 $\mathbf{f(n)}$ 渐进小于和渐进大于 $\mathbf{n^{log_ba}}$，其中相差一个因子 $n^\epsilon$，其中 $\epsilon$为大于0的常数，即要满足 <strong>多项式的差距</strong>。同时第三种情况还要满足 “正则”条件 $af(n/b)\leq cf(n)$。</p><p><strong>这三种情况未覆盖 $f(n)$ 的所有可能性。</strong> 即 $f(n)$ 不满足多项式级别的渐进小于 $n^{log_ba}$而处于情况1和情况2之间。同理，不满足 $f(n)$ 渐进大于而处于 $n^{log_ba}$ 而处于情况2和情况2之间，或则情况3而不满足正则条件，均不能使用主方法求解递归式。</p><hr><h3 id="主方法使用例子"><a href="#主方法使用例子" class="headerlink" title="主方法使用例子"></a>主方法使用例子</h3><p>1、</p><script type="math/tex; mode=display">T(n)=9T(n/3)+ n</script><p>其中 $a=9,b=3,f(n)=n$。很容易求解 $n^{log_ba}=n^2=\Theta(n^2)$。<br>有$f(n)=n= O( n^{log_ba-\epsilon})$，其中$\epsilon=1$，故满足情况1，因此得出$T(n)=\Theta(n^2)$。</p><p>2、</p><script type="math/tex; mode=display">T(n)=T(2n/3)+1</script><p>其中 $a=1,b=3/2,f(n)=1$。$n^{log_ba}=n^{log_{3/2}1}=\Theta(1)$。<br>有$f(n)=\Theta(n^{log_ba})=\Theta(1)$。因此满足情况2，则 $T(n)=\Theta(n^{log_ba} lgn)=\Theta(lgn)$。</p><p>3、</p><script type="math/tex; mode=display">T(n)=3T(n/4)+nlgn</script><p>其中 $a=3,b=4,f(n)=nlgn$。$n^{log_ba}=n^{log_43}= O(n^{0.793})$。由于$f(n)=\Omega(n^{log_43+\epsilon})$，其中$\epsilon\approx0.2$。<br>接下来证明正则条件，即</p><script type="math/tex; mode=display">\begin{aligned}af(n/b) & \leq cf(n) \\ 3(n/4)lg(n/4) & \leq  cnlgn\\ \end{aligned}</script><p>显然，当$c=3/4$时，不等式成立。<br>故$T(n)=\Theta(f(n))=\Theta(nlgn)$</p><p>下面这个递归式不能运用主方法<br>4、</p><script type="math/tex; mode=display">T(n)=2T(n/2)+nlgn</script><p>其中 $a=2,b=2,f(n)=nlgn$，$n^{log_ba}=\Theta(n)$，<br>可能会得到错误的结论有：$f(n)=\Omega(n^{log_22+\epsilon})$。然后继续求解下去。<br>实际上，不满足之前提到的情况1和情况3的渐进差距需要时多项式级别的。<br>即：</p><script type="math/tex; mode=display">\frac{nlgn} {n^{log_22}}=\frac {nlgn} {n} = lgn = O(n^\epsilon)</script><blockquote><p>这里的 $\mathbf{\omicron}$ 符号代表非渐进紧确的上界，<br>如：$f(n)=\omicron(g(n))$: $\forall c&gt;0$，$\exists$常量$n_0&gt;0$，使得 $\forall n\geq n_0$，有 $0 \leq f(n) \leq cg(n)$。简单理解小于但不等于。</p></blockquote><p>即不满足多项式级别的大于。故处于情况2和情况3之间。不可以采用主方法求解。</p><h3 id="练习题4-5-1：-建议自己动手做完后对照。"><a href="#练习题4-5-1：-建议自己动手做完后对照。" class="headerlink" title="练习题4.5-1： 建议自己动手做完后对照。"></a>练习题4.5-1： 建议自己动手做完后对照。</h3><p>a.</p><script type="math/tex; mode=display">T(n)=2T(n/4)+1</script><p>其中$a=2,b=4,f(n)=1$, $n^{log_ba}= \sqrt n$。<br>有 $f(n) = O(n^{log_ba-\epsilon}) = O(n^{0.5-\epsilon})$，其中$\epsilon = 0.5$。<br>故 $T(n) = \Theta(n^{log_42}) = \Theta(\sqrt n)$</p><hr><p>b.</p><script type="math/tex; mode=display">T(n)=2T(n/4)+\sqrt{n}</script><p>同上,可以求出 $n^{log_ba}$，由于 $f(n) = \sqrt n =\Theta(\sqrt n) = \Theta(n^{log_42})$<br>故$T(n) = \Theta( f(n)lgn) = \Theta(\sqrt n  lgn)$</p><hr><p>c.</p><script type="math/tex; mode=display">T(n)=2T(n/4)+n</script><p>同上，求出 $n^{log_ba}$，由于 $f(n) = \Omega(n^{0.5 + \epsilon})$, 其中 $\epsilon =0.5$。接下来证明正则条件：</p><script type="math/tex; mode=display">\begin{aligned}af(n/b)  & \leq c f(n)\\2(n/4)    & \leq c \ n\\\frac 1 2  & \leq c\end{aligned}</script><p>显然，取 $c = \frac 1 2$时，满足条件。故 $T(n) = \Theta(f(n)) = \Theta(n)$</p><hr><p>d.</p><script type="math/tex; mode=display">T(n)=2T(n/4)+n^2</script><p>同上，求出 $n^{log_ba}$，由于 $f(n) =  n^2 = \Omega(n^{logb_a+\epsilon})$，其中 $\epsilon = 1.5$。下面证明正则条件：</p><script type="math/tex; mode=display">\begin{aligned}a f(n/b) & \leq c f(n) \\2 (n/4)^2 & \leq c \ n^2 \\n^2/8 & \leq c \ n^2\end{aligned}</script><p>显然，取 $c = 1/8$ 时，满足条件。故 $T(n) = \Theta( f(n) ) = \Theta(n^2)$。</p><p><strong>参考文献：算法导论</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;主方法求解递归式&quot;&gt;&lt;a href=&quot;#主方法求解递归式&quot; class=&quot;headerlink&quot; title=&quot;主方法求解递归式&quot;&gt;&lt;/a&gt;主方法求解递归式&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在分析递归的算法时，主方法可以较快的计算出算法的时间复杂度&lt;br&gt;主
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="主方法" scheme="http://007havegone.github.io/tags/%E4%B8%BB%E6%96%B9%E6%B3%95/"/>
    
      <category term="时间复杂度" scheme="http://007havegone.github.io/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
      <category term="算法分析" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Effective c++ 读书笔记第一章</title>
    <link href="http://007havegone.github.io/2019/07/13/Effective-c-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>http://007havegone.github.io/2019/07/13/Effective-c-读书笔记第一章/</id>
    <published>2019-07-13T14:28:44.000Z</published>
    <updated>2019-08-18T13:34:29.617Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><h1 id="Ⅰ、-让自习惯C"><a href="#Ⅰ、-让自习惯C" class="headerlink" title="Ⅰ、 让自习惯C++"></a>Ⅰ、 让自习惯C++</h1><p><br></p><h2 id="条款01：视C-为一个语言连邦"><a href="#条款01：视C-为一个语言连邦" class="headerlink" title="条款01：视C++为一个语言连邦"></a>条款01：视C++为一个语言连邦</h2><hr><p>C++是一个多重泛型编程语言，同时支持过程形式、面向对象形式、泛型形式、元编程形式的语言。</p><p>将C++是为一个联邦,主要的此语言为4个：</p><p>1.procedural-based C。C语言的面向过程<br>2.Object-Oriented C++。面向对象<br>3.Template C++。 C++ 的泛型 (generics) 编程和由 template 的强大功能带来 template   metaprogramming (TMP,模板元编程)<br>4.STL。template程序库，主要包括 容器、迭代器、算法以及函数对象</p><p><strong>tips:编程过程中在前面3个次语言之间切换时，可能导致高效编程守则要求的改变</strong></p><p><br></p><h2 id="条款02-尽量以-const-enum-inline-替换-define"><a href="#条款02-尽量以-const-enum-inline-替换-define" class="headerlink" title="条款02:尽量以 const, enum, inline 替换 #define"></a>条款02:尽量以 const, enum, inline 替换 #define</h2><hr><h3 id="2-1、采用const替换-define"><a href="#2-1、采用const替换-define" class="headerlink" title="2.1、采用const替换#define"></a>2.1、采用const替换#define</h3><p>此处用宏定义一个常量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure><p>记号名称ASPECT_RATIO可能未被登记到记录表(symbol table), 因为可能在编译前的预处理阶段被替换。<br>导致发生错误时不容易追踪该信息。</p><p>采用常量替换:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span> <span class="comment">//大写名称通常用于宏，此处改变名称写法</span></span><br></pre></td></tr></table></figure><p>常量定义式通常放在头文件</p><p>定义一个常量的 <code>char*based</code>字符串（不可改变指向不可改变内容）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> autorName = <span class="string">"Scott Meyers"</span>; </span><br><span class="line"><span class="comment">//根据c++ primer观点，第一个const为底层const,保证指针指向内容不变</span></span><br><span class="line"><span class="comment">//第二个const为顶层const,保证指针指向地址不变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//采用string</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">autoirName</span><span class="params">(<span class="string">"Scott Meyers"</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>定义一个class的专属常量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns = <span class="number">5</span>; <span class="comment">//这里只是常量声明式，声明式，声明式</span></span><br><span class="line">        <span class="keyword">int</span> scores[NumTurns];<span class="comment">//使用它</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;C++中 class专属常量又是static且为整数类型(eg: int,char,bool).需要特殊处理，如果未取地址，可以只声明，否则需要另外提供定义式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NumTurns;<span class="comment">//类内已经初始化赋值，无须也无法重新赋值。</span></span><br></pre></td></tr></table></figure><p>#define无法为一个 class 定义一个专属变量，因为 #define 并不重视作用域。<br>也就是不存在所谓的 private #define</p><h3 id="2-2、采用enum替换-define"><a href="#2-2、采用enum替换-define" class="headerlink" title="2.2、采用enum替换#define"></a>2.2、采用enum替换#define</h3><p>&emsp;&emsp;旧式编译器不支持 static 成员在声明式上获得初值，”in class” 初值设定也只允许对整数常量进行。<br>此时，需要将初值放在定义式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CostEstimate</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> FudgeFactor;<span class="comment">//static class 常量声明</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span></span><br><span class="line">    CostEstimate::FudgeFactor = <span class="number">1.35</span>;<span class="comment">//位于实现文件内</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;类内的数组声明式，编译器坚持必须在编译期间知道数组的大小。如果编译器不允许 “static 整数型class常量” 完成 “in class”初值设定，可改用所谓的 “the enum hack” 补偿做法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span>&#125;;<span class="comment">//"the enum hack"</span></span><br><span class="line">                                <span class="comment">//令 NumTurns成为5的一个记号名称</span></span><br><span class="line">    <span class="keyword">int</span> socres[NumTurns];</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：enum不能取地址</strong></p><h3 id="2-3、采用-template替换-define"><a href="#2-3、采用-template替换-define" class="headerlink" title="2.3、采用 template替换 #define"></a>2.3、采用 template替换 #define</h3><p>另一个常见的 #define 误用情况是以它实现宏（macros）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用宏比较a和b的较大值来调用f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a,b) f(a)&gt;f(b) ? (a) : (b) )</span></span><br></pre></td></tr></table></figure><p>缺点： 要为实参添加小括号防止错误，还有一些不容易发现的错误</p><p>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>,b = <span class="number">0</span>;</span><br><span class="line">CALL_WITH_MAX(++a, b);<span class="comment">//a被累加了两次</span></span><br><span class="line">CALL_WITH_MAX(++a, b+<span class="number">10</span>);<span class="comment">//a被累加了一次</span></span><br></pre></td></tr></table></figure><p>采用template函数替代</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T&amp; a,<span class="keyword">const</span> T&amp; b)</span></span>&#123;<span class="comment">//采用 pass by reference-to-const</span></span><br><span class="line">                                                <span class="comment">//可以传递所有类型.</span></span><br><span class="line">    f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h2><hr><h3 id="3-1、const成员函数"><a href="#3-1、const成员函数" class="headerlink" title="3.1、const成员函数"></a>3.1、const成员函数</h3><p>目的：  </p><p>1.使<code>class</code>接口比较容易被理解，那些可以改动，那些不行<br>2.使“操作<code>const</code>对象”称为可能。<code>pass-by-reference-to-const</code>方式传递对象。</p><p><strong><code>const</code>函数可被重载</strong><br>1.<code>const</code>对象只能调用 const版本<br>2.<code>non-const</code>对象可以调用 <code>const</code>和<code>non-const</code>版本，默认为<code>non-const</code>版本。</p><h3 id="3-2、bitwise-constness-和-logical-constness"><a href="#3-2、bitwise-constness-和-logical-constness" class="headerlink" title="3.2、bitwise constness 和 logical constness"></a>3.2、bitwise constness 和 logical constness</h3><blockquote><p>1、<code>bitwise const</code>阵营的人相信，成员函数只有在不改变对象的任何成员变量(static除外)时<br>才可以说是 <code>const</code>。即不改变对象内的任何一个 bit 。<br>这种论点好处是很容易侦测违反点。<br><code>bitwise constness</code>正是 C++ 对常量性的定义，因此 const 成员函数不可以更改对象内的<br>任何<code>non-static</code>成员变量。</p></blockquote><p>不幸的是很多不具备<code>const</code>性质的函数却可以通过 <code>bitwise</code>测试。<br>实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span><span class="comment">//bit const声明</span></span><br><span class="line">    &#123; <span class="keyword">return</span> pText[position]; &#125;                         <span class="comment">//但实际没起到效果</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//此时</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> CTextBlock <span class="title">cctb</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;<span class="comment">//声明一个常量对象</span></span><br><span class="line"><span class="keyword">char</span> *pc = &amp;cctb[<span class="number">0</span>];</span><br><span class="line">*pc = <span class="string">'J'</span>;<span class="comment">//此时cctb变为 “Jello”</span></span><br></pre></td></tr></table></figure><blockquote><p>2、这种情况导出了所谓的<code>logical constness</code>。他们主张，一个 <code>const</code>成员函数<br>可以修改它所处理的对象内的某些 bits, 但只有在客户端侦测不出的情况下才得如此。  </p></blockquote><p>例如： CTextBlock class有可能高速缓存文本区域的长度以便询问：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> length() <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *pText;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> textLength;<span class="comment">//最近一次计算的文本区域长度</span></span><br><span class="line">    <span class="keyword">bool</span> lengthIsValid;<span class="comment">//当前长度是否有效</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> CTextBlock::length() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lengthIsValid)&#123;</span><br><span class="line">        textLength = <span class="built_in">std</span>::<span class="built_in">strlen</span>(pText);<span class="comment">//error!!! const函数内</span></span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;<span class="comment">//不允许修改类成员</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案 <code>mutable</code>释放 <code>non-static</code>成员变量的<code>bitwise constness</code>约束</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> length() <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *pText;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> textLength;<span class="comment">//mutable可能总是会被更改，</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid;<span class="comment">//即使在const函数内</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> CTextBlock::length() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!lengthIsValid)&#123;</span><br><span class="line">            textLength = <span class="built_in">std</span>::<span class="built_in">strlen</span>(pText);<span class="comment">//现在valid</span></span><br><span class="line">            lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> textLength;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-3、在-const-和-non-const-成员函数中避免重复"><a href="#3-3、在-const-和-non-const-成员函数中避免重复" class="headerlink" title="3.3、在 const 和 non-const 成员函数中避免重复"></a>3.3、在 const 和 non-const 成员函数中避免重复</h3><p>假设TextBlock的 operator[] 不单单返回一个 reference，还要做各种检测，<br>这样会导致写出的 const 和 non-const operator[] 冗余。</p><p><strong>解决方案 令 non-const版本调用 const版本</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span> <span class="comment">//一如既往</span></span><br><span class="line">    &#123;   ...</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position)           <span class="comment">//调用 const版本</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&gt;&amp;(                      <span class="comment">//将op[]返回值的const转除</span></span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)    <span class="comment">//为*this加上const</span></span><br><span class="line">                [position];         <span class="comment">//调用 const op[];</span></span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：反向操作将 const函数调用 non-const是不可取的</strong></p><p><br></p><h2 id="条款04：确定对象使用前已被初始化"><a href="#条款04：确定对象使用前已被初始化" class="headerlink" title="条款04：确定对象使用前已被初始化"></a>条款04：确定对象使用前已被初始化</h2><p>定义类Point</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Point p;<span class="comment">//p成员变量有时候会被初始化（为0），有时候不会</span></span><br></pre></td></tr></table></figure><p>1.使用 C part of C++ 而且初始化可能招致运行期成本，那么不保证初始化<br>2.non-C parts of C++,则有所变化，如 vector（STL part of C++）保证初始化,<br> array（C part of C++) 不保证内容初始化。</p><p><strong>最佳处理办法</strong>： 永远在使用对象前先将其初始化。对于无任何成员的内置类型，你必须手工完成此事。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;                              <span class="comment">//对int初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* text = <span class="string">"A C-style string"</span>;<span class="comment">//对指针初始化</span></span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; d;                          <span class="comment">//调用输入流初始化</span></span><br></pre></td></tr></table></figure><h3 id="4-1、区分赋值和初始化"><a href="#4-1、区分赋值和初始化" class="headerlink" title="4.1、区分赋值和初始化"></a>4.1、区分赋值和初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> &#123;</span> ...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ABEntry</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; address,<span class="comment">//构造函数</span></span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt;&amp; phones);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> theName;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> theAddress;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">    <span class="keyword">int</span> numTimesConsulted;</span><br><span class="line">&#125;;</span><br><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; address,  </span><br><span class="line">                <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">&#123;</span><br><span class="line">    theName = name;         <span class="comment">//这些都是赋值</span></span><br><span class="line">    theAddress = address;   <span class="comment">//而非初始化</span></span><br><span class="line">    thePhone = phones;</span><br><span class="line">    numTimesConsulted = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对象的初始化发生在进入构造函数之前，故以上的 theName, theAddress 和 thePhones均不是初始化，而是赋值。初始化发生在某些对象的default构造函数调用时，此时未进入ABEntry构造函数体，而对于 numTimesConsulted这类内置类型，赋值动作的时间点不确定。</p><p>采用 <strong>member initialization list (成员初值列）</strong>来为对象的成员初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; address,  </span><br><span class="line">                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">    :theName(name),    <span class="comment">//此处均为初始化，如果</span></span><br><span class="line">    theAddress(address),    <span class="comment">//类成员没有在指定，编译器</span></span><br><span class="line">    thePhones(phones),      <span class="comment">//调用默认构造函数</span></span><br><span class="line">    numTimesCosulted(<span class="number">0</span>)</span><br><span class="line">    &#123;&#125;</span><br></pre></td></tr></table></figure><p>如果成员变量为 <code>const 或 references</code>，则一定需要初值，不能被赋值。</p><p><strong>C++成员初始化次序</strong><br>base classes 更早由于其 drived classes 被初始化，而 class 的成员变量按照成员声明次序被初始化</p><h3 id="4-2、不同编译单元内定义的-non-local-static-对象的初始化次序"><a href="#4-2、不同编译单元内定义的-non-local-static-对象的初始化次序" class="headerlink" title="4.2、不同编译单元内定义的 non-local static 对象的初始化次序"></a>4.2、不同编译单元内定义的 non-local static 对象的初始化次序</h3><p><strong>local static对象</strong>： 寿命从构造直至程序结束为止，因此不包括 <code>stack</code>和<code>heap-based对象</code>。这种对象包括 <code>global</code>对象 、定义于<code>namespace</code>作用域内的对象、在<code>classed</code>内、在函数内、以及在 file作域内被声明为 <code>static</code>的对象。<br>函数内的 <code>static</code>对象称为为 <code>local static</code>对象(它们相对函数而言为 <code>local</code>)，其他 <code>static</code>对象称为 <code>non-local static</code>对象。它们的析构函数会在 <code>main()</code>结束时自动调用。</p><p><strong>编译单源</strong>：是指产出单一目标文件的那些源码。基本上它是单一源码文件加上其所含的头文件。</p><p>问题在于<strong>C++对于定义于不同编译单元内的 <code>non-local static</code>对象的初始化次序并无明确定义</strong></p><p>实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span>&#123;</span><span class="comment">//编译单元A</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> numDisk() <span class="keyword">const</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;<span class="comment">//预备给用户使用的对象</span></span><br><span class="line"><span class="comment">/*----------------------------------------------------------*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Directory( params); <span class="comment">//编译单元B</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directory( params)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs.numDisks();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设，采用 创建一个 Driectory对象  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Directory <span class="title">tempDir</span><span class="params">( params)</span></span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时 tempDir构造函数调用了 dfs函数对象，故 dfs必须先于 tempDir初始化，否则后果很严重。以下是解决方案：</p><p><strong>采用 <code>local static</code>对象替换 <code>non-local static</code>对象</strong><br><strong>这是 <code>Singleton</code>模式的一个常见手法</strong></p><p>这个手法基础在于：C++保证,函数内的<code>local static</code>对象会在“该函数被调用期间”<br>“首次遇上该对象的定义式”时被初始化。如果函数从未调用，则不会生成对象，<br>也免去了多余的构造函数析构函数的调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span>&#123;</span>...&#125;;              <span class="comment">//同前</span></span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span>                   <span class="comment">//定义一个local static对象 </span></span></span><br><span class="line"><span class="function"></span>&#123;                                   <span class="comment">//返回一个reference</span></span><br><span class="line">    <span class="keyword">static</span> FileSystem fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span>&#123;</span>...&#125;;               <span class="comment">//同前</span></span><br><span class="line">Directory::Directory( params)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> disk = tfs().numDisks();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span>                <span class="comment">//同前,返回一个 reference to tfs</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Directory td;</span><br><span class="line">    <span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以上的 <code>reference-returing</code></strong>函数往往十分单纯：定义并初始化一个<code>local static</code>，然后返回它。</p><p><strong>注意：这些内含 <code>static</code>对象的事实使他们在多线程有不确定性。任何一种 <code>non-const static</code>对象，无论是<code>local</code>还是<code>non-local</code>，多线程环境下的等待某事发生都会有麻烦。</strong></p><p><strong>解决方案：在程序单线程启动阶段手工调用所有reference-returing函数，可以消除与初始化有关的“竞速形势”。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&quot;Ⅰ、-让自习惯C&quot;&gt;&lt;a href=&quot;#Ⅰ、-让自习惯C&quot; class=&quot;headerlink&quot; title=&quot;Ⅰ、 让自习惯C++&quot;&gt;&lt;/a&gt;Ⅰ、 让自习惯C++&lt;/h1&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;条款01：视C-为一个语言
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://007havegone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://007havegone.github.io/tags/C/"/>
    
      <category term="Effective C++" scheme="http://007havegone.github.io/tags/Effective-C/"/>
    
  </entry>
  
</feed>
