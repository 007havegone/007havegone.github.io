<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://007havegone.github.io/"/>
  <updated>2019-07-31T06:55:58.117Z</updated>
  <id>http://007havegone.github.io/</id>
  
  <author>
    <name>007havegone</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法导论思考题4-1</title>
    <link href="http://007havegone.github.io/2019/07/31/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E6%80%9D%E8%80%83%E9%A2%984-1/"/>
    <id>http://007havegone.github.io/2019/07/31/算法导论思考题4-1/</id>
    <published>2019-07-30T16:42:47.000Z</published>
    <updated>2019-07-31T06:55:58.117Z</updated>
    
    <content type="html"><![CDATA[<h3 id="4-1（递归式例子）对下列每个递归式，给出T-n-的渐进上界和渐进下界。假定-n-leq2-时T-n-时常数。给出尽量紧确的界，并验证其正确性。"><a href="#4-1（递归式例子）对下列每个递归式，给出T-n-的渐进上界和渐进下界。假定-n-leq2-时T-n-时常数。给出尽量紧确的界，并验证其正确性。" class="headerlink" title="4-1（递归式例子）对下列每个递归式，给出T(n)的渐进上界和渐进下界。假定 $n\leq2$时T(n)时常数。给出尽量紧确的界，并验证其正确性。"></a>4-1（递归式例子）对下列每个递归式，给出T(n)的渐进上界和渐进下界。假定 $n\leq2$时T(n)时常数。给出尽量紧确的界，并验证其正确性。</h3><p>不会主方法的先看一下这篇博客：<a href="https://blog.csdn.net/qq_40512922/article/details/96932368" target="_blank" rel="noopener">https://blog.csdn.net/qq_40512922/article/details/96932368</a></p><p>a.&emsp;$T(n)=2T(n/2)+n^4$</p><p>证明：有$a=2,b=2,n^{log_ba}=n$，$f(n)=f(n^4)=\Omega(n^{\epsilon+1})$，其中$\epsilon=3$。下面证明正则条件：$\exists c&lt;1,af(n/b)\leq cf(n)$</p><script type="math/tex; mode=display">2f(n/2)=\frac{n^4}{8} \leq cn^4</script><p>当 $c=1/8$时,显然成立。因此$T(n)=\Theta(f(n))=\Theta(n^4)$</p><hr><p>b.&emsp;$T(n)=T(7n/10)+n$</p><p>证明：有$a=1,b=10/7,n^{log_ba}=1$，$f(n)=n=\Omega(n^{\epsilon+0})$，其中$\epsilon=1$，下面证明正则条件：$\exists c&lt;1,af(n/b)\leq cf(n)$</p><script type="math/tex; mode=display">f(7n/10)=7n/10 \leq cn</script><p>当$c=7/10$时，显然成立。因此$T(n)=\Theta(f(n))=\Theta(n)$</p><hr><p>c.&emsp;$T(n)=16T(n/4)+n^2$</p><p>证明：有$a=16,b=4,n^{log_ba}=n^2$，$f(n)=n^2=\Theta(n^2)$。</p><p>因此，$T(n)=\Theta(nlgn)$。</p><hr><p>d.&emsp;$T(n)=7T(n/3)+n^2$</p><p>证明：有$a=7,b=3,n^{log_ba}\approx n^{1.7}$，$f(n)=n^2=\Omega(n^{1.7+\epsilon})$，其中$\epsilon=0.3$，下面证明正则条件。</p><script type="math/tex; mode=display">7f(n/3)=\frac{7n^2}{9} \leq cn^2</script><p>当$c=7/9$时，显然成立。因此$T(n)=\Theta(f(n))=\Theta(n^2)$</p><hr><p>e.&emsp;$T(n)=7T(n/2)+n^2$</p><p>证明：有$a=7,b=2,n^{log_ba}\approx n^{2.8}$，$f(n)=n^2=O(n^{2.8-\epsilon})$，其中$\epsilon=0.8$。</p><p>因此$T(n)=\Theta(n^{log_ba})=\Theta(n^{log_27})$</p><hr><p>f.&emsp;$T(n)=2T(n/4)+\sqrt n$</p><p>证明：有$a=2,b=4,n^{log_ba}=n^{0.5}$，$f(n)=n^{0.5}=\Theta(n^0.5)$。<br>因此，$T(n)=\Theta(f(n)lgn)=\Theta(\sqrt{n}lgn)$</p><hr><p>g.&emsp;$T(n)=T(n-2)+n^2$</p><p>证明：</p><script type="math/tex; mode=display">T(n)=\sum_{i=0}^{n}{(2i)^2}=\frac{2n(n+1)(2n+1)}{3}+T(0) = \Theta(n^3)</script><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;4-1（递归式例子）对下列每个递归式，给出T-n-的渐进上界和渐进下界。假定-n-leq2-时T-n-时常数。给出尽量紧确的界，并验证其正确性。&quot;&gt;&lt;a href=&quot;#4-1（递归式例子）对下列每个递归式，给出T-n-的渐进上界和渐进下界。假定-n-leq2-时T
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="主方法" scheme="http://007havegone.github.io/tags/%E4%B8%BB%E6%96%B9%E6%B3%95/"/>
    
      <category term="算法分析" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>算法导论思考题2-4</title>
    <link href="http://007havegone.github.io/2019/07/30/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E6%80%9D%E8%80%83%E9%A2%982-4/"/>
    <id>http://007havegone.github.io/2019/07/30/算法导论思考题2-4/</id>
    <published>2019-07-30T09:41:22.000Z</published>
    <updated>2019-07-30T14:42:17.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思考题2-4（逆序对）-假设A-1-n-是一个有-n-个不同数的数组，若iA-j-，则对偶-i-j-称为A的一个逆序对-inversion-。"><a href="#思考题2-4（逆序对）-假设A-1-n-是一个有-n-个不同数的数组，若iA-j-，则对偶-i-j-称为A的一个逆序对-inversion-。" class="headerlink" title="思考题2-4（逆序对） 假设A[1..n]是一个有$n$个不同数的数组，若iA[j]，则对偶(i,j)称为A的一个逆序对(inversion)。"></a>思考题2-4（逆序对） 假设A[1..n]是一个有$n$个不同数的数组，若i<j且a[i]>A[j]，则对偶(i,j)称为A的一个逆序对(inversion)。</j且a[i]></h2><h3 id="a-列出数组-的5个逆序对。"><a href="#a-列出数组-的5个逆序对。" class="headerlink" title="a.列出数组$$的5个逆序对。"></a>a.列出数组$<2,3,8,6,1>$的5个逆序对。</2,3,8,6,1></h3><p>&emsp;逆序对有$(1,5),(2,5),(3,4),(3,5),(4,5)$</p><hr><h3 id="b-有集合-1-2-dots-n-中的元素构成的什么数组具有最多的逆序对？它有多少逆序对？"><a href="#b-有集合-1-2-dots-n-中的元素构成的什么数组具有最多的逆序对？它有多少逆序对？" class="headerlink" title="b.有集合$\{1,2,\dots,n\}$中的元素构成的什么数组具有最多的逆序对？它有多少逆序对？"></a>b.有集合$\{1,2,\dots,n\}$中的元素构成的什么数组具有最多的逆序对？它有多少逆序对？</h3><p>&emsp; 当数组为 $\{1,2,\dots,n\}$为逆序时，即$\{n,n-1,\dots,1\}$时逆序对最多。对于 $\forall i,j \in [1,n],(i,j)$均为逆序对。此时共有逆序对$(_n^2)=n(n-1)/2$</p><hr><p>c.插入排序的运行时间与输入数组中逆序对的数量之间是什么关系?证明你的回答。</p><p>&emsp;假设数组$A$初始时存在逆序对$(k,j)$，那么有$k<j$和$a[k]<a[j]$。在1-8行外层for循环中，每次令$key=a[j]$，$i=j-1$，在5-7行的while循环中，有$a[i]>key$，即存在一对逆序对，while循环的一次迭代，将$A[i]$后移一位，最终前$j$个元素处于有序，此时消除了前$j$个元素的逆序对。对于7-9的一次循环，相当于消除一对逆序对。因此，插入排序的运行时间和数组的逆序对之间呈线性关系。</j$和$a[k]<a[j]$。在1-8行外层for循环中，每次令$key=a[j]$，$i=j-1$，在5-7行的while循环中，有$a[i]></p><hr><p>d.给出一个确定在n个元素的任何排列中逆序对数量的算法，最坏情况需要$\Theta(nlgn)$的时间。</p><p>&emsp;对于这个问题，可以采用归并排序统计逆序对量，或者采用线段树。下面给出具体思路</p><p><strong>1、归并排序</strong></p><p>计算数组的逆序对数量，可以采用归并排序二分的思想。对于一个数组来说逆序对的来源可以分为3种情况。</p><p>对于一个数组 $A[left,right],mid=(left+right)/2$<br>(1) 两个都在左半数组，$left \leq i \leq j \leq mid，A[i] &gt; A[j]$<br>(2) 两个都在右半数组，$mid+1 \leq i \leq j \leq right,A[i] &gt; A[j]$<br>(3) 左右各一个，$left \leq i \leq mid &lt; j \leq right,A[i] &gt; A[j]$</p><p>根据上面的思路，只需要对归并排序的代码稍微改动即可。下面是我的实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InversionCount</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">总的逆序对等于左子数组的内部逆序对+右子数组的内部逆序对+来自左和右形成的逆序对</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">cnt+=MergeSort(A,l,m);<span class="comment">//第1种情况</span></span><br><span class="line">cnt+=MergeSort(A,m+<span class="number">1</span>,r);<span class="comment">//第2种情况</span></span><br><span class="line">cnt+=Merge1(A,l,m,r);<span class="comment">//第3种情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//书种归并排序采用哨兵的版本</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Merge1</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> l,<span class="keyword">int</span> m,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> inv_cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *L=<span class="keyword">new</span> <span class="keyword">int</span>[m-l+<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> *R=<span class="keyword">new</span> <span class="keyword">int</span>[r-m+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l,k=<span class="number">0</span>;i&lt;=m;)</span><br><span class="line">L[k++]=A[i++];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=m+<span class="number">1</span>,k=<span class="number">0</span>;i&lt;=r;)</span><br><span class="line">R[k++]=A[i++];</span><br><span class="line"><span class="keyword">int</span> LenA=m-l+<span class="number">1</span>;<span class="comment">//左子数组的长度</span></span><br><span class="line">L[m-l+<span class="number">1</span>]=R[r-m]=INF;<span class="comment">//设置哨兵</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=l,i=<span class="number">0</span>,j=<span class="number">0</span>;k&lt;=r;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(L[i]&lt;=R[j])<span class="comment">//i&lt;j且A[i]&lt;=A[j]，没有逆序对</span></span><br><span class="line">A[k++]=L[i++];</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//i&lt;j且A[i]&gt;A[j]</span></span><br><span class="line"><span class="keyword">if</span>(L[i]!=INF)&#123;<span class="comment">//这里有可能左侧数组先达到尾部，此时防止INF引起额外累加。</span></span><br><span class="line">                <span class="comment">//大于A[j]的数量=LenA-i(小于A[i]的数量，数组从0开始)</span></span><br><span class="line">inv_cnt+=LenA-i;</span><br><span class="line">&#125;</span><br><span class="line">A[k++]=R[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// printf("l = %d r = %d cnt = %d\n",l,r,inv_cnt);</span></span><br><span class="line"><span class="keyword">return</span> inv_cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不用哨兵处理会更方便点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Merge2</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> l,<span class="keyword">int</span> m,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *B=<span class="keyword">new</span> <span class="keyword">int</span>[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> i=l,j=m+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> inv_cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=m&amp;&amp;j&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[i]&lt;=A[j])</span><br><span class="line">B[k++]=A[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">inv_cnt+=m-i+<span class="number">1</span>;</span><br><span class="line">B[k++]=A[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=m)</span><br><span class="line">B[k++]=A[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=r)</span><br><span class="line">B[k++]=A[j++];</span><br><span class="line">k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;)</span><br><span class="line">&#123;</span><br><span class="line">A[i++]=B[k++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> inv_cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> A[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> B[]=&#123;<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> C[]=&#123;<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> D[]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; InversionCount::MergeSort(A,<span class="number">0</span>,<span class="number">7</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; InversionCount::MergeSort(B,<span class="number">0</span>,<span class="number">7</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; InversionCount::MergeSort(C,<span class="number">0</span>,<span class="number">5</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; InversionCount::MergeSort(D,<span class="number">0</span>,<span class="number">4</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2、线段树</strong></p><p>可以采用线段树来处理，这里不打算具体展开线段树的内容，后面有时间再整理一个关于线段树的专题。下面介绍算法思路。</p><p>1、为数组$A[1,n]$建立线段树，区间统计$[left,rigth]的数目，初始化均为0$，如果数据范围较大数据比较分散，可以先进行一次离散化。</p><p>2、依次对$A[1,n] \in [min,man]$的每个元素进行以下操作，假设$A[i]=k$,则对线段树查找区间$[k+1,max]$的大小，加入逆序对数量中，然后令$A[k]+1$。</p><p>上面的操作相当于遍历数组A，对于每一个元素，查找当前在它前面大于它的元素个数，然后累加起来，得到逆序对。遍历数组时间为$O(n)$，每进行一次查找操作为$O(lgn)$，总的的时间复杂度为$O(nlgn)$。</p><p>下面时代码实现，常规的线段树模板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lchild (x&lt;&lt;1) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rchild (x&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> A[N&lt;&lt;<span class="number">2</span>|<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A[x]=A[lchild]+A[rchild];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立线段树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left==right)&#123;</span><br><span class="line">A[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(left,mid,lchild);</span><br><span class="line">build(mid+<span class="number">1</span>,right,rchild);</span><br><span class="line">update(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询区间[L,R]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L&lt;=left&amp;&amp;right&lt;=R)</span><br><span class="line"><span class="keyword">return</span> A[x];</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">ret+=query(left,mid,L,R,lchild);</span><br><span class="line"><span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">ret+=query(mid+<span class="number">1</span>,right,L,R,rchild);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改 A[x]=k的结点+1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left==right)&#123;</span><br><span class="line">++A[x];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i&lt;=mid)</span><br><span class="line">modify(i,left,mid,lchild);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">modify(i,mid+<span class="number">1</span>,right,rchild);</span><br><span class="line">update(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[]=&#123;<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">build(<span class="number">1</span>,<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:arr)</span><br><span class="line">&#123;</span><br><span class="line">cnt+=query(<span class="number">1</span>,<span class="number">10</span>,i+<span class="number">1</span>,<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">modify(i,<span class="number">1</span>,<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思考题2-4（逆序对）-假设A-1-n-是一个有-n-个不同数的数组，若iA-j-，则对偶-i-j-称为A的一个逆序对-inversion-。&quot;&gt;&lt;a href=&quot;#思考题2-4（逆序对）-假设A-1-n-是一个有-n-个不同数的数组，若iA-j-，则对偶-i-j
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="排序" scheme="http://007havegone.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="逆序对" scheme="http://007havegone.github.io/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    
      <category term="线段树" scheme="http://007havegone.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法导论第二章插入排序</title>
    <link href="http://007havegone.github.io/2019/07/29/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://007havegone.github.io/2019/07/29/算法导论第二章插入排序/</id>
    <published>2019-07-29T10:00:17.000Z</published>
    <updated>2019-07-30T08:59:20.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法导论-第二章插入排序实现"><a href="#算法导论-第二章插入排序实现" class="headerlink" title="算法导论 第二章插入排序实现"></a>算法导论 第二章插入排序实现</h1><p>&emsp;插入排序算法是时间复杂度为 $O(n)$，输入规模$n$较小时，插入排序往往能有较好的效果。</p><p>&emsp;最优情况：数据整体有序，无需须交换元素，时间复杂度$O(n)$</p><p>&emsp;最坏情况：数据整体逆序，每个元素要 $1~n-1$次，时间复杂度为 $O(n^2)$。</p><p>&emsp;插入排序中的常数因子较小使得在$n$在较小的时候，在很多情况能够运行更快。作为归并排序，快速排序等算法在小规模时处理的问题时的子程序。</p><p>书中的伪代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSERTION-SORT(A)</span><br><span class="line"><span class="number">1</span> <span class="keyword">for</span> j = <span class="number">2</span> to A.length</span><br><span class="line"><span class="number">2</span> key = A[j]</span><br><span class="line"><span class="number">3</span> <span class="comment">//Insert A[j] into the sorted sequence[1..j-1]</span></span><br><span class="line"><span class="number">4</span>i = j<span class="number">-1</span></span><br><span class="line"><span class="number">5</span><span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key</span><br><span class="line"><span class="number">6</span>A[i+<span class="number">1</span>] = A[i]</span><br><span class="line"><span class="number">7</span>i = i+<span class="number">1</span></span><br><span class="line"><span class="number">8</span>A[i+<span class="number">1</span>] = key</span><br></pre></td></tr></table></figure></p><p>具体实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数组存放位置为[0,len-1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//升序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertSortInc</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len;++j)&#123;</span><br><span class="line"><span class="keyword">int</span> i=j<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> key=A[j];</span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;A[i]&gt;key)&#123;</span><br><span class="line">A[i+<span class="number">1</span>]=A[i];</span><br><span class="line">--i;</span><br><span class="line">&#125;</span><br><span class="line">A[i+<span class="number">1</span>]=key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//降序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertSortDec</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> i=j<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> key=A[j];</span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;A[i]&lt;key)&#123;</span><br><span class="line">A[i+<span class="number">1</span>]=A[i];</span><br><span class="line">--i;</span><br><span class="line">&#125;</span><br><span class="line">A[i+<span class="number">1</span>]=key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法导论-第二章插入排序实现&quot;&gt;&lt;a href=&quot;#算法导论-第二章插入排序实现&quot; class=&quot;headerlink&quot; title=&quot;算法导论 第二章插入排序实现&quot;&gt;&lt;/a&gt;算法导论 第二章插入排序实现&lt;/h1&gt;&lt;p&gt;&amp;emsp;插入排序算法是时间复杂度为 $O
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="排序" scheme="http://007havegone.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法导论思考题1-1</title>
    <link href="http://007havegone.github.io/2019/07/29/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E6%80%9D%E8%80%83%E9%A2%981-1/"/>
    <id>http://007havegone.github.io/2019/07/29/算法导论思考题1-1/</id>
    <published>2019-07-29T09:42:42.000Z</published>
    <updated>2019-07-30T08:59:25.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法导论-思考题1-1"><a href="#算法导论-思考题1-1" class="headerlink" title="算法导论-思考题1-1"></a>算法导论-思考题1-1</h1><h3 id="1-1（运行时间的比较）假设求解问题的算法需要-f-n-微秒-microseconds-，对下表中每个函数-f-n-和时间-t-可以确定在时间-t-内求解问题的最大规模-n-。"><a href="#1-1（运行时间的比较）假设求解问题的算法需要-f-n-微秒-microseconds-，对下表中每个函数-f-n-和时间-t-可以确定在时间-t-内求解问题的最大规模-n-。" class="headerlink" title="1-1（运行时间的比较）假设求解问题的算法需要 $f(n)$微秒(microseconds)，对下表中每个函数$f(n)$和时间$t$可以确定在时间$t$内求解问题的最大规模$n$。"></a>1-1（运行时间的比较）假设求解问题的算法需要 $f(n)$微秒(microseconds)，对下表中每个函数$f(n)$和时间$t$可以确定在时间$t$内求解问题的最大规模$n$。</h3><p><strong>中文版给的$f(n)$单位是毫秒，但看了原版，发现单位是微秒(microseconds)，故下面采用微秒来计算。</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">函数\时间</th><th style="text-align:center">1秒钟</th><th style="text-align:center">1分钟</th><th style="text-align:center">1小时</th><th style="text-align:center">1天</th><th style="text-align:center">1月</th><th style="text-align:center">1年</th><th style="text-align:center">1世纪</th></tr></thead><tbody><tr><td style="text-align:center">$lgn$</td><td style="text-align:center">$2^{10^6}$</td><td style="text-align:center">$2^{6\times 10^7}$</td><td style="text-align:center">$2^{3.6 \times 10^9}$</td><td style="text-align:center">$2^{8.64 \times 10^{10}}$</td><td style="text-align:center">$2^{2.592 \times 10^{12}}$</td><td style="text-align:center">$2^{3.1536 \times 10^{13}}$</td><td style="text-align:center">$2^{3.1536 \times 10^{15}}$</td></tr><tr><td style="text-align:center">$\sqrt n$</td><td style="text-align:center">$10^{12}$</td><td style="text-align:center">$3.6 \times 10^{15}$</td><td style="text-align:center">$1.296 \times10^{19}$</td><td style="text-align:center">$7.465 \times 10^{21}$</td><td style="text-align:center">$6.718 \times 10^{24}$</td><td style="text-align:center">$9.945 \times 10^{26}$</td><td style="text-align:center">$9.945 \times 10^{30}$</td></tr><tr><td style="text-align:center">$n$</td><td style="text-align:center">$10^6$</td><td style="text-align:center">$6 \times 10^7$</td><td style="text-align:center">$3.6 \times 10^9$</td><td style="text-align:center">$8.64 \times 10^{10}$</td><td style="text-align:center">$2.592 \times 10^{12}$</td><td style="text-align:center">$3.1536 \times 10^{13}$</td><td style="text-align:center">$3.1536 \times 10^{15}$</td></tr><tr><td style="text-align:center">$nlgn$</td><td style="text-align:center">$62746$</td><td style="text-align:center">$2.8 \times 10^6$</td><td style="text-align:center">$1.3 \times 10^8$</td><td style="text-align:center">$2.7 \times 10^9$</td><td style="text-align:center">$7.1 \times 10^{10}$</td><td style="text-align:center">$7.9 \times 10^{11}$</td><td style="text-align:center">$6.8 \times 10^{13}$</td></tr><tr><td style="text-align:center">$n^2$</td><td style="text-align:center">$1000$</td><td style="text-align:center">$7745$</td><td style="text-align:center">$60000$</td><td style="text-align:center">$293938$</td><td style="text-align:center">$1609968$</td><td style="text-align:center">$5615692$</td><td style="text-align:center">$56175382$</td></tr><tr><td style="text-align:center">$n^3$</td><td style="text-align:center">$100$</td><td style="text-align:center">$391$</td><td style="text-align:center">$1532$</td><td style="text-align:center">$4420$</td><td style="text-align:center">$13736$</td><td style="text-align:center">$31593$</td><td style="text-align:center">$146677$</td></tr><tr><td style="text-align:center">$2^n$</td><td style="text-align:center">$19$</td><td style="text-align:center">$25$</td><td style="text-align:center">$31$</td><td style="text-align:center">$36$</td><td style="text-align:center">$41$</td><td style="text-align:center">$44$</td><td style="text-align:center">$51$</td></tr><tr><td style="text-align:center">$n!$</td><td style="text-align:center">$9$</td><td style="text-align:center">$11$</td><td style="text-align:center">$12$</td><td style="text-align:center">$13$</td><td style="text-align:center">$15$</td><td style="text-align:center">$16$</td><td style="text-align:center">$17$</td></tr></tbody></table></div><p>$1s=10^6us$</p><p>$1min=6 \times 10^7us$</p><p>$1h=3.6 \times 10^9us$</p><p>$1D=8.64 \times 10^{10}us$</p><p>$1Mon=2.592 \times 10^{12}us$ （1个月30天）</p><p>$1Y=3.1536 \times 10^{13}us$  （365天）</p><p>$1C=3.1536 \times 10^{15}us$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法导论-思考题1-1&quot;&gt;&lt;a href=&quot;#算法导论-思考题1-1&quot; class=&quot;headerlink&quot; title=&quot;算法导论-思考题1-1&quot;&gt;&lt;/a&gt;算法导论-思考题1-1&lt;/h1&gt;&lt;h3 id=&quot;1-1（运行时间的比较）假设求解问题的算法需要-f-n-微
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>算法导论9.1-1找第二小的元素</title>
    <link href="http://007havegone.github.io/2019/07/26/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA9-1-1%E6%89%BE%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>http://007havegone.github.io/2019/07/26/算法导论9-1-1找第二小的元素/</id>
    <published>2019-07-26T13:08:35.000Z</published>
    <updated>2019-07-30T08:59:16.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法导论9-1-1找第二小的元素"><a href="#算法导论9-1-1找第二小的元素" class="headerlink" title="算法导论9.1-1找第二小的元素"></a>算法导论9.1-1找第二小的元素</h1><h2 id="1、证明：在最坏情况下，找到n个元素中第二小的元素需要-n-lceil-lgn-rceil-2-次比较。（提示：可以同时找到最小元素）"><a href="#1、证明：在最坏情况下，找到n个元素中第二小的元素需要-n-lceil-lgn-rceil-2-次比较。（提示：可以同时找到最小元素）" class="headerlink" title="1、证明：在最坏情况下，找到n个元素中第二小的元素需要 $n+ \lceil lgn  \rceil -2$次比较。（提示：可以同时找到最小元素）"></a>1、证明：在最坏情况下，找到n个元素中第二小的元素需要 $n+ \lceil lgn  \rceil -2$次比较。（提示：可以同时找到最小元素）</h2><p>做以下断言：无论采用何种比较算法，在寻找最小元素的过程中，第二小的元素一定与最小元素做过比较。<br>显然，因为第二小的元素直到遇到最小元素前，一定会胜出进入下一轮。如果最小元素没有与第二小元素相比较，则无法得出该元素是最小的关系。  </p><p>因此，要想是我们找到最小元素的比较次数最少，就需要在寻找最小元素的过程中与最小元素发生比较的次数尽量的少。  </p><p>由于每次我们只能取两个元素进行比较，从而考虑每一轮将我们比较元素两两比较，较小的元素进入下一轮（如比较元素有奇数个，落单的直接进入下一轮），这样比较所得的最小元素比较过的元素是最少的（每轮只有一个）。  </p><p>我们将比较过程转化为二叉树（以数组 [7,8,1,3,4,5,9]为例）:</p><p><img src="/2019/07/26/算法导论9-1-1找第二小的元素/二叉树.jpg" alt="二叉树"></p><h3 id="1-证明-n-1"><a href="#1-证明-n-1" class="headerlink" title="1.证明 $n-1$"></a>1.证明 $n-1$</h3><p>其中，除了叶节点外，每个结点都是一次比较的结果。因此该算法中，比较次数为树中度为2的结点数。根据二叉树的性子可以得出比较次数为 $n-1$ （二叉树：度为2的结点数=叶子叶子结点数-1）。可以看出树的每一层只有一个结点与最小元素比较，达到了下界，因此是最优的。</p><p>这里的 $n-1$ 次比较下界还有另外的思路。可以把每个元素看成一个集合。集合中用最小元素代表这个集合。初始状态下 $n$个点都是单独的集合，比较后相当于把集合做合并。合并后用最小值代表这个集合。那么初始状态下的 $n$ 个集合，至少经过 $n-1$ 次合并才能得到1个集合。  </p><h3 id="2-证明-lceil-lg-rceil-1"><a href="#2-证明-lceil-lg-rceil-1" class="headerlink" title="2.证明 $\lceil lg \rceil -1$"></a>2.证明 $\lceil lg \rceil -1$</h3><p>可以看出，与最小元素比较的次数为树高h-1（根节点的高度为1）。有因为叶节点数个数为n。从而有： $n \leq 2^{h-1}$，故有 $h-1 = \lceil lg n \rceil$,即与最小元素比较的次数至少为 $\lceil lg n \rceil$。  </p><p>从这 $\lceil lg n \rceil$个元素中找到的最小元素即是第二小的元素。最坏情况下第二小元素第一轮遇到最小元素被淘汰，从而在寻找最小元素的过程中，我们无法得到其他元素与第二小元素比较大小关系。这种情况下，要在 $\lceil lg n \rceil$个元素中找到最小元素需要 $\lceil lg n \rceil - 1$次比较。</p><p>综上：最坏情况下，要找到第二小的元素所需的比较次数为 $n + \lceil lg n\rceil -2$ 次比较。</p><h2 id="2-算法实现："><a href="#2-算法实现：" class="headerlink" title="2.算法实现："></a>2.算法实现：</h2><p>&emsp; 根据上面的解释。我们其实只要找到最小元素，然后在最小元素比较过程中比较过的元素记录下来，然后我们在这堆元素（上面证明共$\lceil lg n\rceil$个）中找最小元素即可。</p><p>&emsp;具体实现：对于每一个元素，采用数组或链表的结构，每次比较后胜出的元素记录与它比较的元素在原数组的下标，同时自身进入下一轮的比较，根据上面的图可知，每经过一轮比较，元素被筛选掉一半，直至最终仅剩一个元素时，它就是最小元素，返回与它比较元素的元素集合。最终在该集合中寻找第二小元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt;<span class="comment">//记录比较次数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        srand(time(<span class="literal">nullptr</span>));</span><br><span class="line">        for_each(vec.begin(),vec.end(),[](<span class="keyword">int</span> &amp;v)&#123;v=rand();&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSmallestAndCollection(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;* paths)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始状太全是胜者进入下一轮</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; winnerIndex(vec.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;winnerIndex.size();++i)winnerIndex[i]=i;</span><br><span class="line">        <span class="comment">//直到胜者唯一</span></span><br><span class="line">        <span class="keyword">while</span>(winnerIndex.size()!=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            winnerIndex=compareAndStore(vec,winnerIndex,paths);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> paths[winnerIndex[<span class="number">0</span>]];<span class="comment">//最终剩一个返回对于的path</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findSecondSmallest</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *paths)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> smallest2=INF;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path=Solution::findSmallestAndCollection(vec,paths);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:path)<span class="comment">//最 lgn个元素的最小值即是第二小元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vec[i]&lt;smallest2)&#123;</span><br><span class="line">            Solution::cnt++;<span class="comment">//比较次数+1</span></span><br><span class="line">            smallest2=vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> smallest2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; compareAndStore(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;winnerIndex,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;* paths)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> sz=winnerIndex.size();</span><br><span class="line">        <span class="keyword">if</span>(sz&amp;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(winnerIndex[sz<span class="number">-1</span>]);</span><br><span class="line">            --sz;</span><br><span class="line">            <span class="comment">//这里为了方便，奇数个元素时最后一个直接加入，同时数组大小-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;sz;i+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//小的加入ret进入下一轮，同时记录它的比较元素下标</span></span><br><span class="line">            <span class="keyword">if</span>(arr[winnerIndex[i]]&lt;=arr[winnerIndex[i<span class="number">-1</span>]])&#123;</span><br><span class="line">                ret.push_back(winnerIndex[i]);</span><br><span class="line">                paths[winnerIndex[i]].push_back(winnerIndex[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ret.push_back(winnerIndex[i<span class="number">-1</span>]);</span><br><span class="line">                paths[winnerIndex[i<span class="number">-1</span>]].push_back(winnerIndex[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Solution::cnt++;<span class="comment">//比较次数+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Solution::cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showTopTen</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(vec.begin(),vec.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size()&amp;&amp;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; vec[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入元素个数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; len;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(len);Solution::init(vec);<span class="comment">//产生len个随机数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *comparePath=<span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;[vec.size()];<span class="comment">//建立每个元素比较的路径</span></span><br><span class="line"><span class="keyword">int</span> smallest2=Solution::findSecondSmallest(vec,comparePath);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Second smallest element :"</span>&lt;&lt;smallest2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Compare time O(n+lgn-2) \n Std:"</span> &lt;&lt; (len+<span class="built_in">ceil</span>(<span class="built_in">log</span>(len)/<span class="built_in">log</span>(<span class="number">2</span>))<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nExtra:"</span> &lt;&lt; Solution::cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    showTopTen(vec);<span class="comment">//打印vec最小的10个元素</span></span><br><span class="line">    <span class="keyword">delete</span>[] comparePath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p>该算法主要注重比较次数，但是空间复杂度不乐观（保存比较路径），时间复杂度为 $O(n)$。适合于那种一次比较需要耗费大量时间的值。下面有两篇我解决该题参考的博客。</p><h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><p>只涉及证明：</p><p>博客1：<a href="https://blog.csdn.net/qq_33382034/article/details/53495036" target="_blank" rel="noopener">https://blog.csdn.net/qq_33382034/article/details/53495036</a>  </p><p>包括证明和算法实现（python）</p><p>博客2：<a href="http://windmissing.github.io/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/2015-12/9.1-1-second_smallest_element.html" target="_blank" rel="noopener">http://windmissing.github.io/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/2015-12/9.1-1-second_smallest_element.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法导论9-1-1找第二小的元素&quot;&gt;&lt;a href=&quot;#算法导论9-1-1找第二小的元素&quot; class=&quot;headerlink&quot; title=&quot;算法导论9.1-1找第二小的元素&quot;&gt;&lt;/a&gt;算法导论9.1-1找第二小的元素&lt;/h1&gt;&lt;h2 id=&quot;1、证明：在最坏情
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>主方法求解递归式</title>
    <link href="http://007havegone.github.io/2019/07/22/%E4%B8%BB%E6%96%B9%E6%B3%95%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E5%BC%8F/"/>
    <id>http://007havegone.github.io/2019/07/22/主方法求解递归式/</id>
    <published>2019-07-22T15:49:10.000Z</published>
    <updated>2019-07-30T08:59:09.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主方法求解递归式"><a href="#主方法求解递归式" class="headerlink" title="主方法求解递归式"></a>主方法求解递归式</h1><p>&emsp;&emsp;在分析递归的算法时，主方法可以较快的计算出算法的时间复杂度<br>主方法可以用于满足以下形式的递归式。</p><script type="math/tex; mode=display">T(n)=aT(n/b)+f(n)</script><p>其中$a\geq1和b&gt;1$是常数，$f(n)$是渐进函数。<br>&emsp;&emsp;主方法描述的算法：将原本规模为$n$的问题，分解为 $a$ 个规模为 $n/b$ 的子问题，其中 $a,b\in \mathbb{Z^+}$，函数 $f(n)$ 包含了问题分解和子问题合并的代价。</p><p>下面是归并排序的递归式:</p><script type="math/tex; mode=display">T(n)=\begin{cases}\Theta(1) & 若n=1 \\2T(n/2)+\Theta(n) & 若n>1 \\\end{cases}</script><p>其中，$a=2, b=2, f(n)=\Theta(n^2)。$<br>&emsp;&emsp;在具体处理过程中,会遇到 $n/b$ 可能不是整数的情况。可以将 $a$ 项 $T(n/b)$全都替换为$T(\lfloor n/b \rfloor)或T(\lceil n/b\rceil)$ 并不会影响递归式的渐进性质。</p><hr><h3 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h3><p>主定理：$a\geq1和b&gt;1$是常数，$f(n)$是一个函数，$T(n)$是定义在非负整数上的递归式:</p><script type="math/tex; mode=display">T(n)=aT(n/b)+f(n)</script><p>其中将 $n/b$ 解释为$\lfloor n/b \rfloor或\lceil n/b\rceil$。那么$T(n)$有如下渐近界：</p><p> 1.若对某个常数 $\epsilon &gt;0$有 $f(n)= O(n^{log_ba-\epsilon})$ ,则 $T(n)=\Theta(n^{log_ba})。$</p><p> 2.若$f(n)=\Theta(n^{log_ba})$，则 $T(n)=\Theta(n^{log_ba} lgn)$</p><p> 3.若对某个常数$\epsilon&gt;0$ 有 $f(n)=\Omega(n^{log_ba+\epsilon})$，且对某个常数 $c&lt;1$ 和所有足够大的 $n$ 有 $af(n/b)\leq cf(n)$，则 $T(n)=\Theta(f(n))$。 </p><p>&emsp;&emsp;实际上就是将函数 $f(n)$ 和函数 $n^{log_ba}$ 进行比较。如情况1和情况3，两者的较大者决定了递归式的解。对于情况2，则再乘上一个对数因子 $lgn$ ，解为 $T(n)=\Theta(n^{loa_ba}  lgn)=\Theta(f(n) lgn)$。</p><p><strong>注意:</strong> 对于第1种情况和第3种情况的 $\mathbf{f(n)}$ 渐进小于和渐进大于 $\mathbf{n^{log_ba}}$，其中相差一个因子 $n^\epsilon$，其中 $\epsilon$为大于0的常数，即要满足 <strong>多项式的差距</strong>。同时第三种情况还要满足 “正则”条件 $af(n/b)\leq cf(n)$。</p><p><strong>这三种情况未覆盖 $f(n)$ 的所有可能性。</strong> 即 $f(n)$ 不满足多项式级别的渐进小于 $n^{log_ba}$而处于情况1和情况2之间。同理，不满足 $f(n)$ 渐进大于而处于 $n^{log_ba}$ 而处于情况2和情况2之间，或则情况3而不满足正则条件，均不能使用主方法求解递归式。</p><hr><h3 id="主方法使用例子"><a href="#主方法使用例子" class="headerlink" title="主方法使用例子"></a>主方法使用例子</h3><p>1、</p><script type="math/tex; mode=display">T(n)=9T(n/3)+ n</script><p>其中 $a=9,b=3,f(n)=n$。很容易求解 $n^{log_ba}=n^2=\Theta(n^2)$。<br>有$f(n)=n= O( n^{log_ba-\epsilon})$，其中$\epsilon=1$，故满足情况1，因此得出$T(n)=\Theta(n^2)$。</p><p>2、</p><script type="math/tex; mode=display">T(n)=T(2n/3)+1</script><p>其中 $a=1,b=3/2,f(n)=1$。$n^{log_ba}=n^{log_{3/2}1}=\Theta(1)$。<br>有$f(n)=\Theta(n^{log_ba})=\Theta(1)$。因此满足情况2，则 $T(n)=\Theta(n^{log_ba} lgn)=\Theta(lgn)$。</p><p>3、</p><script type="math/tex; mode=display">T(n)=3T(n/4)+nlgn</script><p>其中 $a=3,b=4,f(n)=nlgn$。$n^{log_ba}=n^{log_43}= O(n^{0.793})$。由于$f(n)=\Omega(n^{log_43+\epsilon})$，其中$\epsilon\approx0.2$。<br>接下来证明正则条件，即</p><script type="math/tex; mode=display">\begin{aligned}af(n/b) & \leq cf(n) \\ 3(n/4)lg(n/4) & \leq  cnlgn\\ \end{aligned}</script><p>显然，当$c=3/4$时，不等式成立。<br>故$T(n)=\Theta(f(n))=\Theta(nlgn)$</p><p>下面这个递归式不能运用主方法<br>4、</p><script type="math/tex; mode=display">T(n)=2T(n/2)+nlgn</script><p>其中 $a=2,b=2,f(n)=nlgn$，$n^{log_ba}=\Theta(n)$，<br>可能会得到错误的结论有：$f(n)=\Omega(n^{log_22+\epsilon})$。然后继续求解下去。<br>实际上，不满足之前提到的情况1和情况3的渐进差距需要时多项式级别的。<br>即：</p><script type="math/tex; mode=display">\frac{nlgn} {n^{log_22}}=\frac {nlgn} {n} = lgn = O(n^\epsilon)</script><blockquote><p>这里的 $\mathbf{\omicron}$ 符号代表非渐进紧确的上界，<br>如：$f(n)=\omicron(g(n))$: $\forall c&gt;0$，$\exists$常量$n_0&gt;0$，使得 $\forall n\geq n_0$，有 $0 \leq f(n) \leq cg(n)$。简单理解小于但不等于。</p></blockquote><p>即不满足多项式级别的大于。故处于情况2和情况3之间。不可以采用主方法求解。</p><h3 id="练习题4-5-1：-建议自己动手做完后对照。"><a href="#练习题4-5-1：-建议自己动手做完后对照。" class="headerlink" title="练习题4.5-1： 建议自己动手做完后对照。"></a>练习题4.5-1： 建议自己动手做完后对照。</h3><p>a.</p><script type="math/tex; mode=display">T(n)=2T(n/4)+1</script><p>其中$a=2,b=4,f(n)=1$, $n^{log_ba}= \sqrt n$。<br>有 $f(n) = O(n^{log_ba-\epsilon}) = O(n^{0.5-\epsilon})$，其中$\epsilon = 0.5$。<br>故 $T(n) = \Theta(n^{log_42}) = \Theta(\sqrt n)$</p><hr><p>b.</p><script type="math/tex; mode=display">T(n)=2T(n/4)+\sqrt{n}</script><p>同上,可以求出 $n^{log_ba}$，由于 $f(n) = \sqrt n =\Theta(\sqrt n) = \Theta(n^{log_42})$<br>故$T(n) = \Theta( f(n)lgn) = \Theta(\sqrt n  lgn)$</p><hr><p>c.</p><script type="math/tex; mode=display">T(n)=2T(n/4)+n</script><p>同上，求出 $n^{log_ba}$，由于 $f(n) = \Omega(n^{0.5 + \epsilon})$, 其中 $\epsilon =0.5$。接下来证明正则条件：</p><script type="math/tex; mode=display">\begin{aligned}af(n/b)  & \leq c f(n)\\2(n/4)    & \leq c \ n\\\frac 1 2  & \leq c\end{aligned}</script><p>显然，取 $c = \frac 1 2$时，满足条件。故 $T(n) = \Theta(f(n)) = \Theta(n)$</p><hr><p>d.</p><script type="math/tex; mode=display">T(n)=2T(n/4)+n^2</script><p>同上，求出 $n^{log_ba}$，由于 $f(n) =  n^2 = \Omega(n^{logb_a+\epsilon})$，其中 $\epsilon = 1.5$。下面证明正则条件：</p><script type="math/tex; mode=display">\begin{aligned}a f(n/b) & \leq c f(n) \\2 (n/4)^2 & \leq c \ n^2 \\n^2/8 & \leq c \ n^2\end{aligned}</script><p>显然，取 $c = 1/8$ 时，满足条件。故 $T(n) = \Theta( f(n) ) = \Theta(n^2)$。</p><p><strong>参考文献：算法导论</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;主方法求解递归式&quot;&gt;&lt;a href=&quot;#主方法求解递归式&quot; class=&quot;headerlink&quot; title=&quot;主方法求解递归式&quot;&gt;&lt;/a&gt;主方法求解递归式&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在分析递归的算法时，主方法可以较快的计算出算法的时间复杂度&lt;br&gt;主
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="主方法" scheme="http://007havegone.github.io/tags/%E4%B8%BB%E6%96%B9%E6%B3%95/"/>
    
      <category term="时间复杂度" scheme="http://007havegone.github.io/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
      <category term="算法分析" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Effective c++ 读书笔记第一章</title>
    <link href="http://007havegone.github.io/2019/07/13/Effective-c-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>http://007havegone.github.io/2019/07/13/Effective-c-读书笔记第一章/</id>
    <published>2019-07-13T14:28:44.000Z</published>
    <updated>2019-07-30T08:59:00.318Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><h1 id="Ⅰ、-让自习惯C"><a href="#Ⅰ、-让自习惯C" class="headerlink" title="Ⅰ、 让自习惯C++"></a>Ⅰ、 让自习惯C++</h1><p><br></p><h2 id="条款01：视C-为一个语言连邦"><a href="#条款01：视C-为一个语言连邦" class="headerlink" title="条款01：视C++为一个语言连邦"></a>条款01：视C++为一个语言连邦</h2><hr><p>C++是一个多重泛型编程语言，同时支持过程形式、面向对象形式、泛型形式、元编程形式的语言。</p><p>将C++是为一个联邦,主要的此语言为4个：</p><p>1.procedural-based C。C语言的面向过程<br>2.Object-Oriented C++。面向对象<br>3.Template C++。 C++ 的泛型 (generics) 编程和由 template 的强大功能带来 template   metaprogramming (TMP,模板元编程)<br>4.STL。template程序库，主要包括 容器、迭代器、算法以及函数对象</p><p><strong>tips:编程过程中在前面3个次语言之间切换时，可能导致高效编程守则要求的改变</strong></p><p><br></p><h2 id="条款02-尽量以-const-enum-inline-替换-define"><a href="#条款02-尽量以-const-enum-inline-替换-define" class="headerlink" title="条款02:尽量以 const, enum, inline 替换 #define"></a>条款02:尽量以 const, enum, inline 替换 #define</h2><hr><h3 id="2-1、采用const替换-define"><a href="#2-1、采用const替换-define" class="headerlink" title="2.1、采用const替换#define"></a>2.1、采用const替换#define</h3><p>此处用宏定义一个常量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure><p>记号名称ASPECT_RATIO可能未被登记到记录表(symbol table), 因为可能在编译前的预处理阶段被替换。<br>导致发生错误时不容易追踪该信息。</p><p>采用常量替换:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span> <span class="comment">//大写名称通常用于宏，此处改变名称写法</span></span><br></pre></td></tr></table></figure><p>常量定义式通常放在头文件</p><p>定义一个常量的 <code>char*based</code>字符串（不可改变指向不可改变内容）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> autorName = <span class="string">"Scott Meyers"</span>; </span><br><span class="line"><span class="comment">//根据c++ primer观点，第一个const为底层const,保证指针指向内容不变</span></span><br><span class="line"><span class="comment">//第二个const为顶层const,保证指针指向地址不变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//采用string</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">autoirName</span><span class="params">(<span class="string">"Scott Meyers"</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>定义一个class的专属常量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns = <span class="number">5</span>; <span class="comment">//这里只是常量声明式，声明式，声明式</span></span><br><span class="line"><span class="keyword">int</span> scores[NumTurns];   <span class="comment">//使用它</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;C++中 class专属常量又是static且为整数类型(eg: int,char,bool).需要特殊处理，如果未取地址，可以只声明，否则需要另外提供定义式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NumTurns;<span class="comment">//类内已经初始化赋值，无须也无法重新赋值。</span></span><br></pre></td></tr></table></figure><p>#define无法为一个 class 定义一个专属变量，因为 #define 并不重视作用域。<br>也就是不存在所谓的 private #define</p><h3 id="2-2、采用enum替换-define"><a href="#2-2、采用enum替换-define" class="headerlink" title="2.2、采用enum替换#define"></a>2.2、采用enum替换#define</h3><p>&emsp;&emsp;旧式编译器不支持 static 成员在声明式上获得初值，”in class” 初值设定也只允许对整数常量进行。<br>此时，需要将初值放在定义式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CostEstimate</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> FudgeFactor;<span class="comment">//static class 常量声明</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span></span><br><span class="line">CostEstimate::FudgeFactor = <span class="number">1.35</span>;<span class="comment">//位于实现文件内</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;类内的数组声明式，编译器坚持必须在编译期间知道数组的大小。如果编译器不允许 “static 整数型class常量” 完成 “in class”初值设定，可改用所谓的 “the enum hack” 补偿做法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span>&#125;;<span class="comment">//"the enum hack"</span></span><br><span class="line"><span class="comment">//令 NumTurns成为5的一个记号名称</span></span><br><span class="line"><span class="keyword">int</span> socres[NumTurns];</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：enum不能取地址</strong></p><h3 id="2-3、采用-template替换-define"><a href="#2-3、采用-template替换-define" class="headerlink" title="2.3、采用 template替换 #define"></a>2.3、采用 template替换 #define</h3><p>另一个常见的 #define 误用情况是以它实现宏（macros）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用宏比较a和b的较大值来调用f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a,b) f(a)&gt;f(b) ? (a) : (b) )</span></span><br></pre></td></tr></table></figure><p>缺点： 要为实参添加小括号防止错误，还有一些不容易发现的错误</p><p>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>,b = <span class="number">0</span>;</span><br><span class="line">CALL_WITH_MAX(++a, b);<span class="comment">//a被累加了两次</span></span><br><span class="line">CALL_WITH_MAX(++a, b+<span class="number">10</span>);<span class="comment">//a被累加了一次</span></span><br></pre></td></tr></table></figure><p>采用template函数替代</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T&amp; a,<span class="keyword">const</span> T&amp; b)</span></span>&#123;<span class="comment">//采用 pass by reference-to-const</span></span><br><span class="line"><span class="comment">//可以传递所有类型.</span></span><br><span class="line">f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h2><hr><h3 id="3-1、const成员函数"><a href="#3-1、const成员函数" class="headerlink" title="3.1、const成员函数"></a>3.1、const成员函数</h3><p>目的：  </p><p>1.使<code>class</code>接口比较容易被理解，那些可以改动，那些不行<br>2.使“操作<code>const</code>对象”称为可能。<code>pass-by-reference-to-const</code>方式传递对象。</p><p><strong><code>const</code>函数可被重载</strong><br>1.<code>const</code>对象只能调用 const版本<br>2.<code>non-const</code>对象可以调用 <code>const</code>和<code>non-const</code>版本，默认为<code>non-const</code>版本。</p><h3 id="3-2、bitwise-constness-和-logical-constness"><a href="#3-2、bitwise-constness-和-logical-constness" class="headerlink" title="3.2、bitwise constness 和 logical constness"></a>3.2、bitwise constness 和 logical constness</h3><blockquote><p>1、<code>bitwise const</code>阵营的人相信，成员函数只有在不改变对象的任何成员变量(static除外)时<br>才可以说是 <code>const</code>。即不改变对象内的任何一个 bit 。<br>这种论点好处是很容易侦测违反点。<br><code>bitwise constness</code>正是 C++ 对常量性的定义，因此 const 成员函数不可以更改对象内的<br>任何<code>non-static</code>成员变量。</p></blockquote><p>不幸的是很多不具备<code>const</code>性质的函数却可以通过 <code>bitwise</code>测试。<br>实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span><span class="comment">//bit const声明</span></span><br><span class="line">&#123; <span class="keyword">return</span> pText[position]; &#125;<span class="comment">//但实际没起到效果</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span>* pText;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//此时</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> CTextBlock <span class="title">cctb</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;<span class="comment">//声明一个常量对象</span></span><br><span class="line"><span class="keyword">char</span> *pc = &amp;cctb[<span class="number">0</span>];</span><br><span class="line">*pc = <span class="string">'J'</span>;<span class="comment">//此时cctb变为 “Jello”</span></span><br></pre></td></tr></table></figure><blockquote><p>2、这种情况导出了所谓的<code>logical constness</code>。他们主张，一个 <code>const</code>成员函数<br>可以修改它所处理的对象内的某些 bits, 但只有在客户端侦测不出的情况下才得如此。  </p></blockquote><p>例如： CTextBlock class有可能高速缓存文本区域的长度以便询问：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> length() <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> *pText;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> textLength;<span class="comment">//最近一次计算的文本区域长度</span></span><br><span class="line"><span class="keyword">bool</span> lengthIsValid;<span class="comment">//当前长度是否有效</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> CTextBlock::length() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!lengthIsValid)&#123;</span><br><span class="line">textLength = <span class="built_in">std</span>::<span class="built_in">strlen</span>(pText);<span class="comment">//error!!! const函数内</span></span><br><span class="line">lengthIsValid = <span class="literal">true</span>;<span class="comment">//不允许修改类成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案 <code>mutable</code>释放 <code>non-static</code>成员变量的<code>bitwise constness</code>约束</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> length() <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> *pText;</span><br><span class="line"><span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> textLength;<span class="comment">//mutable可能总是会被更改，</span></span><br><span class="line"><span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid;<span class="comment">//即使在const函数内</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> CTextBlock::length() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!lengthIsValid)&#123;</span><br><span class="line">textLength = <span class="built_in">std</span>::<span class="built_in">strlen</span>(pText);<span class="comment">//现在valid</span></span><br><span class="line">lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3、在-const-和-non-const-成员函数中避免重复"><a href="#3-3、在-const-和-non-const-成员函数中避免重复" class="headerlink" title="3.3、在 const 和 non-const 成员函数中避免重复"></a>3.3、在 const 和 non-const 成员函数中避免重复</h3><p>假设TextBlock的 operator[] 不单单返回一个 reference，还要做各种检测，<br>这样会导致写出的 const 和 non-const operator[] 冗余。</p><p><strong>解决方案 令 non-const版本调用 const版本</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span> <span class="comment">//一如既往</span></span><br><span class="line">&#123; ...</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line"> <span class="keyword">return</span> text[position];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position)<span class="comment">//调用 const版本</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&gt;&amp;(<span class="comment">//将op[]返回值的const转除</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)<span class="comment">//为*this加上const</span></span><br><span class="line">[position];<span class="comment">//调用 const op[];</span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：反向操作将 const函数调用 non-const是不可取的</strong></p><p><br></p><h2 id="条款04：确定对象使用前已被初始化"><a href="#条款04：确定对象使用前已被初始化" class="headerlink" title="条款04：确定对象使用前已被初始化"></a>条款04：确定对象使用前已被初始化</h2><p>定义类Point</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Point p;<span class="comment">//p成员变量有时候会被初始化（为0），有时候不会</span></span><br></pre></td></tr></table></figure><p>1.使用 C part of C++ 而且初始化可能招致运行期成本，那么不保证初始化<br>2.non-C parts of C++,则有所变化，如 vector（STL part of C++）保证初始化,<br> array（C part of C++) 不保证内容初始化。</p><p><strong>最佳处理办法</strong>： 永远在使用对象前先将其初始化。对于无任何成员的内置类型，你必须手工完成此事。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;<span class="comment">//对int初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* text = <span class="string">"A C-style string//对指针初始化</span></span><br><span class="line"><span class="string">double d;</span></span><br><span class="line"><span class="string">std::cin &gt;&gt; d;//调用输入流初始化</span></span><br></pre></td></tr></table></figure><h3 id="4-1、区分赋值和初始化"><a href="#4-1、区分赋值和初始化" class="headerlink" title="4.1、区分赋值和初始化"></a>4.1、区分赋值和初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> &#123;</span> ...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ABEntry</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; address,  <span class="comment">//构造函数</span></span><br><span class="line"> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt;&amp; phones);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> theName;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> theAddress;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt; thePhones;</span><br><span class="line"><span class="keyword">int</span> numTimesConsulted;</span><br><span class="line">&#125;;</span><br><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; address,  </span><br><span class="line"> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">&#123;</span><br><span class="line">theName = name;<span class="comment">//这些都是赋值</span></span><br><span class="line">theAddress = address;<span class="comment">//而非初始化</span></span><br><span class="line">thePhone = phones;</span><br><span class="line">numTimesConsulted = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对象的初始化发生在进入构造函数之前，故以上的 theName, theAddress 和 thePhones均不是初始化，而是赋值。初始化发生在某些对象的default构造函数调用时，此时未进入ABEntry构造函数体，而对于 numTimesConsulted这类内置类型，赋值动作的时间点不确定。</p><p>采用 <strong>member initialization list (成员初值列）</strong>来为对象的成员初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; address,  </span><br><span class="line"> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">:theName(name),<span class="comment">//此处均为初始化，如果</span></span><br><span class="line"> theAddress(address),<span class="comment">//类成员没有在指定，编译器</span></span><br><span class="line"> thePhones(phones),<span class="comment">//调用默认构造函数</span></span><br><span class="line"> numTimesCosulted(<span class="number">0</span>)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>如果成员变量为 <code>const 或 references</code>，则一定需要初值，不能被赋值。</p><p><strong>C++成员初始化次序</strong><br>base classes 更早由于其 drived classes 被初始化，而 class 的成员变量按照成员声明次序被初始化</p><h3 id="4-2、不同编译单元内定义的-non-local-static-对象的初始化次序"><a href="#4-2、不同编译单元内定义的-non-local-static-对象的初始化次序" class="headerlink" title="4.2、不同编译单元内定义的 non-local static 对象的初始化次序"></a>4.2、不同编译单元内定义的 non-local static 对象的初始化次序</h3><p><strong>local static对象</strong>： 寿命从构造直至程序结束为止，因此不包括 <code>stack</code>和<code>heap-based对象</code>。这种对象包括 <code>global</code>对象 、定义于<code>namespace</code>作用域内的对象、在<code>classed</code>内、在函数内、以及在 file作域内被声明为 <code>static</code>的对象。<br>函数内的 <code>static</code>对象称为为 <code>local static</code>对象(它们相对函数而言为 <code>local</code>)，其他 <code>static</code>对象称为 <code>non-local static</code>对象。它们的析构函数会在 <code>main()</code>结束时自动调用。</p><p><strong>编译单源</strong>：是指产出单一目标文件的那些源码。基本上它是单一源码文件加上其所含的头文件。</p><p>问题在于<strong>C++对于定义于不同编译单元内的 <code>non-local static</code>对象的初始化次序并无明确定义</strong></p><p>实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span>&#123;</span><span class="comment">//编译单元A</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> numDisk() <span class="keyword">const</span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;<span class="comment">//预备给用户使用的对象</span></span><br><span class="line"><span class="comment">/*----------------------------------------------------------*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Directory( params); <span class="comment">//编译单元B</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directory( params)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs.numDisks();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设，采用 创建一个 Driectory对象  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Directory <span class="title">tempDir</span><span class="params">( params)</span></span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时 tempDir构造函数调用了 dfs函数对象，故 dfs必须先于 tempDir初始化，否则后果很严重。以下是解决方案：</p><p><strong>采用 <code>local static</code>对象替换 <code>non-local static</code>对象</strong><br><strong>这是 <code>Singleton</code>模式的一个常见手法</strong></p><p>这个手法基础在于：C++保证,函数内的<code>local static</code>对象会在“该函数被调用期间”<br>“首次遇上该对象的定义式”时被初始化。如果函数从未调用，则不会生成对象，<br>也免去了多余的构造函数析构函数的调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span>&#123;</span>...&#125;;<span class="comment">//同前</span></span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span><span class="comment">//定义一个local static对象 </span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//返回一个reference</span></span><br><span class="line"><span class="keyword">static</span> FileSystem fs;</span><br><span class="line"><span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span>&#123;</span>...&#125;;<span class="comment">//同前</span></span><br><span class="line">Directory::Directory( params)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> disk = tfs().numDisks();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span><span class="comment">//同前,返回一个 reference to tfs</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> Directory td;</span><br><span class="line"><span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以上的 <code>reference-returing</code></strong>函数往往十分单纯：定义并初始化一个<code>local static</code>，然后返回它。</p><p><strong>注意：这些内含 <code>static</code>对象的事实使他们在多线程有不确定性。任何一种 <code>non-const static</code>对象，无论是<code>local</code>还是<code>non-local</code>，多线程环境下的等待某事发生都会有麻烦。</strong></p><p><strong>解决方案：在程序单线程启动阶段手工调用所有reference-returing函数，可以消除与初始化有关的“竞速形势”。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&quot;Ⅰ、-让自习惯C&quot;&gt;&lt;a href=&quot;#Ⅰ、-让自习惯C&quot; class=&quot;headerlink&quot; title=&quot;Ⅰ、 让自习惯C++&quot;&gt;&lt;/a&gt;Ⅰ、 让自习惯C++&lt;/h1&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;条款01：视C-为一个语言
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://007havegone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://007havegone.github.io/tags/C/"/>
    
      <category term="Effective C++" scheme="http://007havegone.github.io/tags/Effective-C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://007havegone.github.io/2019/07/13/hello-world/"/>
    <id>http://007havegone.github.io/2019/07/13/hello-world/</id>
    <published>2019-07-12T16:00:00.000Z</published>
    <updated>2019-07-13T12:11:52.535Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
