<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://007havegone.github.io/"/>
  <updated>2019-08-03T09:38:55.804Z</updated>
  <id>http://007havegone.github.io/</id>
  
  <author>
    <name>007havegone</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法导论思考题9-2</title>
    <link href="http://007havegone.github.io/2019/08/02/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E6%80%9D%E8%80%83%E9%A2%989-2/"/>
    <id>http://007havegone.github.io/2019/08/02/算法导论思考题9-2/</id>
    <published>2019-08-01T16:13:03.000Z</published>
    <updated>2019-08-03T09:38:55.804Z</updated>
    
    <content type="html"><![CDATA[<h3 id="9-2-emsp-带权中位数-对分别具体以正权重-w-1-w-2-dotsb-w-n-且满足-sum-i-1-n-w-i-1-的-n-个互异的元素-x-1-x-2-dotsb-x-n-来说，带权中位数-x-k-较小中位数-是满足如下条件的元素："><a href="#9-2-emsp-带权中位数-对分别具体以正权重-w-1-w-2-dotsb-w-n-且满足-sum-i-1-n-w-i-1-的-n-个互异的元素-x-1-x-2-dotsb-x-n-来说，带权中位数-x-k-较小中位数-是满足如下条件的元素：" class="headerlink" title="9-2&emsp;(带权中位数)对分别具体以正权重$w_1,w_2,\dotsb,w_n$,且满足$\sum_{i=1}^{n}{w_i=1}$的$n$个互异的元素$x_1,x_2,\dotsb,x_n$来说，带权中位数$x_k$(较小中位数)是满足如下条件的元素："></a>9-2&emsp;(带权中位数)对分别具体以正权重$w_1,w_2,\dotsb,w_n$,且满足$\sum_{i=1}^{n}{w_i=1}$的$n$个互异的元素$x_1,x_2,\dotsb,x_n$来说，带权中位数$x_k$(较小中位数)是满足如下条件的元素：</h3><script type="math/tex; mode=display">\sum_{x_i < x_k}w_i <\frac{1}{2} \quad和\quad\sum_{x_i > x_k}w_i \leq \frac{1}{2}</script><p>例如，如果元素是$0.1  ,0.35  ,0.05  ,0.1  ,0.15  ,0.05  ,0.2$，并且每个元素的权重等于本身(即对所有$i=1,2,\dotsb,7都有w_i=x_i$)，那么中位数是0.1，而带全中位数是0.2。</p><h3 id="a-emsp-证明：如果对所有-i-1-2-dotsb-n-都有-w-i-1-n-，那么-x-1-x-2-dotsb-x-n-的中位数就是-x-i-的带权中位数。"><a href="#a-emsp-证明：如果对所有-i-1-2-dotsb-n-都有-w-i-1-n-，那么-x-1-x-2-dotsb-x-n-的中位数就是-x-i-的带权中位数。" class="headerlink" title="a.&emsp; 证明：如果对所有$i=1,2,\dotsb,n$都有$w_i=1/n$，那么$x_1,x_2,\dotsb,x_n$的中位数就是$x_i$的带权中位数。"></a>a.&emsp; 证明：如果对所有$i=1,2,\dotsb,n$都有$w_i=1/n$，那么$x_1,x_2,\dotsb,x_n$的中位数就是$x_i$的带权中位数。</h3><p>证明：$x_i,x_2,\dotsb,n$的中位数（<strong>题目给的是低中位数</strong>）是$x_k=x$那么就有：</p><script type="math/tex; mode=display">\begin{aligned}    |\{x_i| 1 \leq i \leq n,x_i < x\}| &< n/2 \\    |\{x_i| 1 \leq i \leq n,x_i > x\}| &\leq n/2\end{aligned}</script><p>这里解释下:</p><p>第1个式子是小于中位数的个数，因为是低中位数，无论集合是奇数偶数个都是小于$n/2$；</p><p>第2个式子是大于中位数的个数，当集合个数是奇数是，也是小于$n/2$，当集合个数为偶数时，等号成立。</p><p>同时因为每一个元素的权值都是置为$1/n$，那么就有：</p><script type="math/tex; mode=display">\begin{aligned}    \sum_{x_i<x}{w_i} &= \sum_{x_i<x}{\frac{1}{n}}  \\                      &= \frac{1}{n}·\sum_{x_i<x}1  \\                      &= \frac{1}{n}·|\{x_i| 1 \leq i \leq n,x_i <x\}|  \\                      &< \frac{1}{n} · \frac{n}{2}  \\                      &= \frac{1}{2}\end{aligned}</script><p>满足带权中位数的第一个条件。同理，我们有：</p><script type="math/tex; mode=display">\begin{aligned}    \sum_{x_i>x}{w_i} &= \sum_{x_i>x}{\frac{1}{n}}  \\                      &= \frac{1}{n}·\sum_{x_i>x}1  \\                      &= \frac{1}{n}·|\{x_i| 1 \leq i \leq n,x_i > x\}| \\                      &\leq \frac{1}{n}·\frac{n}{2} \\                      &=\frac{1}{2}\end{aligned}</script><p>第二个条件得证。因此当集合X的每个元素的权重都是$1/n$时，$x_1,x_2,\dotsb,x_n$的中位数$x_k=x$，同时也是带权中位数。</p><hr><h3 id="b-emsp-利用排序，设计一个最坏情况下-O-nlgn-时间的算法，可以得到-n-个元素的带权中位数。"><a href="#b-emsp-利用排序，设计一个最坏情况下-O-nlgn-时间的算法，可以得到-n-个元素的带权中位数。" class="headerlink" title="b.&emsp; 利用排序，设计一个最坏情况下$O(nlgn)$时间的算法，可以得到$n$个元素的带权中位数。"></a>b.&emsp; 利用排序，设计一个最坏情况下$O(nlgn)$时间的算法，可以得到$n$个元素的带权中位数。</h3><p><strong>Step1</strong>、可以对元素$x_1,x_2,\dotsb,x_n$采用归并排序或者堆排序算法来升序排序。</p><p><strong>Step2</strong>、然后从最小$x_1$开始，从左往右遍历每一个，将权值累加起来，当权值超过$1/2$，那么最后一个导致超过$1/2$的元素就是带权中位数。</p><p>Step1时间复杂度为$O(nlgn)$，Step2时间复杂度为$O(n)$。满足题目要求。</p><hr><h3 id="c-emsp-说明如何利用像9-3节的SELECT这样的线性时间中位数算法，在-Theta-n-最坏情况时间内求出带权中位数。"><a href="#c-emsp-说明如何利用像9-3节的SELECT这样的线性时间中位数算法，在-Theta-n-最坏情况时间内求出带权中位数。" class="headerlink" title="c.&emsp;说明如何利用像9.3节的SELECT这样的线性时间中位数算法，在$\Theta(n)$最坏情况时间内求出带权中位数。"></a>c.&emsp;说明如何利用像9.3节的SELECT这样的线性时间中位数算法，在$\Theta(n)$最坏情况时间内求出带权中位数。</h3><p>线性时间查找带权中位数的思想是二分查找。算法工作流程如下:</p><p>1、问题规模$n \leq 2$，可以在$O(1)$情况下暴力解决。</p><p>2、问题规模$n &gt; 2$时，我们先找到集合$X$的中位数$x_k =x$，将集合$X$用$x_k$划分为两个集合，下面称为$L=\{x_i|1 \leq i \leq n,x_i &lt; x\}$和$G=\{x_i|1 \leq i \leq n,x_i &gt;x\}$,然后计算$W_L$和$W_G$（两部分的权重）。根据$W_G$和$W_G$的权重情况，可以分为3种情况处理：</p><script type="math/tex; mode=display">\begin{cases}   a、 x_k即为带权中位数 &    W_L < 1/2 \ and \ W_G <1/2   \\   b、 在集合L中查找     &          W_L>1/2             \\   c、 在集合G中查找     &          W_G>1/2   \end{cases}</script><p>在处理b、c情况时，我们为了避免下一次划分时重复计算$W_L$和$W_G$，对于情况b：我们可以将$w_k=w_k+W_G$，然后将$x_k$加入下一步要进行查找的集合$L$中。</p><p>下面时该算法的伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">WEIGHTED-MEDIUM(X)</span><br><span class="line">    <span class="comment">//规模小于等于2，O(1)解决</span></span><br><span class="line">    <span class="keyword">if</span> X.size = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x[<span class="number">1</span>]</span><br><span class="line">    elseif x.size = <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> w[<span class="number">1</span>]&gt;=w[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">return</span> x1</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> x2</span><br><span class="line">    <span class="comment">//规模 &gt;2，取中位数，二分递归进行</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        find the Medium x[k] in X[<span class="number">1</span>,..,n]</span><br><span class="line">        partition the <span class="built_in">set</span> X by x[k] into L,G</span><br><span class="line">        computer WL=sum of w[i] in the <span class="built_in">set</span> L</span><br><span class="line">                 WG=sum of w[i] in the <span class="built_in">set</span> G</span><br><span class="line">        <span class="keyword">if</span> WL&lt;<span class="number">1</span>/<span class="number">2</span> <span class="keyword">and</span> WG &lt; <span class="number">1</span>/<span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> x[k]</span><br><span class="line">        elseif WL &gt; <span class="number">1</span>/<span class="number">2</span></span><br><span class="line">            w[k]=w[k]+WG</span><br><span class="line">            X'&lt;--&#123;x[i] in X | x[i] &lt;= x[k]&#125;</span><br><span class="line">            <span class="keyword">return</span> WEIGHT-MEDIUM(X')</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            w[k]=w[k]+WL</span><br><span class="line">            X'&lt;--&#123;x[i] in X | x[i] &gt;= x[k]&#125;</span><br><span class="line">            <span class="keyword">return</span> WEIGHTED-MEDIUM(X')</span><br></pre></td></tr></table></figure><p><strong>算法分析</strong>：在对数组的每一次递归过程中，取中位数$x_k$，划分集合X和计算$W_L,W_R$的时间复杂度均为$O(n)$。最差情况下满足以下递归式：</p><script type="math/tex; mode=display">    T(n)=T(n/2+1)+\Theta(n)</script><p>下一次递归，划分的集合是原来的一半元素，同时还有$x_k$，因此为$T(2n+1)$。<br>这个递归式和快速选择(线性选择算法)的递推式接近，该算法的时间复杂度$T(n)=\Theta(n)$。</p><hr><p><strong>邮局位置问题</strong>的定义如下，给定权重分别为$w_1,w_2,\dotsb,w_n$的$n$个点$p_1,p_2,\dotsb,p_n$，我们希望找到一个点$p$(不一定是输入点中的一个)，使得$\sum_{i=1}^{n}{w_id(p,p_i)}$最小，这里$d(a,b)$表示点$a$和$b$之间的距离。</p><h3 id="d-emsp-证明：对一维邮局位置问题，带权中位数是最好的解决方法，其中，每个点都是一个实数，点-a-和-b-之间的距离是-d-a-b-a-b-。"><a href="#d-emsp-证明：对一维邮局位置问题，带权中位数是最好的解决方法，其中，每个点都是一个实数，点-a-和-b-之间的距离是-d-a-b-a-b-。" class="headerlink" title="d.&emsp;证明：对一维邮局位置问题，带权中位数是最好的解决方法，其中，每个点都是一个实数，点$a$和$b$之间的距离是$d(a,b)=|a-b|$。"></a>d.&emsp;证明：对一维邮局位置问题，带权中位数是最好的解决方法，其中，每个点都是一个实数，点$a$和$b$之间的距离是$d(a,b)=|a-b|$。</h3><p>&emsp;采用$x_1,x_2,\dotsb,x_n$表示$n$个点的坐标，每个点相应的权值为$w_1,w_2,\dotsb,w_n$，令$x=x_k$为带权中位数。</p><p>&emsp;对于任意点$p$，我们设函数$f(p)=\sum_{i=1}^n{w_i|p-x_i|}$，我们需要找出令该函数最小值的点。令$y$是除$x$外的任意点，我们通过证明$f(y)-f(x) \geq 0$来检验带权中位数$x$是最优解。我们可以分为下面两种情况来讨论：$y &gt; x$和 $x &gt; y$。对于$\forall  x,y$有：</p><script type="math/tex; mode=display">\begin{aligned}    f(y)-f(x) &=\sum_{i=1}^{n}{w_i|y-x_i|} -\sum_{i=1}^{n}{w_i |x-x_i|}    \\              &=\sum_{i=1}^{n}{w_i(|y-x_i|-|x-x_i|)}\end{aligned}</script><p>1、 当$y&gt;x$时，对于上面式子中的$|y-x_i|-|x-x_i|$可以分为三种情况：</p><p>&emsp;1.1、$x &lt; y \leq x_i$</p><script type="math/tex; mode=display">\frac{|y-x|+|y-x_i|=|x-x_i| \quad AND \quad |y-x|=y-x}{\to |y-x_i|-|x-x_i|=-|y-x|=x-y}</script><p>&emsp;1.2、$x &lt; x_i \leq y$</p><script type="math/tex; mode=display">\frac{|y-x_i| \geq 0 \quad AND \quad |x-x_i| \leq y-x}{\to |y-x_i|-|x-x_i| \geq -(y-x) = x-y}</script><p>&emsp;1.3、$x_i \leq x &lt; y$，类似1.1</p><script type="math/tex; mode=display">\frac{|x-x_i|+|y-x|=|y-x_i| \quad AND \quad |y-x|=y-x}{\to |y-x_i|-|x-x_i|=|y-x|=y-x}</script><p>解释一下上面这么写的原因，如：1.1，$d(x,x_i)==d(x,y)+d(y,x_i)$，绝对值内的减法理解为距离计算，配凑出与我们要求的式子，进行等价转换，后面方便处理。</p><p><strong>其实对于1.1和1.3我们简单根据正负情况消去绝对值符号也行。</strong></p><p>&emsp;将前两种情况($x &lt; x_i$)与第三种情况分开($x_i \leq x$)。。我们有：</p><script type="math/tex; mode=display">\begin{aligned}    f(y)-f(x) &= \sum_{i=1}^{n}{w_i(|y-x_i|-|x-x_i|)}   \\              &\geq \sum_{x<x_i}{w_i(x-y)}+\sum_{x \geq x_i}{w_i(y-x)}  \\              &= (y-x)\left(\sum_{x \geq x_i}{w_i}-\sum_{x < x_i}{w_i}\right)\end{aligned}</script><p>结合$x_k$的性质，我们有：</p><script type="math/tex; mode=display">\begin{aligned}    \sum_{x_i < x}{w_i} <1/2 \quad    \underrightarrow{implies} & \sum_{x_i \leq x}{w_i} \geq 1/2    \\    和 \sum_{x_i>x}{w_i} &\leq 1/2  \\    \therefore \sum_{x \geq x_i}{w_i}-\sum_{x < x_i}{w_i} &\geq 0\end{aligned}</script><p>又$\because y-x &gt;0$，$\therefore f(y)-f(x) \geq 0$</p><p>2、当$x &gt; y$时，我们同样将$|y-x_i|-|x-x_i|$分为下面三种情况：</p><p>&emsp;2.1、$x_i \leq y &lt; x$</p><script type="math/tex; mode=display">\frac{|y - x_i|+|x - y|=|x-x_i|\quad AND \quad |x-y|=x-y}{\to |y-x_i|-|x-x_i|=-|x-y|=y-x}</script><p>&emsp;2.2、$y \leq x_i &lt; x$</p><script type="math/tex; mode=display">\frac{|y-x_i \geq 0| \quad AND \quad |x_-x_i| \leq x-y}{\to |y-x_i|-|x-x_i| \geq -(x-y)=y-x}</script><p>&emsp;2.3、$y &lt; x \leq x_i$,类似情况1</p><script type="math/tex; mode=display">\frac{|x-y|+|x-x_i|=|y-x_i| AND |x-y|=x-y}{\to |y-x_i|-|x-x_i|=|x-y|=x-y}</script><p>&emsp;和之前处理一样，分为前两种情况为$x_i &lt; x$，第三种情况为$x \leq x_i$，我们有：</p><script type="math/tex; mode=display">\begin{aligned}   f(y)-f(x) &=\sum_{i=1}^{n}{w_i(|y-x_i|-|x-x_i|)}   \\             &\geq \sum_{x_i<x}{w_i(y-x)} +\sum_{x\leq x_i}{w_i(x-y)}   \\             &=(y-x)\left(\sum_{x_i<x}{w_i}-\sum_{x \leq x_i}{w_i} \right)\\\end{aligned}</script><p>同上，$\because x$是带权中位数，有:</p><script type="math/tex; mode=display">\begin{aligned}    \sum_{x_i < x}{w_i} &< 1/2  \\     和 \sum_{x_i >x}{w_i} \leq 1/2 \quad &\underrightarrow{implies}     \sum_{x_i \geq x}{w_i} > 1/2    \\    \therefore \sum_{x_i < x}{w_i}-\sum_{x \leq x_i}{w_i} &>0\end{aligned}</script><p>又 $\because y-x&gt;0 \therefore f(y)-f(x)&gt;0$。</p><p>综上：</p><script type="math/tex; mode=display">f(y)-f(x)\begin{cases}    \geq 0 & y > x\\      >  0 & x > y\end{cases}</script><p>因此，带权中位数$x=x_k$是一维邮局问题的最优解,得证。</p><hr><h3 id="e-emsp-请给出二位邮局位置问题的最好解决方法：其中的点是-x-y-的二位坐标形式，点-a-x-1-y-1-与-b-x-2-y-2-之间的距离是-Manhattan-距离-曼哈顿距离-出租车距离-街区距离-，即-d-a-b-x-1-x-2-y-1-y-2"><a href="#e-emsp-请给出二位邮局位置问题的最好解决方法：其中的点是-x-y-的二位坐标形式，点-a-x-1-y-1-与-b-x-2-y-2-之间的距离是-Manhattan-距离-曼哈顿距离-出租车距离-街区距离-，即-d-a-b-x-1-x-2-y-1-y-2" class="headerlink" title="e.&emsp;请给出二位邮局位置问题的最好解决方法：其中的点是$(x,y)$的二位坐标形式，点$a=(x_1,y_1)$与$b=(x_2,y_2)$之间的距离是$Manhattan$距离(曼哈顿距离/出租车距离/街区距离)，即$d(a,b)=|x_1-x_2|+|y_1-y_2|$"></a>e.&emsp;请给出二位邮局位置问题的最好解决方法：其中的点是$(x,y)$的二位坐标形式，点$a=(x_1,y_1)$与$b=(x_2,y_2)$之间的距离是$Manhattan$距离(曼哈顿距离/出租车距离/街区距离)，即$d(a,b)=|x_1-x_2|+|y_1-y_2|$</h3><p>&emsp;我们采用一对坐标来表示每个点$p_i=(x_i,y_i)$，同时每个点相应的权值为$w_i$。因此，我们的目标转变为找到一个点$p=(x,y)$使下面的函数达到最小值：</p><script type="math/tex; mode=display">f(x,y)=\sum_{i=1}^{n}{w_i(|x-x_i|+|y-y_i|)}</script><p>&emsp;我们可以将函数$f(x,y)$转变为两个等价的一元函数相加:</p><script type="math/tex; mode=display">\begin{aligned}    f(x,y)&=g(x)+h(y)\\     其中，g(x) &=\sum_{i=1}^{n}{w_i|x-x_i|}  \\     h(y) &=\sum_{i=1}^{n}{w_i|y-y_i|}\end{aligned}</script><p>我们要使$f(x,y)$取得最小值，可以单独的对每一维度进行处理，因为$g(x)$不依赖于变量$y，h(y)$不依赖于变量$x$。因此：</p><script type="math/tex; mode=display">\begin{aligned}    \min_{x,y}{f(x,y)} &= \min_{x,y}{(g(x)+h(y))}   \\                       &= \min_{x} \left(\min_{y}(g(x)+h(y))\right) \\                       &= \min_{x} \left(g(x)+ \min_{y}h(y) \right) \\                       &= \min_{x}g(x)+\min_{y}h(y)\end{aligned}</script><p>&emsp;原先的二维问题，现在问题就转变为求2个一维最优解问题。和我们上面问题$d$一样，因此，我们只要分别求$x、y$维度上的带权中位数，设为$x_k,y_k$。最终答案记为$(x_k,y_k)$。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;9-2-emsp-带权中位数-对分别具体以正权重-w-1-w-2-dotsb-w-n-且满足-sum-i-1-n-w-i-1-的-n-个互异的元素-x-1-x-2-dotsb-x-n-来说，带权中位数-x-k-较小中位数-是满足如下条件的元素：&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="中位数" scheme="http://007havegone.github.io/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>算法导论9.3-8两个有序数组的中位数</title>
    <link href="http://007havegone.github.io/2019/08/01/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA9-3-8%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://007havegone.github.io/2019/08/01/算法导论9-3-8两个有序数组的中位数/</id>
    <published>2019-08-01T10:16:30.000Z</published>
    <updated>2019-08-01T16:15:53.648Z</updated>
    
    <content type="html"><![CDATA[<h3 id="9-3-8-emsp-设X-1-n-和Y-1-n-为两个数组，每个都包含n个有序的元素，请设计一个-O-lgn-时间的算法找出数组X和Y中所有2n个元素的中位数。"><a href="#9-3-8-emsp-设X-1-n-和Y-1-n-为两个数组，每个都包含n个有序的元素，请设计一个-O-lgn-时间的算法找出数组X和Y中所有2n个元素的中位数。" class="headerlink" title="9.3-8&emsp;设X[1..n]和Y[1..n]为两个数组，每个都包含n个有序的元素，请设计一个$O(lgn)$时间的算法找出数组X和Y中所有2n个元素的中位数。"></a>9.3-8&emsp;设X[1..n]和Y[1..n]为两个数组，每个都包含n个有序的元素，请设计一个$O(lgn)$时间的算法找出数组X和Y中所有2n个元素的中位数。</h3><p><strong>下面假设中位数(低中位数，数组长度偶数时较小的那个)在数组$X$中。如果要求中间两个数的均值，只需要在该基础之上修改一点就好。</strong></p><p>a、$X[k]=m$为中位数，对于数组$X$,有$k$个元素小于等于$X[k]$，同时有$n-k$个元素大于等于$X[k]$。当两个数组合并有序时，对于中位数来说，共有$n$个元素小于等于$X[k]$，n个元素大于等于$X[k]$。那么对于数组$Y$来说，有$n-k$个元素小于等于$X[k]$，$n-(n-k)=k$个元素大于等于$X[k]$。那么就存在以下不等式：</p><script type="math/tex; mode=display">Y[n-k] \leq X[k] \leq Y[n-k+1],1 \leq k < n</script><p>b、$若X[k]$不是中位数。且中位数为$X[k’] \,(1 \leq k’ &lt; k &lt; n)$，那么就有：</p><script type="math/tex; mode=display">Y[n-k'] \leq X[k'] \leq Y[n-k'+1]</script><p>那么对于$X[k]$来说，有：</p><script type="math/tex; mode=display">\begin{aligned}  Y[n-k+1] &\leq Y[n-k'] \leq X[k'] < X[k] \\               Y[n-k+1] &< X[k]  \end{aligned}</script><p>c、$若X[k]$不是中位数。且中位数为$X[k’]  (1 \leq k &lt; k’ &lt; n)$，那么就有：</p><script type="math/tex; mode=display">Y[n-k'] \leq X[k'] \leq Y[n-k'+1]</script><p>那么对于$X[k]$来说，有：</p><script type="math/tex; mode=display">\begin{aligned}    X[k] &< X[k'] \leq Y[n-k'+1] \leq Y[n-k] \\                X[k] &< Y[n-k]\end{aligned}</script><p>d、在递归的过程中，我们要注意一个递归的一个边界问题，在实际的编程中，对于数组$A[L,..R]，1 \leq L \leq R \leq n$。我们取$k=(L+R)/2,k \in [1,n]$, 当$k=n$时，那么对于上面三种情况会出现$Y[n-k]=Y[0]$是一个空数组，对于这种情况，其实只需判断$X[k]=X[n] \leq Y[1]$。</p><p>利用上面的性质，就可以在$O(1)$的时间内判断$X[k]$是否时中位数。对于一个数组区间$X[L,R]$。我们采用二分的思想，取中点$k=(L+R)/2$，判断上面的条件，如果满足条件a或d，那么$X[k]$就是中位数，如果是条件b，那么说明$k$偏大，我们在左子区间继续二分查找，否则为条件c，我们在右子区间继续二分查找。这样的一个二分查找过程的时间复杂度为$\Theta(lgn)$。</p><p>上面给出性质的是假设中位数在数组$X$的分析，如果中位数不在数组$X$中，在查找的过程中到达边界而不满足$X[k]$为中位数的a条件，我们可以返回一个标志如NOTFIND。此时中位数一定在数组$Y$中，我们进行同样的操作。最差情况下进行$2lgn$次查找。时间复杂度仍为为$\Theta(lgn)$。</p><p>下面是伪代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Two-Array-Medium(X,Y)</span><br><span class="line">n &lt;-- X.length  <span class="comment">//与数组Y长度相同</span></span><br><span class="line">medium = Find-Medium(X,Y,<span class="number">1</span>,n,n)<span class="comment">//先尝试在数组X查找</span></span><br><span class="line"><span class="keyword">if</span> medium = NOTFIND<span class="comment">//未找到，在Y数组查找</span></span><br><span class="line">    medium = Find-Medium(Y,X,<span class="number">1</span>,n,n)</span><br><span class="line"><span class="keyword">return</span> medium</span><br><span class="line"></span><br><span class="line">Find-Medium(A,B,low,high,n)</span><br><span class="line"><span class="keyword">if</span> low &gt; high</span><br><span class="line">    <span class="keyword">return</span> NOTFIND</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    k = (high+low)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> k=n <span class="keyword">and</span> A[n]&lt;=B[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> A[n]</span><br><span class="line">    elseif k &lt; n <span class="keyword">and</span> B[n-k] &lt;= A[k] &lt;= B[n-k+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> A[k]</span><br><span class="line">    elseif B[n-k+<span class="number">1</span>] &lt; A[k]</span><br><span class="line">        <span class="keyword">return</span> Find-Medium(A,B,low,k<span class="number">-1</span>,n)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Find-Medium(A,B,k+<span class="number">1</span>,high,n)</span><br></pre></td></tr></table></figure><p>实际编程中，数组从0开始稍微改动下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOTFIND 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数n为数组长度,此时边界为n-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMedium</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> B[],<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L&gt;R)</span><br><span class="line"><span class="keyword">return</span> NOTFIND;</span><br><span class="line"><span class="keyword">int</span> k=(L+R)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// k=n-1时要独立一个分支，否则第二个if会越界</span></span><br><span class="line"><span class="keyword">if</span>(k==(n<span class="number">-1</span>)&amp;&amp;A[k]&lt;=B[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">return</span> A[k];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k&lt;(n<span class="number">-1</span>)&amp;&amp;B[n-k<span class="number">-2</span>]&lt;=A[k]&amp;&amp;A[k]&lt;=B[n-k<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">return</span> A[k];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(B[n-k<span class="number">-1</span>]&lt;A[k])</span><br><span class="line"><span class="keyword">return</span> findMedium(A,B,L,k<span class="number">-1</span>,n);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> findMedium(A,B,k+<span class="number">1</span>,R,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TwoArrayMedium</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> B[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=NOTFIND;</span><br><span class="line"><span class="keyword">if</span>((ret=findMedium(A,B,<span class="number">0</span>,len<span class="number">-1</span>,len))==NOTFIND)</span><br><span class="line">ret=findMedium(B,A,<span class="number">0</span>,len<span class="number">-1</span>,len);<span class="comment">//不在数组A,继续在B中查找</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">unsigned</span> N&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getRandomArray</span><span class="params">(T (&amp;arr)[N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//随机生成2000以内的随机数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> default_random_engine <span class="title">e</span><span class="params">(time(<span class="literal">nullptr</span>))</span></span>;</span><br><span class="line"><span class="keyword">static</span> uniform_int_distribution&lt;T&gt; d(<span class="number">0</span>,<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:arr)</span><br><span class="line">i=d(e);</span><br><span class="line">sort(arr,arr+N);<span class="comment">//数组排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> A[LEN];</span><br><span class="line"><span class="keyword">int</span> B[LEN];</span><br><span class="line">getRandomArray(A);</span><br><span class="line">getRandomArray(B);</span><br><span class="line"><span class="keyword">int</span> C[<span class="number">2</span>*LEN];</span><br><span class="line">copy(A,A+LEN,C);</span><br><span class="line">copy(B,B+LEN,C+LEN);</span><br><span class="line">sort(C,C+<span class="number">2</span>*LEN);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:C)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"中位数为:"</span> &lt;&lt; TwoArrayMedium(A,B,LEN) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个问题我只求了低中位数，因为数组总长度为$2n$恒为偶数，因此如果要求中间两个数的均值。只需要在上面代码的基础上稍微改下，加上$k+1$位置的数，然后除2即可达到。<strong>（注意：如果k求出是X数组的最后一位，那么高中位数在数组Y中）</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;9-3-8-emsp-设X-1-n-和Y-1-n-为两个数组，每个都包含n个有序的元素，请设计一个-O-lgn-时间的算法找出数组X和Y中所有2n个元素的中位数。&quot;&gt;&lt;a href=&quot;#9-3-8-emsp-设X-1-n-和Y-1-n-为两个数组，每个都包含n个有
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="中位数" scheme="http://007havegone.github.io/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    
      <category term="二分查找" scheme="http://007havegone.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>算法导论思考题6-2</title>
    <link href="http://007havegone.github.io/2019/07/31/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E6%80%9D%E8%80%83%E9%A2%986-2/"/>
    <id>http://007havegone.github.io/2019/07/31/算法导论思考题6-2/</id>
    <published>2019-07-31T12:02:23.000Z</published>
    <updated>2019-07-31T12:40:33.592Z</updated>
    
    <content type="html"><![CDATA[<h3 id="6-2（对d叉堆的分析）d叉堆与二叉堆很类似，但（一个可能的例外是）其中的每个非叶节点有d个孩子，而不是仅仅2个。"><a href="#6-2（对d叉堆的分析）d叉堆与二叉堆很类似，但（一个可能的例外是）其中的每个非叶节点有d个孩子，而不是仅仅2个。" class="headerlink" title="6-2（对d叉堆的分析）d叉堆与二叉堆很类似，但（一个可能的例外是）其中的每个非叶节点有d个孩子，而不是仅仅2个。"></a>6-2（对d叉堆的分析）d叉堆与二叉堆很类似，但（一个可能的例外是）其中的每个非叶节点有d个孩子，而不是仅仅2个。</h3><p>a.&emsp;如何在一个数组中表示一个d叉堆？</p><p>假设数组从$A[1]$开始,它作为根，那么$A[1]$有d个孩子分别是$A[2]…A[d+1]$，共d个。那么对于$A[2]…A[d+1]$共d个结点，一共有$d^2$个结点，从$A[d+2]….A[d^2+d+1]$。依次类推。那么对于一个编号为$i$的结点的第$j$个孩子$(1 \leq j \leq d)$，</p><p>D-ARY-Parent(i)<br>return $\lfloor (i-2)/d+1 \rfloor$</p><p>D-ARY-Child(i,j)<br>return $\lfloor d(i-1)+j+1$</p><p>i的d个结点从$d(i-1)+2到di+1$。</p><p>结合画图，不难推出。</p><p>自己可以通过 <strong>D-ARY-Parent(D-ARY-Child(i,j))=i</strong> 来验证一下。二叉堆是当$d=2$时的一个特例。</p><hr><p>b.&emsp;包含n个元素的d叉堆的高度是多少?请用n和d表示。</p><p>类似二叉堆的推导过程。不难的得出一个n个元素的d叉堆，有$\Theta(log_dn)=\Theta(lgn/lgd)$。</p><hr><p>c.&emsp;请给出EXTRACT-MAX在d叉堆上的一个有效实现，并用d和n表示出它的时间复杂度。</p><p>对于d叉堆的EXTRACT-MAX实现，与树中二叉堆的实现相同，只需要修改MAX-HEAPIFY在下放的过程中，是与d个孩子比较，而不是2个孩子。对于每一层的下放，最差情况下比较d次。那么对于一个n个结点的d叉堆来说。EXTRACT-MAX的时间复杂度为 $\Theta(dlog_dn)=\Theta(dlgn/lgd)$。</p><hr><p>d.&emsp;给出INSERT在d叉最大堆上的一个有效实现，并用d和n表示它的时间复杂度。</p><p>树中给出的二叉堆的MAX-HEAP-INSERT的实现同样适用与d叉堆。该过程只需要访问结点的parent结点，其他并没有改变。最坏情况下时间复杂度为$\Theta(h)$。h为d叉堆的高度，前面已求出，$h=\Theta(lgn/lgd)$。</p><hr><p>e.&emsp;给出INCREASE-KEY(A,i,k)的一个有效实现，当$k&lt;A[i]$时，它会触发一个错误，否则执行$A[i]=k$,并更新相应的d叉最大堆。请用d和n表示出它的时间复杂度。</p><p>跟书本的实现一致。只需要将计算parent的结点的公式替换即可。最坏情况下的时间复杂度为$\Theta(h)=\Theta(log_dn)=\Theta(lgn/lgd)$。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;6-2（对d叉堆的分析）d叉堆与二叉堆很类似，但（一个可能的例外是）其中的每个非叶节点有d个孩子，而不是仅仅2个。&quot;&gt;&lt;a href=&quot;#6-2（对d叉堆的分析）d叉堆与二叉堆很类似，但（一个可能的例外是）其中的每个非叶节点有d个孩子，而不是仅仅2个。&quot; clas
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="d叉堆" scheme="http://007havegone.github.io/tags/d%E5%8F%89%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>算法导论思考题4-1</title>
    <link href="http://007havegone.github.io/2019/07/31/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E6%80%9D%E8%80%83%E9%A2%984-1/"/>
    <id>http://007havegone.github.io/2019/07/31/算法导论思考题4-1/</id>
    <published>2019-07-30T16:42:47.000Z</published>
    <updated>2019-07-31T06:55:58.117Z</updated>
    
    <content type="html"><![CDATA[<h3 id="4-1（递归式例子）对下列每个递归式，给出T-n-的渐进上界和渐进下界。假定-n-leq2-时T-n-时常数。给出尽量紧确的界，并验证其正确性。"><a href="#4-1（递归式例子）对下列每个递归式，给出T-n-的渐进上界和渐进下界。假定-n-leq2-时T-n-时常数。给出尽量紧确的界，并验证其正确性。" class="headerlink" title="4-1（递归式例子）对下列每个递归式，给出T(n)的渐进上界和渐进下界。假定 $n\leq2$时T(n)时常数。给出尽量紧确的界，并验证其正确性。"></a>4-1（递归式例子）对下列每个递归式，给出T(n)的渐进上界和渐进下界。假定 $n\leq2$时T(n)时常数。给出尽量紧确的界，并验证其正确性。</h3><p>不会主方法的先看一下这篇博客：<a href="https://blog.csdn.net/qq_40512922/article/details/96932368" target="_blank" rel="noopener">https://blog.csdn.net/qq_40512922/article/details/96932368</a></p><p>a.&emsp;$T(n)=2T(n/2)+n^4$</p><p>证明：有$a=2,b=2,n^{log_ba}=n$，$f(n)=f(n^4)=\Omega(n^{\epsilon+1})$，其中$\epsilon=3$。下面证明正则条件：$\exists c&lt;1,af(n/b)\leq cf(n)$</p><script type="math/tex; mode=display">2f(n/2)=\frac{n^4}{8} \leq cn^4</script><p>当 $c=1/8$时,显然成立。因此$T(n)=\Theta(f(n))=\Theta(n^4)$</p><hr><p>b.&emsp;$T(n)=T(7n/10)+n$</p><p>证明：有$a=1,b=10/7,n^{log_ba}=1$，$f(n)=n=\Omega(n^{\epsilon+0})$，其中$\epsilon=1$，下面证明正则条件：$\exists c&lt;1,af(n/b)\leq cf(n)$</p><script type="math/tex; mode=display">f(7n/10)=7n/10 \leq cn</script><p>当$c=7/10$时，显然成立。因此$T(n)=\Theta(f(n))=\Theta(n)$</p><hr><p>c.&emsp;$T(n)=16T(n/4)+n^2$</p><p>证明：有$a=16,b=4,n^{log_ba}=n^2$，$f(n)=n^2=\Theta(n^2)$。</p><p>因此，$T(n)=\Theta(nlgn)$。</p><hr><p>d.&emsp;$T(n)=7T(n/3)+n^2$</p><p>证明：有$a=7,b=3,n^{log_ba}\approx n^{1.7}$，$f(n)=n^2=\Omega(n^{1.7+\epsilon})$，其中$\epsilon=0.3$，下面证明正则条件。</p><script type="math/tex; mode=display">7f(n/3)=\frac{7n^2}{9} \leq cn^2</script><p>当$c=7/9$时，显然成立。因此$T(n)=\Theta(f(n))=\Theta(n^2)$</p><hr><p>e.&emsp;$T(n)=7T(n/2)+n^2$</p><p>证明：有$a=7,b=2,n^{log_ba}\approx n^{2.8}$，$f(n)=n^2=O(n^{2.8-\epsilon})$，其中$\epsilon=0.8$。</p><p>因此$T(n)=\Theta(n^{log_ba})=\Theta(n^{log_27})$</p><hr><p>f.&emsp;$T(n)=2T(n/4)+\sqrt n$</p><p>证明：有$a=2,b=4,n^{log_ba}=n^{0.5}$，$f(n)=n^{0.5}=\Theta(n^0.5)$。<br>因此，$T(n)=\Theta(f(n)lgn)=\Theta(\sqrt{n}lgn)$</p><hr><p>g.&emsp;$T(n)=T(n-2)+n^2$</p><p>证明：</p><script type="math/tex; mode=display">T(n)=\sum_{i=0}^{n}{(2i)^2}=\frac{2n(n+1)(2n+1)}{3}+T(0) = \Theta(n^3)</script><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;4-1（递归式例子）对下列每个递归式，给出T-n-的渐进上界和渐进下界。假定-n-leq2-时T-n-时常数。给出尽量紧确的界，并验证其正确性。&quot;&gt;&lt;a href=&quot;#4-1（递归式例子）对下列每个递归式，给出T-n-的渐进上界和渐进下界。假定-n-leq2-时T
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="主方法" scheme="http://007havegone.github.io/tags/%E4%B8%BB%E6%96%B9%E6%B3%95/"/>
    
      <category term="算法分析" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>算法导论思考题2-4</title>
    <link href="http://007havegone.github.io/2019/07/30/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E6%80%9D%E8%80%83%E9%A2%982-4/"/>
    <id>http://007havegone.github.io/2019/07/30/算法导论思考题2-4/</id>
    <published>2019-07-30T09:41:22.000Z</published>
    <updated>2019-07-30T14:42:17.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思考题2-4（逆序对）-假设A-1-n-是一个有-n-个不同数的数组，若iA-j-，则对偶-i-j-称为A的一个逆序对-inversion-。"><a href="#思考题2-4（逆序对）-假设A-1-n-是一个有-n-个不同数的数组，若iA-j-，则对偶-i-j-称为A的一个逆序对-inversion-。" class="headerlink" title="思考题2-4（逆序对） 假设A[1..n]是一个有$n$个不同数的数组，若iA[j]，则对偶(i,j)称为A的一个逆序对(inversion)。"></a>思考题2-4（逆序对） 假设A[1..n]是一个有$n$个不同数的数组，若i<j且a[i]>A[j]，则对偶(i,j)称为A的一个逆序对(inversion)。</j且a[i]></h2><h3 id="a-列出数组-的5个逆序对。"><a href="#a-列出数组-的5个逆序对。" class="headerlink" title="a.列出数组$$的5个逆序对。"></a>a.列出数组$<2,3,8,6,1>$的5个逆序对。</2,3,8,6,1></h3><p>&emsp;逆序对有$(1,5),(2,5),(3,4),(3,5),(4,5)$</p><hr><h3 id="b-有集合-1-2-dots-n-中的元素构成的什么数组具有最多的逆序对？它有多少逆序对？"><a href="#b-有集合-1-2-dots-n-中的元素构成的什么数组具有最多的逆序对？它有多少逆序对？" class="headerlink" title="b.有集合$\{1,2,\dots,n\}$中的元素构成的什么数组具有最多的逆序对？它有多少逆序对？"></a>b.有集合$\{1,2,\dots,n\}$中的元素构成的什么数组具有最多的逆序对？它有多少逆序对？</h3><p>&emsp; 当数组为 $\{1,2,\dots,n\}$为逆序时，即$\{n,n-1,\dots,1\}$时逆序对最多。对于 $\forall i,j \in [1,n],(i,j)$均为逆序对。此时共有逆序对$(_n^2)=n(n-1)/2$</p><hr><p>c.插入排序的运行时间与输入数组中逆序对的数量之间是什么关系?证明你的回答。</p><p>&emsp;假设数组$A$初始时存在逆序对$(k,j)$，那么有$k<j$和$a[k]<a[j]$。在1-8行外层for循环中，每次令$key=a[j]$，$i=j-1$，在5-7行的while循环中，有$a[i]>key$，即存在一对逆序对，while循环的一次迭代，将$A[i]$后移一位，最终前$j$个元素处于有序，此时消除了前$j$个元素的逆序对。对于7-9的一次循环，相当于消除一对逆序对。因此，插入排序的运行时间和数组的逆序对之间呈线性关系。</j$和$a[k]<a[j]$。在1-8行外层for循环中，每次令$key=a[j]$，$i=j-1$，在5-7行的while循环中，有$a[i]></p><hr><p>d.给出一个确定在n个元素的任何排列中逆序对数量的算法，最坏情况需要$\Theta(nlgn)$的时间。</p><p>&emsp;对于这个问题，可以采用归并排序统计逆序对量，或者采用线段树。下面给出具体思路</p><p><strong>1、归并排序</strong></p><p>计算数组的逆序对数量，可以采用归并排序二分的思想。对于一个数组来说逆序对的来源可以分为3种情况。</p><p>对于一个数组 $A[left,right],mid=(left+right)/2$<br>(1) 两个都在左半数组，$left \leq i \leq j \leq mid，A[i] &gt; A[j]$<br>(2) 两个都在右半数组，$mid+1 \leq i \leq j \leq right,A[i] &gt; A[j]$<br>(3) 左右各一个，$left \leq i \leq mid &lt; j \leq right,A[i] &gt; A[j]$</p><p>根据上面的思路，只需要对归并排序的代码稍微改动即可。下面是我的实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InversionCount</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">总的逆序对等于左子数组的内部逆序对+右子数组的内部逆序对+来自左和右形成的逆序对</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">cnt+=MergeSort(A,l,m);<span class="comment">//第1种情况</span></span><br><span class="line">cnt+=MergeSort(A,m+<span class="number">1</span>,r);<span class="comment">//第2种情况</span></span><br><span class="line">cnt+=Merge1(A,l,m,r);<span class="comment">//第3种情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//书种归并排序采用哨兵的版本</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Merge1</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> l,<span class="keyword">int</span> m,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> inv_cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *L=<span class="keyword">new</span> <span class="keyword">int</span>[m-l+<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> *R=<span class="keyword">new</span> <span class="keyword">int</span>[r-m+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l,k=<span class="number">0</span>;i&lt;=m;)</span><br><span class="line">L[k++]=A[i++];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=m+<span class="number">1</span>,k=<span class="number">0</span>;i&lt;=r;)</span><br><span class="line">R[k++]=A[i++];</span><br><span class="line"><span class="keyword">int</span> LenA=m-l+<span class="number">1</span>;<span class="comment">//左子数组的长度</span></span><br><span class="line">L[m-l+<span class="number">1</span>]=R[r-m]=INF;<span class="comment">//设置哨兵</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=l,i=<span class="number">0</span>,j=<span class="number">0</span>;k&lt;=r;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(L[i]&lt;=R[j])<span class="comment">//i&lt;j且A[i]&lt;=A[j]，没有逆序对</span></span><br><span class="line">A[k++]=L[i++];</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//i&lt;j且A[i]&gt;A[j]</span></span><br><span class="line"><span class="keyword">if</span>(L[i]!=INF)&#123;<span class="comment">//这里有可能左侧数组先达到尾部，此时防止INF引起额外累加。</span></span><br><span class="line">                <span class="comment">//大于A[j]的数量=LenA-i(小于A[i]的数量，数组从0开始)</span></span><br><span class="line">inv_cnt+=LenA-i;</span><br><span class="line">&#125;</span><br><span class="line">A[k++]=R[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// printf("l = %d r = %d cnt = %d\n",l,r,inv_cnt);</span></span><br><span class="line"><span class="keyword">return</span> inv_cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不用哨兵处理会更方便点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Merge2</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> l,<span class="keyword">int</span> m,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *B=<span class="keyword">new</span> <span class="keyword">int</span>[r-l+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> i=l,j=m+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> inv_cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=m&amp;&amp;j&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A[i]&lt;=A[j])</span><br><span class="line">B[k++]=A[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">inv_cnt+=m-i+<span class="number">1</span>;</span><br><span class="line">B[k++]=A[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=m)</span><br><span class="line">B[k++]=A[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=r)</span><br><span class="line">B[k++]=A[j++];</span><br><span class="line">k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;)</span><br><span class="line">&#123;</span><br><span class="line">A[i++]=B[k++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> inv_cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> A[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> B[]=&#123;<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> C[]=&#123;<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> D[]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; InversionCount::MergeSort(A,<span class="number">0</span>,<span class="number">7</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; InversionCount::MergeSort(B,<span class="number">0</span>,<span class="number">7</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; InversionCount::MergeSort(C,<span class="number">0</span>,<span class="number">5</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; InversionCount::MergeSort(D,<span class="number">0</span>,<span class="number">4</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2、线段树</strong></p><p>可以采用线段树来处理，这里不打算具体展开线段树的内容，后面有时间再整理一个关于线段树的专题。下面介绍算法思路。</p><p>1、为数组$A[1,n]$建立线段树，区间统计$[left,rigth]的数目，初始化均为0$，如果数据范围较大数据比较分散，可以先进行一次离散化。</p><p>2、依次对$A[1,n] \in [min,man]$的每个元素进行以下操作，假设$A[i]=k$,则对线段树查找区间$[k+1,max]$的大小，加入逆序对数量中，然后令$A[k]+1$。</p><p>上面的操作相当于遍历数组A，对于每一个元素，查找当前在它前面大于它的元素个数，然后累加起来，得到逆序对。遍历数组时间为$O(n)$，每进行一次查找操作为$O(lgn)$，总的的时间复杂度为$O(nlgn)$。</p><p>下面时代码实现，常规的线段树模板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lchild (x&lt;&lt;1) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rchild (x&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> A[N&lt;&lt;<span class="number">2</span>|<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A[x]=A[lchild]+A[rchild];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立线段树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left==right)&#123;</span><br><span class="line">A[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(left,mid,lchild);</span><br><span class="line">build(mid+<span class="number">1</span>,right,rchild);</span><br><span class="line">update(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询区间[L,R]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L&lt;=left&amp;&amp;right&lt;=R)</span><br><span class="line"><span class="keyword">return</span> A[x];</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">ret+=query(left,mid,L,R,lchild);</span><br><span class="line"><span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">ret+=query(mid+<span class="number">1</span>,right,L,R,rchild);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改 A[x]=k的结点+1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left==right)&#123;</span><br><span class="line">++A[x];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i&lt;=mid)</span><br><span class="line">modify(i,left,mid,lchild);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">modify(i,mid+<span class="number">1</span>,right,rchild);</span><br><span class="line">update(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[]=&#123;<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">build(<span class="number">1</span>,<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:arr)</span><br><span class="line">&#123;</span><br><span class="line">cnt+=query(<span class="number">1</span>,<span class="number">10</span>,i+<span class="number">1</span>,<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">modify(i,<span class="number">1</span>,<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思考题2-4（逆序对）-假设A-1-n-是一个有-n-个不同数的数组，若iA-j-，则对偶-i-j-称为A的一个逆序对-inversion-。&quot;&gt;&lt;a href=&quot;#思考题2-4（逆序对）-假设A-1-n-是一个有-n-个不同数的数组，若iA-j-，则对偶-i-j
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="逆序对" scheme="http://007havegone.github.io/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    
      <category term="排序" scheme="http://007havegone.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="线段树" scheme="http://007havegone.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法导论第二章插入排序</title>
    <link href="http://007havegone.github.io/2019/07/29/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://007havegone.github.io/2019/07/29/算法导论第二章插入排序/</id>
    <published>2019-07-29T10:00:17.000Z</published>
    <updated>2019-07-30T08:59:20.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法导论-第二章插入排序实现"><a href="#算法导论-第二章插入排序实现" class="headerlink" title="算法导论 第二章插入排序实现"></a>算法导论 第二章插入排序实现</h1><p>&emsp;插入排序算法是时间复杂度为 $O(n)$，输入规模$n$较小时，插入排序往往能有较好的效果。</p><p>&emsp;最优情况：数据整体有序，无需须交换元素，时间复杂度$O(n)$</p><p>&emsp;最坏情况：数据整体逆序，每个元素要 $1~n-1$次，时间复杂度为 $O(n^2)$。</p><p>&emsp;插入排序中的常数因子较小使得在$n$在较小的时候，在很多情况能够运行更快。作为归并排序，快速排序等算法在小规模时处理的问题时的子程序。</p><p>书中的伪代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSERTION-SORT(A)</span><br><span class="line"><span class="number">1</span> <span class="keyword">for</span> j = <span class="number">2</span> to A.length</span><br><span class="line"><span class="number">2</span> key = A[j]</span><br><span class="line"><span class="number">3</span> <span class="comment">//Insert A[j] into the sorted sequence[1..j-1]</span></span><br><span class="line"><span class="number">4</span>i = j<span class="number">-1</span></span><br><span class="line"><span class="number">5</span><span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key</span><br><span class="line"><span class="number">6</span>A[i+<span class="number">1</span>] = A[i]</span><br><span class="line"><span class="number">7</span>i = i+<span class="number">1</span></span><br><span class="line"><span class="number">8</span>A[i+<span class="number">1</span>] = key</span><br></pre></td></tr></table></figure></p><p>具体实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数组存放位置为[0,len-1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//升序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertSortInc</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len;++j)&#123;</span><br><span class="line"><span class="keyword">int</span> i=j<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> key=A[j];</span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;A[i]&gt;key)&#123;</span><br><span class="line">A[i+<span class="number">1</span>]=A[i];</span><br><span class="line">--i;</span><br><span class="line">&#125;</span><br><span class="line">A[i+<span class="number">1</span>]=key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//降序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertSortDec</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> i=j<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> key=A[j];</span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;A[i]&lt;key)&#123;</span><br><span class="line">A[i+<span class="number">1</span>]=A[i];</span><br><span class="line">--i;</span><br><span class="line">&#125;</span><br><span class="line">A[i+<span class="number">1</span>]=key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法导论-第二章插入排序实现&quot;&gt;&lt;a href=&quot;#算法导论-第二章插入排序实现&quot; class=&quot;headerlink&quot; title=&quot;算法导论 第二章插入排序实现&quot;&gt;&lt;/a&gt;算法导论 第二章插入排序实现&lt;/h1&gt;&lt;p&gt;&amp;emsp;插入排序算法是时间复杂度为 $O
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="排序" scheme="http://007havegone.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法导论思考题1-1</title>
    <link href="http://007havegone.github.io/2019/07/29/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E6%80%9D%E8%80%83%E9%A2%981-1/"/>
    <id>http://007havegone.github.io/2019/07/29/算法导论思考题1-1/</id>
    <published>2019-07-29T09:42:42.000Z</published>
    <updated>2019-07-30T08:59:25.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法导论-思考题1-1"><a href="#算法导论-思考题1-1" class="headerlink" title="算法导论-思考题1-1"></a>算法导论-思考题1-1</h1><h3 id="1-1（运行时间的比较）假设求解问题的算法需要-f-n-微秒-microseconds-，对下表中每个函数-f-n-和时间-t-可以确定在时间-t-内求解问题的最大规模-n-。"><a href="#1-1（运行时间的比较）假设求解问题的算法需要-f-n-微秒-microseconds-，对下表中每个函数-f-n-和时间-t-可以确定在时间-t-内求解问题的最大规模-n-。" class="headerlink" title="1-1（运行时间的比较）假设求解问题的算法需要 $f(n)$微秒(microseconds)，对下表中每个函数$f(n)$和时间$t$可以确定在时间$t$内求解问题的最大规模$n$。"></a>1-1（运行时间的比较）假设求解问题的算法需要 $f(n)$微秒(microseconds)，对下表中每个函数$f(n)$和时间$t$可以确定在时间$t$内求解问题的最大规模$n$。</h3><p><strong>中文版给的$f(n)$单位是毫秒，但看了原版，发现单位是微秒(microseconds)，故下面采用微秒来计算。</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">函数\时间</th><th style="text-align:center">1秒钟</th><th style="text-align:center">1分钟</th><th style="text-align:center">1小时</th><th style="text-align:center">1天</th><th style="text-align:center">1月</th><th style="text-align:center">1年</th><th style="text-align:center">1世纪</th></tr></thead><tbody><tr><td style="text-align:center">$lgn$</td><td style="text-align:center">$2^{10^6}$</td><td style="text-align:center">$2^{6\times 10^7}$</td><td style="text-align:center">$2^{3.6 \times 10^9}$</td><td style="text-align:center">$2^{8.64 \times 10^{10}}$</td><td style="text-align:center">$2^{2.592 \times 10^{12}}$</td><td style="text-align:center">$2^{3.1536 \times 10^{13}}$</td><td style="text-align:center">$2^{3.1536 \times 10^{15}}$</td></tr><tr><td style="text-align:center">$\sqrt n$</td><td style="text-align:center">$10^{12}$</td><td style="text-align:center">$3.6 \times 10^{15}$</td><td style="text-align:center">$1.296 \times10^{19}$</td><td style="text-align:center">$7.465 \times 10^{21}$</td><td style="text-align:center">$6.718 \times 10^{24}$</td><td style="text-align:center">$9.945 \times 10^{26}$</td><td style="text-align:center">$9.945 \times 10^{30}$</td></tr><tr><td style="text-align:center">$n$</td><td style="text-align:center">$10^6$</td><td style="text-align:center">$6 \times 10^7$</td><td style="text-align:center">$3.6 \times 10^9$</td><td style="text-align:center">$8.64 \times 10^{10}$</td><td style="text-align:center">$2.592 \times 10^{12}$</td><td style="text-align:center">$3.1536 \times 10^{13}$</td><td style="text-align:center">$3.1536 \times 10^{15}$</td></tr><tr><td style="text-align:center">$nlgn$</td><td style="text-align:center">$62746$</td><td style="text-align:center">$2.8 \times 10^6$</td><td style="text-align:center">$1.3 \times 10^8$</td><td style="text-align:center">$2.7 \times 10^9$</td><td style="text-align:center">$7.1 \times 10^{10}$</td><td style="text-align:center">$7.9 \times 10^{11}$</td><td style="text-align:center">$6.8 \times 10^{13}$</td></tr><tr><td style="text-align:center">$n^2$</td><td style="text-align:center">$1000$</td><td style="text-align:center">$7745$</td><td style="text-align:center">$60000$</td><td style="text-align:center">$293938$</td><td style="text-align:center">$1609968$</td><td style="text-align:center">$5615692$</td><td style="text-align:center">$56175382$</td></tr><tr><td style="text-align:center">$n^3$</td><td style="text-align:center">$100$</td><td style="text-align:center">$391$</td><td style="text-align:center">$1532$</td><td style="text-align:center">$4420$</td><td style="text-align:center">$13736$</td><td style="text-align:center">$31593$</td><td style="text-align:center">$146677$</td></tr><tr><td style="text-align:center">$2^n$</td><td style="text-align:center">$19$</td><td style="text-align:center">$25$</td><td style="text-align:center">$31$</td><td style="text-align:center">$36$</td><td style="text-align:center">$41$</td><td style="text-align:center">$44$</td><td style="text-align:center">$51$</td></tr><tr><td style="text-align:center">$n!$</td><td style="text-align:center">$9$</td><td style="text-align:center">$11$</td><td style="text-align:center">$12$</td><td style="text-align:center">$13$</td><td style="text-align:center">$15$</td><td style="text-align:center">$16$</td><td style="text-align:center">$17$</td></tr></tbody></table></div><p>$1s=10^6us$</p><p>$1min=6 \times 10^7us$</p><p>$1h=3.6 \times 10^9us$</p><p>$1D=8.64 \times 10^{10}us$</p><p>$1Mon=2.592 \times 10^{12}us$ （1个月30天）</p><p>$1Y=3.1536 \times 10^{13}us$  （365天）</p><p>$1C=3.1536 \times 10^{15}us$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法导论-思考题1-1&quot;&gt;&lt;a href=&quot;#算法导论-思考题1-1&quot; class=&quot;headerlink&quot; title=&quot;算法导论-思考题1-1&quot;&gt;&lt;/a&gt;算法导论-思考题1-1&lt;/h1&gt;&lt;h3 id=&quot;1-1（运行时间的比较）假设求解问题的算法需要-f-n-微
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>算法导论9.1-1找第二小的元素</title>
    <link href="http://007havegone.github.io/2019/07/26/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA9-1-1%E6%89%BE%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>http://007havegone.github.io/2019/07/26/算法导论9-1-1找第二小的元素/</id>
    <published>2019-07-26T13:08:35.000Z</published>
    <updated>2019-07-30T08:59:16.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法导论9-1-1找第二小的元素"><a href="#算法导论9-1-1找第二小的元素" class="headerlink" title="算法导论9.1-1找第二小的元素"></a>算法导论9.1-1找第二小的元素</h1><h2 id="1、证明：在最坏情况下，找到n个元素中第二小的元素需要-n-lceil-lgn-rceil-2-次比较。（提示：可以同时找到最小元素）"><a href="#1、证明：在最坏情况下，找到n个元素中第二小的元素需要-n-lceil-lgn-rceil-2-次比较。（提示：可以同时找到最小元素）" class="headerlink" title="1、证明：在最坏情况下，找到n个元素中第二小的元素需要 $n+ \lceil lgn  \rceil -2$次比较。（提示：可以同时找到最小元素）"></a>1、证明：在最坏情况下，找到n个元素中第二小的元素需要 $n+ \lceil lgn  \rceil -2$次比较。（提示：可以同时找到最小元素）</h2><p>做以下断言：无论采用何种比较算法，在寻找最小元素的过程中，第二小的元素一定与最小元素做过比较。<br>显然，因为第二小的元素直到遇到最小元素前，一定会胜出进入下一轮。如果最小元素没有与第二小元素相比较，则无法得出该元素是最小的关系。  </p><p>因此，要想是我们找到最小元素的比较次数最少，就需要在寻找最小元素的过程中与最小元素发生比较的次数尽量的少。  </p><p>由于每次我们只能取两个元素进行比较，从而考虑每一轮将我们比较元素两两比较，较小的元素进入下一轮（如比较元素有奇数个，落单的直接进入下一轮），这样比较所得的最小元素比较过的元素是最少的（每轮只有一个）。  </p><p>我们将比较过程转化为二叉树（以数组 [7,8,1,3,4,5,9]为例）:</p><p><img src="/2019/07/26/算法导论9-1-1找第二小的元素/二叉树.jpg" alt="二叉树"></p><h3 id="1-证明-n-1"><a href="#1-证明-n-1" class="headerlink" title="1.证明 $n-1$"></a>1.证明 $n-1$</h3><p>其中，除了叶节点外，每个结点都是一次比较的结果。因此该算法中，比较次数为树中度为2的结点数。根据二叉树的性子可以得出比较次数为 $n-1$ （二叉树：度为2的结点数=叶子叶子结点数-1）。可以看出树的每一层只有一个结点与最小元素比较，达到了下界，因此是最优的。</p><p>这里的 $n-1$ 次比较下界还有另外的思路。可以把每个元素看成一个集合。集合中用最小元素代表这个集合。初始状态下 $n$个点都是单独的集合，比较后相当于把集合做合并。合并后用最小值代表这个集合。那么初始状态下的 $n$ 个集合，至少经过 $n-1$ 次合并才能得到1个集合。  </p><h3 id="2-证明-lceil-lg-rceil-1"><a href="#2-证明-lceil-lg-rceil-1" class="headerlink" title="2.证明 $\lceil lg \rceil -1$"></a>2.证明 $\lceil lg \rceil -1$</h3><p>可以看出，与最小元素比较的次数为树高h-1（根节点的高度为1）。有因为叶节点数个数为n。从而有： $n \leq 2^{h-1}$，故有 $h-1 = \lceil lg n \rceil$,即与最小元素比较的次数至少为 $\lceil lg n \rceil$。  </p><p>从这 $\lceil lg n \rceil$个元素中找到的最小元素即是第二小的元素。最坏情况下第二小元素第一轮遇到最小元素被淘汰，从而在寻找最小元素的过程中，我们无法得到其他元素与第二小元素比较大小关系。这种情况下，要在 $\lceil lg n \rceil$个元素中找到最小元素需要 $\lceil lg n \rceil - 1$次比较。</p><p>综上：最坏情况下，要找到第二小的元素所需的比较次数为 $n + \lceil lg n\rceil -2$ 次比较。</p><h2 id="2-算法实现："><a href="#2-算法实现：" class="headerlink" title="2.算法实现："></a>2.算法实现：</h2><p>&emsp; 根据上面的解释。我们其实只要找到最小元素，然后在最小元素比较过程中比较过的元素记录下来，然后我们在这堆元素（上面证明共$\lceil lg n\rceil$个）中找最小元素即可。</p><p>&emsp;具体实现：对于每一个元素，采用数组或链表的结构，每次比较后胜出的元素记录与它比较的元素在原数组的下标，同时自身进入下一轮的比较，根据上面的图可知，每经过一轮比较，元素被筛选掉一半，直至最终仅剩一个元素时，它就是最小元素，返回与它比较元素的元素集合。最终在该集合中寻找第二小元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt;<span class="comment">//记录比较次数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        srand(time(<span class="literal">nullptr</span>));</span><br><span class="line">        for_each(vec.begin(),vec.end(),[](<span class="keyword">int</span> &amp;v)&#123;v=rand();&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSmallestAndCollection(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;* paths)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始状太全是胜者进入下一轮</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; winnerIndex(vec.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;winnerIndex.size();++i)winnerIndex[i]=i;</span><br><span class="line">        <span class="comment">//直到胜者唯一</span></span><br><span class="line">        <span class="keyword">while</span>(winnerIndex.size()!=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            winnerIndex=compareAndStore(vec,winnerIndex,paths);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> paths[winnerIndex[<span class="number">0</span>]];<span class="comment">//最终剩一个返回对于的path</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findSecondSmallest</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *paths)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> smallest2=INF;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path=Solution::findSmallestAndCollection(vec,paths);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:path)<span class="comment">//最 lgn个元素的最小值即是第二小元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vec[i]&lt;smallest2)&#123;</span><br><span class="line">            Solution::cnt++;<span class="comment">//比较次数+1</span></span><br><span class="line">            smallest2=vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> smallest2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; compareAndStore(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;winnerIndex,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;* paths)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> sz=winnerIndex.size();</span><br><span class="line">        <span class="keyword">if</span>(sz&amp;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(winnerIndex[sz<span class="number">-1</span>]);</span><br><span class="line">            --sz;</span><br><span class="line">            <span class="comment">//这里为了方便，奇数个元素时最后一个直接加入，同时数组大小-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;sz;i+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//小的加入ret进入下一轮，同时记录它的比较元素下标</span></span><br><span class="line">            <span class="keyword">if</span>(arr[winnerIndex[i]]&lt;=arr[winnerIndex[i<span class="number">-1</span>]])&#123;</span><br><span class="line">                ret.push_back(winnerIndex[i]);</span><br><span class="line">                paths[winnerIndex[i]].push_back(winnerIndex[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ret.push_back(winnerIndex[i<span class="number">-1</span>]);</span><br><span class="line">                paths[winnerIndex[i<span class="number">-1</span>]].push_back(winnerIndex[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Solution::cnt++;<span class="comment">//比较次数+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Solution::cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showTopTen</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(vec.begin(),vec.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size()&amp;&amp;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; vec[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入元素个数"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; len;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(len);Solution::init(vec);<span class="comment">//产生len个随机数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *comparePath=<span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;[vec.size()];<span class="comment">//建立每个元素比较的路径</span></span><br><span class="line"><span class="keyword">int</span> smallest2=Solution::findSecondSmallest(vec,comparePath);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Second smallest element :"</span>&lt;&lt;smallest2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Compare time O(n+lgn-2) \n Std:"</span> &lt;&lt; (len+<span class="built_in">ceil</span>(<span class="built_in">log</span>(len)/<span class="built_in">log</span>(<span class="number">2</span>))<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nExtra:"</span> &lt;&lt; Solution::cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    showTopTen(vec);<span class="comment">//打印vec最小的10个元素</span></span><br><span class="line">    <span class="keyword">delete</span>[] comparePath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p>该算法主要注重比较次数，但是空间复杂度不乐观（保存比较路径），时间复杂度为 $O(n)$。适合于那种一次比较需要耗费大量时间的值。下面有两篇我解决该题参考的博客。</p><h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><p>只涉及证明：</p><p>博客1：<a href="https://blog.csdn.net/qq_33382034/article/details/53495036" target="_blank" rel="noopener">https://blog.csdn.net/qq_33382034/article/details/53495036</a>  </p><p>包括证明和算法实现（python）</p><p>博客2：<a href="http://windmissing.github.io/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/2015-12/9.1-1-second_smallest_element.html" target="_blank" rel="noopener">http://windmissing.github.io/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/2015-12/9.1-1-second_smallest_element.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法导论9-1-1找第二小的元素&quot;&gt;&lt;a href=&quot;#算法导论9-1-1找第二小的元素&quot; class=&quot;headerlink&quot; title=&quot;算法导论9.1-1找第二小的元素&quot;&gt;&lt;/a&gt;算法导论9.1-1找第二小的元素&lt;/h1&gt;&lt;h2 id=&quot;1、证明：在最坏情
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>主方法求解递归式</title>
    <link href="http://007havegone.github.io/2019/07/22/%E4%B8%BB%E6%96%B9%E6%B3%95%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E5%BC%8F/"/>
    <id>http://007havegone.github.io/2019/07/22/主方法求解递归式/</id>
    <published>2019-07-22T15:49:10.000Z</published>
    <updated>2019-07-30T08:59:09.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主方法求解递归式"><a href="#主方法求解递归式" class="headerlink" title="主方法求解递归式"></a>主方法求解递归式</h1><p>&emsp;&emsp;在分析递归的算法时，主方法可以较快的计算出算法的时间复杂度<br>主方法可以用于满足以下形式的递归式。</p><script type="math/tex; mode=display">T(n)=aT(n/b)+f(n)</script><p>其中$a\geq1和b&gt;1$是常数，$f(n)$是渐进函数。<br>&emsp;&emsp;主方法描述的算法：将原本规模为$n$的问题，分解为 $a$ 个规模为 $n/b$ 的子问题，其中 $a,b\in \mathbb{Z^+}$，函数 $f(n)$ 包含了问题分解和子问题合并的代价。</p><p>下面是归并排序的递归式:</p><script type="math/tex; mode=display">T(n)=\begin{cases}\Theta(1) & 若n=1 \\2T(n/2)+\Theta(n) & 若n>1 \\\end{cases}</script><p>其中，$a=2, b=2, f(n)=\Theta(n^2)。$<br>&emsp;&emsp;在具体处理过程中,会遇到 $n/b$ 可能不是整数的情况。可以将 $a$ 项 $T(n/b)$全都替换为$T(\lfloor n/b \rfloor)或T(\lceil n/b\rceil)$ 并不会影响递归式的渐进性质。</p><hr><h3 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h3><p>主定理：$a\geq1和b&gt;1$是常数，$f(n)$是一个函数，$T(n)$是定义在非负整数上的递归式:</p><script type="math/tex; mode=display">T(n)=aT(n/b)+f(n)</script><p>其中将 $n/b$ 解释为$\lfloor n/b \rfloor或\lceil n/b\rceil$。那么$T(n)$有如下渐近界：</p><p> 1.若对某个常数 $\epsilon &gt;0$有 $f(n)= O(n^{log_ba-\epsilon})$ ,则 $T(n)=\Theta(n^{log_ba})。$</p><p> 2.若$f(n)=\Theta(n^{log_ba})$，则 $T(n)=\Theta(n^{log_ba} lgn)$</p><p> 3.若对某个常数$\epsilon&gt;0$ 有 $f(n)=\Omega(n^{log_ba+\epsilon})$，且对某个常数 $c&lt;1$ 和所有足够大的 $n$ 有 $af(n/b)\leq cf(n)$，则 $T(n)=\Theta(f(n))$。 </p><p>&emsp;&emsp;实际上就是将函数 $f(n)$ 和函数 $n^{log_ba}$ 进行比较。如情况1和情况3，两者的较大者决定了递归式的解。对于情况2，则再乘上一个对数因子 $lgn$ ，解为 $T(n)=\Theta(n^{loa_ba}  lgn)=\Theta(f(n) lgn)$。</p><p><strong>注意:</strong> 对于第1种情况和第3种情况的 $\mathbf{f(n)}$ 渐进小于和渐进大于 $\mathbf{n^{log_ba}}$，其中相差一个因子 $n^\epsilon$，其中 $\epsilon$为大于0的常数，即要满足 <strong>多项式的差距</strong>。同时第三种情况还要满足 “正则”条件 $af(n/b)\leq cf(n)$。</p><p><strong>这三种情况未覆盖 $f(n)$ 的所有可能性。</strong> 即 $f(n)$ 不满足多项式级别的渐进小于 $n^{log_ba}$而处于情况1和情况2之间。同理，不满足 $f(n)$ 渐进大于而处于 $n^{log_ba}$ 而处于情况2和情况2之间，或则情况3而不满足正则条件，均不能使用主方法求解递归式。</p><hr><h3 id="主方法使用例子"><a href="#主方法使用例子" class="headerlink" title="主方法使用例子"></a>主方法使用例子</h3><p>1、</p><script type="math/tex; mode=display">T(n)=9T(n/3)+ n</script><p>其中 $a=9,b=3,f(n)=n$。很容易求解 $n^{log_ba}=n^2=\Theta(n^2)$。<br>有$f(n)=n= O( n^{log_ba-\epsilon})$，其中$\epsilon=1$，故满足情况1，因此得出$T(n)=\Theta(n^2)$。</p><p>2、</p><script type="math/tex; mode=display">T(n)=T(2n/3)+1</script><p>其中 $a=1,b=3/2,f(n)=1$。$n^{log_ba}=n^{log_{3/2}1}=\Theta(1)$。<br>有$f(n)=\Theta(n^{log_ba})=\Theta(1)$。因此满足情况2，则 $T(n)=\Theta(n^{log_ba} lgn)=\Theta(lgn)$。</p><p>3、</p><script type="math/tex; mode=display">T(n)=3T(n/4)+nlgn</script><p>其中 $a=3,b=4,f(n)=nlgn$。$n^{log_ba}=n^{log_43}= O(n^{0.793})$。由于$f(n)=\Omega(n^{log_43+\epsilon})$，其中$\epsilon\approx0.2$。<br>接下来证明正则条件，即</p><script type="math/tex; mode=display">\begin{aligned}af(n/b) & \leq cf(n) \\ 3(n/4)lg(n/4) & \leq  cnlgn\\ \end{aligned}</script><p>显然，当$c=3/4$时，不等式成立。<br>故$T(n)=\Theta(f(n))=\Theta(nlgn)$</p><p>下面这个递归式不能运用主方法<br>4、</p><script type="math/tex; mode=display">T(n)=2T(n/2)+nlgn</script><p>其中 $a=2,b=2,f(n)=nlgn$，$n^{log_ba}=\Theta(n)$，<br>可能会得到错误的结论有：$f(n)=\Omega(n^{log_22+\epsilon})$。然后继续求解下去。<br>实际上，不满足之前提到的情况1和情况3的渐进差距需要时多项式级别的。<br>即：</p><script type="math/tex; mode=display">\frac{nlgn} {n^{log_22}}=\frac {nlgn} {n} = lgn = O(n^\epsilon)</script><blockquote><p>这里的 $\mathbf{\omicron}$ 符号代表非渐进紧确的上界，<br>如：$f(n)=\omicron(g(n))$: $\forall c&gt;0$，$\exists$常量$n_0&gt;0$，使得 $\forall n\geq n_0$，有 $0 \leq f(n) \leq cg(n)$。简单理解小于但不等于。</p></blockquote><p>即不满足多项式级别的大于。故处于情况2和情况3之间。不可以采用主方法求解。</p><h3 id="练习题4-5-1：-建议自己动手做完后对照。"><a href="#练习题4-5-1：-建议自己动手做完后对照。" class="headerlink" title="练习题4.5-1： 建议自己动手做完后对照。"></a>练习题4.5-1： 建议自己动手做完后对照。</h3><p>a.</p><script type="math/tex; mode=display">T(n)=2T(n/4)+1</script><p>其中$a=2,b=4,f(n)=1$, $n^{log_ba}= \sqrt n$。<br>有 $f(n) = O(n^{log_ba-\epsilon}) = O(n^{0.5-\epsilon})$，其中$\epsilon = 0.5$。<br>故 $T(n) = \Theta(n^{log_42}) = \Theta(\sqrt n)$</p><hr><p>b.</p><script type="math/tex; mode=display">T(n)=2T(n/4)+\sqrt{n}</script><p>同上,可以求出 $n^{log_ba}$，由于 $f(n) = \sqrt n =\Theta(\sqrt n) = \Theta(n^{log_42})$<br>故$T(n) = \Theta( f(n)lgn) = \Theta(\sqrt n  lgn)$</p><hr><p>c.</p><script type="math/tex; mode=display">T(n)=2T(n/4)+n</script><p>同上，求出 $n^{log_ba}$，由于 $f(n) = \Omega(n^{0.5 + \epsilon})$, 其中 $\epsilon =0.5$。接下来证明正则条件：</p><script type="math/tex; mode=display">\begin{aligned}af(n/b)  & \leq c f(n)\\2(n/4)    & \leq c \ n\\\frac 1 2  & \leq c\end{aligned}</script><p>显然，取 $c = \frac 1 2$时，满足条件。故 $T(n) = \Theta(f(n)) = \Theta(n)$</p><hr><p>d.</p><script type="math/tex; mode=display">T(n)=2T(n/4)+n^2</script><p>同上，求出 $n^{log_ba}$，由于 $f(n) =  n^2 = \Omega(n^{logb_a+\epsilon})$，其中 $\epsilon = 1.5$。下面证明正则条件：</p><script type="math/tex; mode=display">\begin{aligned}a f(n/b) & \leq c f(n) \\2 (n/4)^2 & \leq c \ n^2 \\n^2/8 & \leq c \ n^2\end{aligned}</script><p>显然，取 $c = 1/8$ 时，满足条件。故 $T(n) = \Theta( f(n) ) = \Theta(n^2)$。</p><p><strong>参考文献：算法导论</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;主方法求解递归式&quot;&gt;&lt;a href=&quot;#主方法求解递归式&quot; class=&quot;headerlink&quot; title=&quot;主方法求解递归式&quot;&gt;&lt;/a&gt;主方法求解递归式&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在分析递归的算法时，主方法可以较快的计算出算法的时间复杂度&lt;br&gt;主
      
    
    </summary>
    
      <category term="算法导论" scheme="http://007havegone.github.io/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="主方法" scheme="http://007havegone.github.io/tags/%E4%B8%BB%E6%96%B9%E6%B3%95/"/>
    
      <category term="时间复杂度" scheme="http://007havegone.github.io/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
      <category term="算法分析" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
      <category term="算法导论" scheme="http://007havegone.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Effective c++ 读书笔记第一章</title>
    <link href="http://007havegone.github.io/2019/07/13/Effective-c-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>http://007havegone.github.io/2019/07/13/Effective-c-读书笔记第一章/</id>
    <published>2019-07-13T14:28:44.000Z</published>
    <updated>2019-07-30T08:59:00.318Z</updated>
    
    <content type="html"><![CDATA[<p><br></p><h1 id="Ⅰ、-让自习惯C"><a href="#Ⅰ、-让自习惯C" class="headerlink" title="Ⅰ、 让自习惯C++"></a>Ⅰ、 让自习惯C++</h1><p><br></p><h2 id="条款01：视C-为一个语言连邦"><a href="#条款01：视C-为一个语言连邦" class="headerlink" title="条款01：视C++为一个语言连邦"></a>条款01：视C++为一个语言连邦</h2><hr><p>C++是一个多重泛型编程语言，同时支持过程形式、面向对象形式、泛型形式、元编程形式的语言。</p><p>将C++是为一个联邦,主要的此语言为4个：</p><p>1.procedural-based C。C语言的面向过程<br>2.Object-Oriented C++。面向对象<br>3.Template C++。 C++ 的泛型 (generics) 编程和由 template 的强大功能带来 template   metaprogramming (TMP,模板元编程)<br>4.STL。template程序库，主要包括 容器、迭代器、算法以及函数对象</p><p><strong>tips:编程过程中在前面3个次语言之间切换时，可能导致高效编程守则要求的改变</strong></p><p><br></p><h2 id="条款02-尽量以-const-enum-inline-替换-define"><a href="#条款02-尽量以-const-enum-inline-替换-define" class="headerlink" title="条款02:尽量以 const, enum, inline 替换 #define"></a>条款02:尽量以 const, enum, inline 替换 #define</h2><hr><h3 id="2-1、采用const替换-define"><a href="#2-1、采用const替换-define" class="headerlink" title="2.1、采用const替换#define"></a>2.1、采用const替换#define</h3><p>此处用宏定义一个常量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure><p>记号名称ASPECT_RATIO可能未被登记到记录表(symbol table), 因为可能在编译前的预处理阶段被替换。<br>导致发生错误时不容易追踪该信息。</p><p>采用常量替换:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span> <span class="comment">//大写名称通常用于宏，此处改变名称写法</span></span><br></pre></td></tr></table></figure><p>常量定义式通常放在头文件</p><p>定义一个常量的 <code>char*based</code>字符串（不可改变指向不可改变内容）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> autorName = <span class="string">"Scott Meyers"</span>; </span><br><span class="line"><span class="comment">//根据c++ primer观点，第一个const为底层const,保证指针指向内容不变</span></span><br><span class="line"><span class="comment">//第二个const为顶层const,保证指针指向地址不变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//采用string</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">autoirName</span><span class="params">(<span class="string">"Scott Meyers"</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>定义一个class的专属常量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns = <span class="number">5</span>; <span class="comment">//这里只是常量声明式，声明式，声明式</span></span><br><span class="line"><span class="keyword">int</span> scores[NumTurns];   <span class="comment">//使用它</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;C++中 class专属常量又是static且为整数类型(eg: int,char,bool).需要特殊处理，如果未取地址，可以只声明，否则需要另外提供定义式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NumTurns;<span class="comment">//类内已经初始化赋值，无须也无法重新赋值。</span></span><br></pre></td></tr></table></figure><p>#define无法为一个 class 定义一个专属变量，因为 #define 并不重视作用域。<br>也就是不存在所谓的 private #define</p><h3 id="2-2、采用enum替换-define"><a href="#2-2、采用enum替换-define" class="headerlink" title="2.2、采用enum替换#define"></a>2.2、采用enum替换#define</h3><p>&emsp;&emsp;旧式编译器不支持 static 成员在声明式上获得初值，”in class” 初值设定也只允许对整数常量进行。<br>此时，需要将初值放在定义式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CostEstimate</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> FudgeFactor;<span class="comment">//static class 常量声明</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span></span><br><span class="line">CostEstimate::FudgeFactor = <span class="number">1.35</span>;<span class="comment">//位于实现文件内</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;类内的数组声明式，编译器坚持必须在编译期间知道数组的大小。如果编译器不允许 “static 整数型class常量” 完成 “in class”初值设定，可改用所谓的 “the enum hack” 补偿做法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span>&#125;;<span class="comment">//"the enum hack"</span></span><br><span class="line"><span class="comment">//令 NumTurns成为5的一个记号名称</span></span><br><span class="line"><span class="keyword">int</span> socres[NumTurns];</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：enum不能取地址</strong></p><h3 id="2-3、采用-template替换-define"><a href="#2-3、采用-template替换-define" class="headerlink" title="2.3、采用 template替换 #define"></a>2.3、采用 template替换 #define</h3><p>另一个常见的 #define 误用情况是以它实现宏（macros）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用宏比较a和b的较大值来调用f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a,b) f(a)&gt;f(b) ? (a) : (b) )</span></span><br></pre></td></tr></table></figure><p>缺点： 要为实参添加小括号防止错误，还有一些不容易发现的错误</p><p>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>,b = <span class="number">0</span>;</span><br><span class="line">CALL_WITH_MAX(++a, b);<span class="comment">//a被累加了两次</span></span><br><span class="line">CALL_WITH_MAX(++a, b+<span class="number">10</span>);<span class="comment">//a被累加了一次</span></span><br></pre></td></tr></table></figure><p>采用template函数替代</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T&amp; a,<span class="keyword">const</span> T&amp; b)</span></span>&#123;<span class="comment">//采用 pass by reference-to-const</span></span><br><span class="line"><span class="comment">//可以传递所有类型.</span></span><br><span class="line">f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h2><hr><h3 id="3-1、const成员函数"><a href="#3-1、const成员函数" class="headerlink" title="3.1、const成员函数"></a>3.1、const成员函数</h3><p>目的：  </p><p>1.使<code>class</code>接口比较容易被理解，那些可以改动，那些不行<br>2.使“操作<code>const</code>对象”称为可能。<code>pass-by-reference-to-const</code>方式传递对象。</p><p><strong><code>const</code>函数可被重载</strong><br>1.<code>const</code>对象只能调用 const版本<br>2.<code>non-const</code>对象可以调用 <code>const</code>和<code>non-const</code>版本，默认为<code>non-const</code>版本。</p><h3 id="3-2、bitwise-constness-和-logical-constness"><a href="#3-2、bitwise-constness-和-logical-constness" class="headerlink" title="3.2、bitwise constness 和 logical constness"></a>3.2、bitwise constness 和 logical constness</h3><blockquote><p>1、<code>bitwise const</code>阵营的人相信，成员函数只有在不改变对象的任何成员变量(static除外)时<br>才可以说是 <code>const</code>。即不改变对象内的任何一个 bit 。<br>这种论点好处是很容易侦测违反点。<br><code>bitwise constness</code>正是 C++ 对常量性的定义，因此 const 成员函数不可以更改对象内的<br>任何<code>non-static</code>成员变量。</p></blockquote><p>不幸的是很多不具备<code>const</code>性质的函数却可以通过 <code>bitwise</code>测试。<br>实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span><span class="comment">//bit const声明</span></span><br><span class="line">&#123; <span class="keyword">return</span> pText[position]; &#125;<span class="comment">//但实际没起到效果</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span>* pText;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//此时</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> CTextBlock <span class="title">cctb</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;<span class="comment">//声明一个常量对象</span></span><br><span class="line"><span class="keyword">char</span> *pc = &amp;cctb[<span class="number">0</span>];</span><br><span class="line">*pc = <span class="string">'J'</span>;<span class="comment">//此时cctb变为 “Jello”</span></span><br></pre></td></tr></table></figure><blockquote><p>2、这种情况导出了所谓的<code>logical constness</code>。他们主张，一个 <code>const</code>成员函数<br>可以修改它所处理的对象内的某些 bits, 但只有在客户端侦测不出的情况下才得如此。  </p></blockquote><p>例如： CTextBlock class有可能高速缓存文本区域的长度以便询问：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> length() <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> *pText;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> textLength;<span class="comment">//最近一次计算的文本区域长度</span></span><br><span class="line"><span class="keyword">bool</span> lengthIsValid;<span class="comment">//当前长度是否有效</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> CTextBlock::length() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!lengthIsValid)&#123;</span><br><span class="line">textLength = <span class="built_in">std</span>::<span class="built_in">strlen</span>(pText);<span class="comment">//error!!! const函数内</span></span><br><span class="line">lengthIsValid = <span class="literal">true</span>;<span class="comment">//不允许修改类成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案 <code>mutable</code>释放 <code>non-static</code>成员变量的<code>bitwise constness</code>约束</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> length() <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> *pText;</span><br><span class="line"><span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> textLength;<span class="comment">//mutable可能总是会被更改，</span></span><br><span class="line"><span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid;<span class="comment">//即使在const函数内</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> CTextBlock::length() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!lengthIsValid)&#123;</span><br><span class="line">textLength = <span class="built_in">std</span>::<span class="built_in">strlen</span>(pText);<span class="comment">//现在valid</span></span><br><span class="line">lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3、在-const-和-non-const-成员函数中避免重复"><a href="#3-3、在-const-和-non-const-成员函数中避免重复" class="headerlink" title="3.3、在 const 和 non-const 成员函数中避免重复"></a>3.3、在 const 和 non-const 成员函数中避免重复</h3><p>假设TextBlock的 operator[] 不单单返回一个 reference，还要做各种检测，<br>这样会导致写出的 const 和 non-const operator[] 冗余。</p><p><strong>解决方案 令 non-const版本调用 const版本</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span> <span class="comment">//一如既往</span></span><br><span class="line">&#123; ...</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line"> <span class="keyword">return</span> text[position];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position)<span class="comment">//调用 const版本</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&gt;&amp;(<span class="comment">//将op[]返回值的const转除</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)<span class="comment">//为*this加上const</span></span><br><span class="line">[position];<span class="comment">//调用 const op[];</span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：反向操作将 const函数调用 non-const是不可取的</strong></p><p><br></p><h2 id="条款04：确定对象使用前已被初始化"><a href="#条款04：确定对象使用前已被初始化" class="headerlink" title="条款04：确定对象使用前已被初始化"></a>条款04：确定对象使用前已被初始化</h2><p>定义类Point</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Point p;<span class="comment">//p成员变量有时候会被初始化（为0），有时候不会</span></span><br></pre></td></tr></table></figure><p>1.使用 C part of C++ 而且初始化可能招致运行期成本，那么不保证初始化<br>2.non-C parts of C++,则有所变化，如 vector（STL part of C++）保证初始化,<br> array（C part of C++) 不保证内容初始化。</p><p><strong>最佳处理办法</strong>： 永远在使用对象前先将其初始化。对于无任何成员的内置类型，你必须手工完成此事。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;<span class="comment">//对int初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* text = <span class="string">"A C-style string//对指针初始化</span></span><br><span class="line"><span class="string">double d;</span></span><br><span class="line"><span class="string">std::cin &gt;&gt; d;//调用输入流初始化</span></span><br></pre></td></tr></table></figure><h3 id="4-1、区分赋值和初始化"><a href="#4-1、区分赋值和初始化" class="headerlink" title="4.1、区分赋值和初始化"></a>4.1、区分赋值和初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> &#123;</span> ...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ABEntry</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; address,  <span class="comment">//构造函数</span></span><br><span class="line"> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt;&amp; phones);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> theName;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> theAddress;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt; thePhones;</span><br><span class="line"><span class="keyword">int</span> numTimesConsulted;</span><br><span class="line">&#125;;</span><br><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; address,  </span><br><span class="line"> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">&#123;</span><br><span class="line">theName = name;<span class="comment">//这些都是赋值</span></span><br><span class="line">theAddress = address;<span class="comment">//而非初始化</span></span><br><span class="line">thePhone = phones;</span><br><span class="line">numTimesConsulted = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对象的初始化发生在进入构造函数之前，故以上的 theName, theAddress 和 thePhones均不是初始化，而是赋值。初始化发生在某些对象的default构造函数调用时，此时未进入ABEntry构造函数体，而对于 numTimesConsulted这类内置类型，赋值动作的时间点不确定。</p><p>采用 <strong>member initialization list (成员初值列）</strong>来为对象的成员初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; address,  </span><br><span class="line"> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">:theName(name),<span class="comment">//此处均为初始化，如果</span></span><br><span class="line"> theAddress(address),<span class="comment">//类成员没有在指定，编译器</span></span><br><span class="line"> thePhones(phones),<span class="comment">//调用默认构造函数</span></span><br><span class="line"> numTimesCosulted(<span class="number">0</span>)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>如果成员变量为 <code>const 或 references</code>，则一定需要初值，不能被赋值。</p><p><strong>C++成员初始化次序</strong><br>base classes 更早由于其 drived classes 被初始化，而 class 的成员变量按照成员声明次序被初始化</p><h3 id="4-2、不同编译单元内定义的-non-local-static-对象的初始化次序"><a href="#4-2、不同编译单元内定义的-non-local-static-对象的初始化次序" class="headerlink" title="4.2、不同编译单元内定义的 non-local static 对象的初始化次序"></a>4.2、不同编译单元内定义的 non-local static 对象的初始化次序</h3><p><strong>local static对象</strong>： 寿命从构造直至程序结束为止，因此不包括 <code>stack</code>和<code>heap-based对象</code>。这种对象包括 <code>global</code>对象 、定义于<code>namespace</code>作用域内的对象、在<code>classed</code>内、在函数内、以及在 file作域内被声明为 <code>static</code>的对象。<br>函数内的 <code>static</code>对象称为为 <code>local static</code>对象(它们相对函数而言为 <code>local</code>)，其他 <code>static</code>对象称为 <code>non-local static</code>对象。它们的析构函数会在 <code>main()</code>结束时自动调用。</p><p><strong>编译单源</strong>：是指产出单一目标文件的那些源码。基本上它是单一源码文件加上其所含的头文件。</p><p>问题在于<strong>C++对于定义于不同编译单元内的 <code>non-local static</code>对象的初始化次序并无明确定义</strong></p><p>实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span>&#123;</span><span class="comment">//编译单元A</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> numDisk() <span class="keyword">const</span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;<span class="comment">//预备给用户使用的对象</span></span><br><span class="line"><span class="comment">/*----------------------------------------------------------*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Directory( params); <span class="comment">//编译单元B</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">Directory::Directory( params)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> disks = tfs.numDisks();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设，采用 创建一个 Driectory对象  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Directory <span class="title">tempDir</span><span class="params">( params)</span></span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时 tempDir构造函数调用了 dfs函数对象，故 dfs必须先于 tempDir初始化，否则后果很严重。以下是解决方案：</p><p><strong>采用 <code>local static</code>对象替换 <code>non-local static</code>对象</strong><br><strong>这是 <code>Singleton</code>模式的一个常见手法</strong></p><p>这个手法基础在于：C++保证,函数内的<code>local static</code>对象会在“该函数被调用期间”<br>“首次遇上该对象的定义式”时被初始化。如果函数从未调用，则不会生成对象，<br>也免去了多余的构造函数析构函数的调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span>&#123;</span>...&#125;;<span class="comment">//同前</span></span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span><span class="comment">//定义一个local static对象 </span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//返回一个reference</span></span><br><span class="line"><span class="keyword">static</span> FileSystem fs;</span><br><span class="line"><span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span>&#123;</span>...&#125;;<span class="comment">//同前</span></span><br><span class="line">Directory::Directory( params)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> disk = tfs().numDisks();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span><span class="comment">//同前,返回一个 reference to tfs</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> Directory td;</span><br><span class="line"><span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以上的 <code>reference-returing</code></strong>函数往往十分单纯：定义并初始化一个<code>local static</code>，然后返回它。</p><p><strong>注意：这些内含 <code>static</code>对象的事实使他们在多线程有不确定性。任何一种 <code>non-const static</code>对象，无论是<code>local</code>还是<code>non-local</code>，多线程环境下的等待某事发生都会有麻烦。</strong></p><p><strong>解决方案：在程序单线程启动阶段手工调用所有reference-returing函数，可以消除与初始化有关的“竞速形势”。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&quot;Ⅰ、-让自习惯C&quot;&gt;&lt;a href=&quot;#Ⅰ、-让自习惯C&quot; class=&quot;headerlink&quot; title=&quot;Ⅰ、 让自习惯C++&quot;&gt;&lt;/a&gt;Ⅰ、 让自习惯C++&lt;/h1&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;条款01：视C-为一个语言
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://007havegone.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://007havegone.github.io/tags/C/"/>
    
      <category term="Effective C++" scheme="http://007havegone.github.io/tags/Effective-C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://007havegone.github.io/2019/07/13/hello-world/"/>
    <id>http://007havegone.github.io/2019/07/13/hello-world/</id>
    <published>2019-07-12T16:00:00.000Z</published>
    <updated>2019-07-13T12:11:52.535Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
